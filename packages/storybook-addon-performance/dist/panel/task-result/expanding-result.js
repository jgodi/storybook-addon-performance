"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/@storybook/components/dist/chunk-NNAAFZ4U.mjs
var __create2, __defProp2, __getOwnPropDesc2, __getOwnPropNames2, __getProtoOf2, __hasOwnProp2, __commonJS2, __copyProps2, __toESM2;
var init_chunk_NNAAFZ4U = __esm({
  "../../node_modules/@storybook/components/dist/chunk-NNAAFZ4U.mjs"() {
    __create2 = Object.create;
    __defProp2 = Object.defineProperty;
    __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    __getOwnPropNames2 = Object.getOwnPropertyNames;
    __getProtoOf2 = Object.getPrototypeOf;
    __hasOwnProp2 = Object.prototype.hasOwnProperty;
    __commonJS2 = (cb, mod) => function() {
      return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from == "object" || typeof from == "function")
        for (let key of __getOwnPropNames2(from))
          !__hasOwnProp2.call(to, key) && key !== except && __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      return to;
    };
    __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  }
});

// ../../node_modules/@storybook/components/dist/chunk-4REFJGR7.mjs
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
var require_window;
var init_chunk_4REFJGR7 = __esm({
  "../../node_modules/@storybook/components/dist/chunk-4REFJGR7.mjs"() {
    init_chunk_NNAAFZ4U();
    require_window = __commonJS2({ "../../node_modules/global/window.js"(exports, module2) {
      var win;
      typeof window < "u" ? win = window : typeof global < "u" ? win = global : typeof self < "u" ? win = self : win = {};
      module2.exports = win;
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-S72H4O6B.mjs
var require_markdown;
var init_chunk_S72H4O6B = __esm({
  "../../node_modules/@storybook/components/dist/chunk-S72H4O6B.mjs"() {
    init_chunk_NNAAFZ4U();
    require_markdown = __commonJS2({ "../../node_modules/refractor/lang/markdown.js"(exports, module2) {
      module2.exports = markdown;
      markdown.displayName = "markdown";
      markdown.aliases = ["md"];
      function markdown(Prism) {
        (function(Prism2) {
          var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
          function createInline(pattern) {
            return pattern = pattern.replace(/<inner>/g, function() {
              return inner;
            }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
          }
          var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
            return tableCell;
          }), tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
          Prism2.languages.markdown = Prism2.languages.extend("markup", {}), Prism2.languages.insertBefore("markdown", "prolog", { "front-matter-block": { pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/, lookbehind: true, greedy: true, inside: { punctuation: /^---|---$/, "front-matter": { pattern: /\S+(?:\s+\S+)*/, alias: ["yaml", "language-yaml"], inside: Prism2.languages.yaml } } }, blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" }, table: { pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"), inside: { "table-data-rows": { pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"), lookbehind: true, inside: { "table-data": { pattern: RegExp(tableCell), inside: Prism2.languages.markdown }, punctuation: /\|/ } }, "table-line": { pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"), lookbehind: true, inside: { punctuation: /\||:?-{3,}:?/ } }, "table-header-row": { pattern: RegExp("^" + tableRow + "$"), inside: { "table-header": { pattern: RegExp(tableCell), alias: "important", inside: Prism2.languages.markdown }, punctuation: /\|/ } } } }, code: [{ pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/, lookbehind: true, alias: "keyword" }, { pattern: /^```[\s\S]*?^```$/m, greedy: true, inside: { "code-block": { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: true }, "code-language": { pattern: /^(```).+/, lookbehind: true }, punctuation: /```/ } }], title: [{ pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m, alias: "important", inside: { punctuation: /==+$|--+$/ } }, { pattern: /(^\s*)#.+/m, lookbehind: true, alias: "important", inside: { punctuation: /^#+|#+$/ } }], hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: true, alias: "punctuation" }, list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: true, alias: "punctuation" }, "url-reference": { pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/, inside: { variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: true }, string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/, punctuation: /^[\[\]!:]|[<>]/ }, alias: "url" }, bold: { pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: true, inside: {} }, punctuation: /\*\*|__/ } }, italic: { pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: true, inside: {} }, punctuation: /[*_]/ } }, strike: { pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: true, inside: {} }, punctuation: /~~?/ } }, "code-snippet": { pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/, lookbehind: true, greedy: true, alias: ["code", "keyword"] }, url: { pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source), lookbehind: true, greedy: true, inside: { operator: /^!/, content: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: true, inside: {} }, variable: { pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/, lookbehind: true }, url: { pattern: /(^\]\()[^\s)]+/, lookbehind: true }, string: { pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/, lookbehind: true } } } }), ["url", "bold", "italic", "strike"].forEach(function(token) {
            ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
              token !== inside && (Prism2.languages.markdown[token].inside.content.inside[inside] = Prism2.languages.markdown[inside]);
            });
          }), Prism2.hooks.add("after-tokenize", function(env) {
            if (env.language !== "markdown" && env.language !== "md")
              return;
            function walkTokens(tokens) {
              if (!(!tokens || typeof tokens == "string"))
                for (var i = 0, l = tokens.length; i < l; i++) {
                  var token = tokens[i];
                  if (token.type !== "code") {
                    walkTokens(token.content);
                    continue;
                  }
                  var codeLang = token.content[1], codeBlock = token.content[3];
                  if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content == "string") {
                    var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
                    lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
                    var alias = "language-" + lang;
                    codeBlock.alias ? typeof codeBlock.alias == "string" ? codeBlock.alias = [codeBlock.alias, alias] : codeBlock.alias.push(alias) : codeBlock.alias = [alias];
                  }
                }
            }
            walkTokens(env.tokens);
          }), Prism2.hooks.add("wrap", function(env) {
            if (env.type === "code-block") {
              for (var codeLang = "", i = 0, l = env.classes.length; i < l; i++) {
                var cls = env.classes[i], match2 = /language-(.+)/.exec(cls);
                if (match2) {
                  codeLang = match2[1];
                  break;
                }
              }
              var grammar = Prism2.languages[codeLang];
              if (grammar)
                env.content = Prism2.highlight(textContent(env.content.value), grammar, codeLang);
              else if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
                var id = "md-" + new Date().valueOf() + "-" + Math.floor(Math.random() * 1e16);
                env.attributes.id = id, Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
                  var ele = document.getElementById(id);
                  ele && (ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang));
                });
              }
            }
          });
          var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi"), KNOWN_ENTITY_NAMES = { amp: "&", lt: "<", gt: ">", quot: '"' }, fromCodePoint = String.fromCodePoint || String.fromCharCode;
          function textContent(html) {
            var text = html.replace(tagPattern, "");
            return text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m, code) {
              if (code = code.toLowerCase(), code[0] === "#") {
                var value;
                return code[1] === "x" ? value = parseInt(code.slice(2), 16) : value = Number(code.slice(1)), fromCodePoint(value);
              } else {
                var known = KNOWN_ENTITY_NAMES[code];
                return known || m;
              }
            }), text;
          }
          Prism2.languages.md = Prism2.languages.markdown;
        })(Prism);
      }
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-CR4N7OJN.mjs
var require_yaml;
var init_chunk_CR4N7OJN = __esm({
  "../../node_modules/@storybook/components/dist/chunk-CR4N7OJN.mjs"() {
    init_chunk_NNAAFZ4U();
    require_yaml = __commonJS2({ "../../node_modules/refractor/lang/yaml.js"(exports, module2) {
      module2.exports = yaml;
      yaml.displayName = "yaml";
      yaml.aliases = ["yml"];
      function yaml(Prism) {
        (function(Prism2) {
          var anchorOrAlias = /[*&][^\s[\]{},]+/, tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)", plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
            return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
          }), string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
          function createValuePattern(value, flags) {
            flags = (flags || "").replace(/m/g, "") + "m";
            var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
              return properties;
            }).replace(/<<value>>/g, function() {
              return value;
            });
            return RegExp(pattern, flags);
          }
          Prism2.languages.yaml = { scalar: { pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
            return properties;
          })), lookbehind: true, alias: "string" }, comment: /#.*/, key: { pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
            return properties;
          }).replace(/<<key>>/g, function() {
            return "(?:" + plainKey + "|" + string + ")";
          })), lookbehind: true, greedy: true, alias: "atrule" }, directive: { pattern: /(^[ \t]*)%.+/m, lookbehind: true, alias: "important" }, datetime: { pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source), lookbehind: true, alias: "number" }, boolean: { pattern: createValuePattern(/false|true/.source, "i"), lookbehind: true, alias: "important" }, null: { pattern: createValuePattern(/null|~/.source, "i"), lookbehind: true, alias: "important" }, string: { pattern: createValuePattern(string), lookbehind: true, greedy: true }, number: { pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"), lookbehind: true }, tag, important: anchorOrAlias, punctuation: /---|[:[\]{}\-,|>?]|\.\.\./ }, Prism2.languages.yml = Prism2.languages.yaml;
        })(Prism);
      }
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-XWWAUDHM.mjs
var require_typescript;
var init_chunk_XWWAUDHM = __esm({
  "../../node_modules/@storybook/components/dist/chunk-XWWAUDHM.mjs"() {
    init_chunk_NNAAFZ4U();
    require_typescript = __commonJS2({ "../../node_modules/refractor/lang/typescript.js"(exports, module2) {
      module2.exports = typescript;
      typescript.displayName = "typescript";
      typescript.aliases = ["ts"];
      function typescript(Prism) {
        (function(Prism2) {
          Prism2.languages.typescript = Prism2.languages.extend("javascript", { "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/, lookbehind: true, greedy: true, inside: null }, builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/ }), Prism2.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[\{*]|$))/), delete Prism2.languages.typescript.parameter, delete Prism2.languages.typescript["literal-property"];
          var typeInside = Prism2.languages.extend("typescript", {});
          delete typeInside["class-name"], Prism2.languages.typescript["class-name"].inside = typeInside, Prism2.languages.insertBefore("typescript", "function", { decorator: { pattern: /@[$\w\xA0-\uFFFF]+/, inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\s\S]+/ } }, "generic-function": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/, greedy: true, inside: { function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: typeInside } } } }), Prism2.languages.ts = Prism2.languages.typescript;
        })(Prism);
      }
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-R5KWTIWY.mjs
var require_jsx;
var init_chunk_R5KWTIWY = __esm({
  "../../node_modules/@storybook/components/dist/chunk-R5KWTIWY.mjs"() {
    init_chunk_NNAAFZ4U();
    require_jsx = __commonJS2({ "../../node_modules/refractor/lang/jsx.js"(exports, module2) {
      module2.exports = jsx;
      jsx.displayName = "jsx";
      jsx.aliases = [];
      function jsx(Prism) {
        (function(Prism2) {
          var javascript = Prism2.util.clone(Prism2.languages.javascript), space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
          function re(source, flags) {
            return source = source.replace(/<S>/g, function() {
              return space;
            }).replace(/<BRACES>/g, function() {
              return braces;
            }).replace(/<SPREAD>/g, function() {
              return spread;
            }), RegExp(source, flags);
          }
          spread = re(spread).source, Prism2.languages.jsx = Prism2.languages.extend("markup", javascript), Prism2.languages.jsx.tag.pattern = re(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source), Prism2.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, Prism2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, Prism2.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, Prism2.languages.jsx.tag.inside.comment = javascript.comment, Prism2.languages.insertBefore("inside", "attr-name", { spread: { pattern: re(/<SPREAD>/.source), inside: Prism2.languages.jsx } }, Prism2.languages.jsx.tag), Prism2.languages.insertBefore("inside", "special-attr", { script: { pattern: re(/=<BRACES>/.source), alias: "language-javascript", inside: { "script-punctuation": { pattern: /^=(?=\{)/, alias: "punctuation" }, rest: Prism2.languages.jsx } } }, Prism2.languages.jsx.tag);
          var stringifyToken = function(token) {
            return token ? typeof token == "string" ? token : typeof token.content == "string" ? token.content : token.content.map(stringifyToken).join("") : "";
          }, walkTokens = function(tokens) {
            for (var openedTags = [], i = 0; i < tokens.length; i++) {
              var token = tokens[i], notTagNorBrace = false;
              if (typeof token != "string" && (token.type === "tag" && token.content[0] && token.content[0].type === "tag" ? token.content[0].content[0].content === "</" ? openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1]) && openedTags.pop() : token.content[token.content.length - 1].content === "/>" || openedTags.push({ tagName: stringifyToken(token.content[0].content[1]), openedBraces: 0 }) : openedTags.length > 0 && token.type === "punctuation" && token.content === "{" ? openedTags[openedTags.length - 1].openedBraces++ : openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}" ? openedTags[openedTags.length - 1].openedBraces-- : notTagNorBrace = true), (notTagNorBrace || typeof token == "string") && openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
                var plainText = stringifyToken(token);
                i < tokens.length - 1 && (typeof tokens[i + 1] == "string" || tokens[i + 1].type === "plain-text") && (plainText += stringifyToken(tokens[i + 1]), tokens.splice(i + 1, 1)), i > 0 && (typeof tokens[i - 1] == "string" || tokens[i - 1].type === "plain-text") && (plainText = stringifyToken(tokens[i - 1]) + plainText, tokens.splice(i - 1, 1), i--), tokens[i] = new Prism2.Token("plain-text", plainText, null, plainText);
              }
              token.content && typeof token.content != "string" && walkTokens(token.content);
            }
          };
          Prism2.hooks.add("after-tokenize", function(env) {
            env.language !== "jsx" && env.language !== "tsx" || walkTokens(env.tokens);
          });
        })(Prism);
      }
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-Q5VTUGLN.mjs
var require_tsx;
var init_chunk_Q5VTUGLN = __esm({
  "../../node_modules/@storybook/components/dist/chunk-Q5VTUGLN.mjs"() {
    init_chunk_XWWAUDHM();
    init_chunk_R5KWTIWY();
    init_chunk_NNAAFZ4U();
    require_tsx = __commonJS2({ "../../node_modules/refractor/lang/tsx.js"(exports, module2) {
      var refractorJsx = require_jsx(), refractorTypescript = require_typescript();
      module2.exports = tsx;
      tsx.displayName = "tsx";
      tsx.aliases = [];
      function tsx(Prism) {
        Prism.register(refractorJsx), Prism.register(refractorTypescript), function(Prism2) {
          var typescript = Prism2.util.clone(Prism2.languages.typescript);
          Prism2.languages.tsx = Prism2.languages.extend("jsx", typescript), delete Prism2.languages.tsx.parameter, delete Prism2.languages.tsx["literal-property"];
          var tag = Prism2.languages.tsx.tag;
          tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")", tag.pattern.flags), tag.lookbehind = true;
        }(Prism);
      }
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-KMON5KHC.mjs
var require_clike;
var init_chunk_KMON5KHC = __esm({
  "../../node_modules/@storybook/components/dist/chunk-KMON5KHC.mjs"() {
    init_chunk_NNAAFZ4U();
    require_clike = __commonJS2({ "../../node_modules/refractor/lang/clike.js"(exports, module2) {
      module2.exports = clike;
      clike.displayName = "clike";
      clike.aliases = [];
      function clike(Prism) {
        Prism.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/, boolean: /\b(?:false|true)\b/, function: /\b\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/ };
      }
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-FXDDSU3L.mjs
var require_javascript;
var init_chunk_FXDDSU3L = __esm({
  "../../node_modules/@storybook/components/dist/chunk-FXDDSU3L.mjs"() {
    init_chunk_NNAAFZ4U();
    require_javascript = __commonJS2({ "../../node_modules/refractor/lang/javascript.js"(exports, module2) {
      module2.exports = javascript;
      javascript.displayName = "javascript";
      javascript.aliases = ["js"];
      function javascript(Prism) {
        Prism.languages.javascript = Prism.languages.extend("clike", { "class-name": [Prism.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/, lookbehind: true }], keyword: [{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: true }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, number: { pattern: RegExp(/(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source), lookbehind: true }, operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/ }), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/, lookbehind: true, greedy: true, inside: { "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: true, alias: "language-regex", inside: Prism.languages.regex }, "regex-delimiter": /^\/|\/$/, "regex-flags": /^[a-z]+$/ } }, "function-variable": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/, lookbehind: true, inside: Prism.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ }), Prism.languages.insertBefore("javascript", "string", { hashbang: { pattern: /^#!.*/, greedy: true, alias: "comment" }, "template-string": { pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/, lookbehind: true, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: Prism.languages.javascript } }, string: /[\s\S]+/ } }, "string-property": { pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m, lookbehind: true, greedy: true, alias: "property" } }), Prism.languages.insertBefore("javascript", "operator", { "literal-property": { pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m, lookbehind: true, alias: "property" } }), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")), Prism.languages.js = Prism.languages.javascript;
      }
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-YTVVV3IZ.mjs
var require_css;
var init_chunk_YTVVV3IZ = __esm({
  "../../node_modules/@storybook/components/dist/chunk-YTVVV3IZ.mjs"() {
    init_chunk_NNAAFZ4U();
    require_css = __commonJS2({ "../../node_modules/refractor/lang/css.js"(exports, module2) {
      module2.exports = css;
      css.displayName = "css";
      css.aliases = [];
      function css(Prism) {
        (function(Prism2) {
          var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
          Prism2.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/, inside: { rule: /^@[\w-]+/, "selector-function-argument": { pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/, lookbehind: true, alias: "selector" }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: true } } }, url: { pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"), greedy: true, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + string.source + "$"), alias: "url" } } }, selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"), lookbehind: true }, string: { pattern: string, greedy: true }, property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: true }, important: /!important\b/i, function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: true }, punctuation: /[(){};:,]/ }, Prism2.languages.css.atrule.inside.rest = Prism2.languages.css;
          var markup = Prism2.languages.markup;
          markup && (markup.tag.addInlined("style", "css"), markup.tag.addAttribute("style", "css"));
        })(Prism);
      }
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-I3OL67LK.mjs
var require_markup;
var init_chunk_I3OL67LK = __esm({
  "../../node_modules/@storybook/components/dist/chunk-I3OL67LK.mjs"() {
    init_chunk_NNAAFZ4U();
    require_markup = __commonJS2({ "../../node_modules/refractor/lang/markup.js"(exports, module2) {
      module2.exports = markup;
      markup.displayName = "markup";
      markup.aliases = ["html", "mathml", "svg", "xml", "ssml", "atom", "rss"];
      function markup(Prism) {
        Prism.languages.markup = { comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: true }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: true }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: true, inside: { "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: true, greedy: true, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: true }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: true }, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: true, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(env) {
          env.type === "entity" && (env.attributes.title = env.content.value.replace(/&amp;/, "&"));
        }), Object.defineProperty(Prism.languages.markup.tag, "addInlined", { value: function(tagName, lang) {
          var includedCdataInside = {};
          includedCdataInside["language-" + lang] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: true, inside: Prism.languages[lang] }, includedCdataInside.cdata = /^<!\[CDATA\[|\]\]>$/i;
          var inside = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: includedCdataInside } };
          inside["language-" + lang] = { pattern: /[\s\S]+/, inside: Prism.languages[lang] };
          var def = {};
          def[tagName] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"), lookbehind: true, greedy: true, inside }, Prism.languages.insertBefore("markup", "cdata", def);
        } }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", { value: function(attrName, lang) {
          Prism.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"), lookbehind: true, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: true, alias: [lang, "language-" + lang], inside: Prism.languages[lang] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } });
        } }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml;
      }
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-6GBBAFYE.mjs
var require_immutable, require_schema, require_merge, require_normalize, require_info, require_types, require_defined_info, require_create, require_xlink, require_xml, require_case_sensitive_transform, require_case_insensitive_transform, require_xmlns, require_aria, require_html, require_html2, require_find, require_hast_util_parse_selector, require_space_separated_tokens, require_comma_separated_tokens, require_factory, require_html3, require_hastscript, require_character_entities_legacy, require_character_reference_invalid, require_is_decimal, require_is_hexadecimal, require_is_alphabetical, require_is_alphanumerical, require_character_entities, require_decode_entity, require_parse_entities, require_prism_core, require_core;
var init_chunk_6GBBAFYE = __esm({
  "../../node_modules/@storybook/components/dist/chunk-6GBBAFYE.mjs"() {
    init_chunk_KMON5KHC();
    init_chunk_FXDDSU3L();
    init_chunk_YTVVV3IZ();
    init_chunk_I3OL67LK();
    init_chunk_NNAAFZ4U();
    require_immutable = __commonJS2({ "../../node_modules/xtend/immutable.js"(exports, module2) {
      module2.exports = extend;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function extend() {
        for (var target = {}, i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }
    } });
    require_schema = __commonJS2({ "../../node_modules/property-information/lib/util/schema.js"(exports, module2) {
      "use strict";
      module2.exports = Schema;
      var proto = Schema.prototype;
      proto.space = null;
      proto.normal = {};
      proto.property = {};
      function Schema(property, normal, space) {
        this.property = property, this.normal = normal, space && (this.space = space);
      }
    } });
    require_merge = __commonJS2({ "../../node_modules/property-information/lib/util/merge.js"(exports, module2) {
      "use strict";
      var xtend = require_immutable(), Schema = require_schema();
      module2.exports = merge;
      function merge(definitions) {
        for (var length2 = definitions.length, property = [], normal = [], index3 = -1, info, space; ++index3 < length2; )
          info = definitions[index3], property.push(info.property), normal.push(info.normal), space = info.space;
        return new Schema(xtend.apply(null, property), xtend.apply(null, normal), space);
      }
    } });
    require_normalize = __commonJS2({ "../../node_modules/property-information/normalize.js"(exports, module2) {
      "use strict";
      module2.exports = normalize;
      function normalize(value) {
        return value.toLowerCase();
      }
    } });
    require_info = __commonJS2({ "../../node_modules/property-information/lib/util/info.js"(exports, module2) {
      "use strict";
      module2.exports = Info;
      var proto = Info.prototype;
      proto.space = null;
      proto.attribute = null;
      proto.property = null;
      proto.boolean = false;
      proto.booleanish = false;
      proto.overloadedBoolean = false;
      proto.number = false;
      proto.commaSeparated = false;
      proto.spaceSeparated = false;
      proto.commaOrSpaceSeparated = false;
      proto.mustUseProperty = false;
      proto.defined = false;
      function Info(property, attribute) {
        this.property = property, this.attribute = attribute;
      }
    } });
    require_types = __commonJS2({ "../../node_modules/property-information/lib/util/types.js"(exports) {
      "use strict";
      var powers = 0;
      exports.boolean = increment();
      exports.booleanish = increment();
      exports.overloadedBoolean = increment();
      exports.number = increment();
      exports.spaceSeparated = increment();
      exports.commaSeparated = increment();
      exports.commaOrSpaceSeparated = increment();
      function increment() {
        return Math.pow(2, ++powers);
      }
    } });
    require_defined_info = __commonJS2({ "../../node_modules/property-information/lib/util/defined-info.js"(exports, module2) {
      "use strict";
      var Info = require_info(), types = require_types();
      module2.exports = DefinedInfo;
      DefinedInfo.prototype = new Info();
      DefinedInfo.prototype.defined = true;
      var checks = ["boolean", "booleanish", "overloadedBoolean", "number", "commaSeparated", "spaceSeparated", "commaOrSpaceSeparated"], checksLength = checks.length;
      function DefinedInfo(property, attribute, mask, space) {
        var index3 = -1, check;
        for (mark(this, "space", space), Info.call(this, property, attribute); ++index3 < checksLength; )
          check = checks[index3], mark(this, check, (mask & types[check]) === types[check]);
      }
      function mark(values, key, value) {
        value && (values[key] = value);
      }
    } });
    require_create = __commonJS2({ "../../node_modules/property-information/lib/util/create.js"(exports, module2) {
      "use strict";
      var normalize = require_normalize(), Schema = require_schema(), DefinedInfo = require_defined_info();
      module2.exports = create;
      function create(definition) {
        var space = definition.space, mustUseProperty = definition.mustUseProperty || [], attributes = definition.attributes || {}, props = definition.properties, transform = definition.transform, property = {}, normal = {}, prop, info;
        for (prop in props)
          info = new DefinedInfo(prop, transform(attributes, prop), props[prop], space), mustUseProperty.indexOf(prop) !== -1 && (info.mustUseProperty = true), property[prop] = info, normal[normalize(prop)] = prop, normal[normalize(info.attribute)] = prop;
        return new Schema(property, normal, space);
      }
    } });
    require_xlink = __commonJS2({ "../../node_modules/property-information/lib/xlink.js"(exports, module2) {
      "use strict";
      var create = require_create();
      module2.exports = create({ space: "xlink", transform: xlinkTransform, properties: { xLinkActuate: null, xLinkArcRole: null, xLinkHref: null, xLinkRole: null, xLinkShow: null, xLinkTitle: null, xLinkType: null } });
      function xlinkTransform(_, prop) {
        return "xlink:" + prop.slice(5).toLowerCase();
      }
    } });
    require_xml = __commonJS2({ "../../node_modules/property-information/lib/xml.js"(exports, module2) {
      "use strict";
      var create = require_create();
      module2.exports = create({ space: "xml", transform: xmlTransform, properties: { xmlLang: null, xmlBase: null, xmlSpace: null } });
      function xmlTransform(_, prop) {
        return "xml:" + prop.slice(3).toLowerCase();
      }
    } });
    require_case_sensitive_transform = __commonJS2({ "../../node_modules/property-information/lib/util/case-sensitive-transform.js"(exports, module2) {
      "use strict";
      module2.exports = caseSensitiveTransform;
      function caseSensitiveTransform(attributes, attribute) {
        return attribute in attributes ? attributes[attribute] : attribute;
      }
    } });
    require_case_insensitive_transform = __commonJS2({ "../../node_modules/property-information/lib/util/case-insensitive-transform.js"(exports, module2) {
      "use strict";
      var caseSensitiveTransform = require_case_sensitive_transform();
      module2.exports = caseInsensitiveTransform;
      function caseInsensitiveTransform(attributes, property) {
        return caseSensitiveTransform(attributes, property.toLowerCase());
      }
    } });
    require_xmlns = __commonJS2({ "../../node_modules/property-information/lib/xmlns.js"(exports, module2) {
      "use strict";
      var create = require_create(), caseInsensitiveTransform = require_case_insensitive_transform();
      module2.exports = create({ space: "xmlns", attributes: { xmlnsxlink: "xmlns:xlink" }, transform: caseInsensitiveTransform, properties: { xmlns: null, xmlnsXLink: null } });
    } });
    require_aria = __commonJS2({ "../../node_modules/property-information/lib/aria.js"(exports, module2) {
      "use strict";
      var types = require_types(), create = require_create(), booleanish = types.booleanish, number = types.number, spaceSeparated = types.spaceSeparated;
      module2.exports = create({ transform: ariaTransform, properties: { ariaActiveDescendant: null, ariaAtomic: booleanish, ariaAutoComplete: null, ariaBusy: booleanish, ariaChecked: booleanish, ariaColCount: number, ariaColIndex: number, ariaColSpan: number, ariaControls: spaceSeparated, ariaCurrent: null, ariaDescribedBy: spaceSeparated, ariaDetails: null, ariaDisabled: booleanish, ariaDropEffect: spaceSeparated, ariaErrorMessage: null, ariaExpanded: booleanish, ariaFlowTo: spaceSeparated, ariaGrabbed: booleanish, ariaHasPopup: null, ariaHidden: booleanish, ariaInvalid: null, ariaKeyShortcuts: null, ariaLabel: null, ariaLabelledBy: spaceSeparated, ariaLevel: number, ariaLive: null, ariaModal: booleanish, ariaMultiLine: booleanish, ariaMultiSelectable: booleanish, ariaOrientation: null, ariaOwns: spaceSeparated, ariaPlaceholder: null, ariaPosInSet: number, ariaPressed: booleanish, ariaReadOnly: booleanish, ariaRelevant: null, ariaRequired: booleanish, ariaRoleDescription: spaceSeparated, ariaRowCount: number, ariaRowIndex: number, ariaRowSpan: number, ariaSelected: booleanish, ariaSetSize: number, ariaSort: null, ariaValueMax: number, ariaValueMin: number, ariaValueNow: number, ariaValueText: null, role: null } });
      function ariaTransform(_, prop) {
        return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
      }
    } });
    require_html = __commonJS2({ "../../node_modules/property-information/lib/html.js"(exports, module2) {
      "use strict";
      var types = require_types(), create = require_create(), caseInsensitiveTransform = require_case_insensitive_transform(), boolean = types.boolean, overloadedBoolean = types.overloadedBoolean, booleanish = types.booleanish, number = types.number, spaceSeparated = types.spaceSeparated, commaSeparated = types.commaSeparated;
      module2.exports = create({ space: "html", attributes: { acceptcharset: "accept-charset", classname: "class", htmlfor: "for", httpequiv: "http-equiv" }, transform: caseInsensitiveTransform, mustUseProperty: ["checked", "multiple", "muted", "selected"], properties: { abbr: null, accept: commaSeparated, acceptCharset: spaceSeparated, accessKey: spaceSeparated, action: null, allow: null, allowFullScreen: boolean, allowPaymentRequest: boolean, allowUserMedia: boolean, alt: null, as: null, async: boolean, autoCapitalize: null, autoComplete: spaceSeparated, autoFocus: boolean, autoPlay: boolean, capture: boolean, charSet: null, checked: boolean, cite: null, className: spaceSeparated, cols: number, colSpan: null, content: null, contentEditable: booleanish, controls: boolean, controlsList: spaceSeparated, coords: number | commaSeparated, crossOrigin: null, data: null, dateTime: null, decoding: null, default: boolean, defer: boolean, dir: null, dirName: null, disabled: boolean, download: overloadedBoolean, draggable: booleanish, encType: null, enterKeyHint: null, form: null, formAction: null, formEncType: null, formMethod: null, formNoValidate: boolean, formTarget: null, headers: spaceSeparated, height: number, hidden: boolean, high: number, href: null, hrefLang: null, htmlFor: spaceSeparated, httpEquiv: spaceSeparated, id: null, imageSizes: null, imageSrcSet: commaSeparated, inputMode: null, integrity: null, is: null, isMap: boolean, itemId: null, itemProp: spaceSeparated, itemRef: spaceSeparated, itemScope: boolean, itemType: spaceSeparated, kind: null, label: null, lang: null, language: null, list: null, loading: null, loop: boolean, low: number, manifest: null, max: null, maxLength: number, media: null, method: null, min: null, minLength: number, multiple: boolean, muted: boolean, name: null, nonce: null, noModule: boolean, noValidate: boolean, onAbort: null, onAfterPrint: null, onAuxClick: null, onBeforePrint: null, onBeforeUnload: null, onBlur: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onContextMenu: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnded: null, onError: null, onFocus: null, onFormData: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLanguageChange: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadEnd: null, onLoadStart: null, onMessage: null, onMessageError: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRejectionHandled: null, onReset: null, onResize: null, onScroll: null, onSecurityPolicyViolation: null, onSeeked: null, onSeeking: null, onSelect: null, onSlotChange: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnhandledRejection: null, onUnload: null, onVolumeChange: null, onWaiting: null, onWheel: null, open: boolean, optimum: number, pattern: null, ping: spaceSeparated, placeholder: null, playsInline: boolean, poster: null, preload: null, readOnly: boolean, referrerPolicy: null, rel: spaceSeparated, required: boolean, reversed: boolean, rows: number, rowSpan: number, sandbox: spaceSeparated, scope: null, scoped: boolean, seamless: boolean, selected: boolean, shape: null, size: number, sizes: null, slot: null, span: number, spellCheck: booleanish, src: null, srcDoc: null, srcLang: null, srcSet: commaSeparated, start: number, step: null, style: null, tabIndex: number, target: null, title: null, translate: null, type: null, typeMustMatch: boolean, useMap: null, value: booleanish, width: number, wrap: null, align: null, aLink: null, archive: spaceSeparated, axis: null, background: null, bgColor: null, border: number, borderColor: null, bottomMargin: number, cellPadding: null, cellSpacing: null, char: null, charOff: null, classId: null, clear: null, code: null, codeBase: null, codeType: null, color: null, compact: boolean, declare: boolean, event: null, face: null, frame: null, frameBorder: null, hSpace: number, leftMargin: number, link: null, longDesc: null, lowSrc: null, marginHeight: number, marginWidth: number, noResize: boolean, noHref: boolean, noShade: boolean, noWrap: boolean, object: null, profile: null, prompt: null, rev: null, rightMargin: number, rules: null, scheme: null, scrolling: booleanish, standby: null, summary: null, text: null, topMargin: number, valueType: null, version: null, vAlign: null, vLink: null, vSpace: number, allowTransparency: null, autoCorrect: null, autoSave: null, disablePictureInPicture: boolean, disableRemotePlayback: boolean, prefix: null, property: null, results: number, security: null, unselectable: null } });
    } });
    require_html2 = __commonJS2({ "../../node_modules/property-information/html.js"(exports, module2) {
      "use strict";
      var merge = require_merge(), xlink = require_xlink(), xml = require_xml(), xmlns = require_xmlns(), aria = require_aria(), html = require_html();
      module2.exports = merge([xml, xlink, xmlns, aria, html]);
    } });
    require_find = __commonJS2({ "../../node_modules/property-information/find.js"(exports, module2) {
      "use strict";
      var normalize = require_normalize(), DefinedInfo = require_defined_info(), Info = require_info(), data = "data";
      module2.exports = find;
      var valid = /^data[-\w.:]+$/i, dash = /-[a-z]/g, cap = /[A-Z]/g;
      function find(schema, value) {
        var normal = normalize(value), prop = value, Type = Info;
        return normal in schema.normal ? schema.property[schema.normal[normal]] : (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value) && (value.charAt(4) === "-" ? prop = datasetToProperty(value) : value = datasetToAttribute(value), Type = DefinedInfo), new Type(prop, value));
      }
      function datasetToProperty(attribute) {
        var value = attribute.slice(5).replace(dash, camelcase);
        return data + value.charAt(0).toUpperCase() + value.slice(1);
      }
      function datasetToAttribute(property) {
        var value = property.slice(4);
        return dash.test(value) ? property : (value = value.replace(cap, kebab), value.charAt(0) !== "-" && (value = "-" + value), data + value);
      }
      function kebab($0) {
        return "-" + $0.toLowerCase();
      }
      function camelcase($0) {
        return $0.charAt(1).toUpperCase();
      }
    } });
    require_hast_util_parse_selector = __commonJS2({ "../../node_modules/hast-util-parse-selector/index.js"(exports, module2) {
      "use strict";
      module2.exports = parse;
      var search = /[#.]/g;
      function parse(selector, defaultTagName) {
        for (var value = selector || "", name = defaultTagName || "div", props = {}, start2 = 0, subvalue, previous, match2; start2 < value.length; )
          search.lastIndex = start2, match2 = search.exec(value), subvalue = value.slice(start2, match2 ? match2.index : value.length), subvalue && (previous ? previous === "#" ? props.id = subvalue : props.className ? props.className.push(subvalue) : props.className = [subvalue] : name = subvalue, start2 += subvalue.length), match2 && (previous = match2[0], start2++);
        return { type: "element", tagName: name, properties: props, children: [] };
      }
    } });
    require_space_separated_tokens = __commonJS2({ "../../node_modules/space-separated-tokens/index.js"(exports) {
      "use strict";
      exports.parse = parse;
      exports.stringify = stringify;
      var empty = "", space = " ", whiteSpace = /[ \t\n\r\f]+/g;
      function parse(value) {
        var input = String(value || empty).trim();
        return input === empty ? [] : input.split(whiteSpace);
      }
      function stringify(values) {
        return values.join(space).trim();
      }
    } });
    require_comma_separated_tokens = __commonJS2({ "../../node_modules/comma-separated-tokens/index.js"(exports) {
      "use strict";
      exports.parse = parse;
      exports.stringify = stringify;
      var comma = ",", space = " ", empty = "";
      function parse(value) {
        for (var values = [], input = String(value || empty), index3 = input.indexOf(comma), lastIndex = 0, end2 = false, val; !end2; )
          index3 === -1 && (index3 = input.length, end2 = true), val = input.slice(lastIndex, index3).trim(), (val || !end2) && values.push(val), lastIndex = index3 + 1, index3 = input.indexOf(comma, lastIndex);
        return values;
      }
      function stringify(values, options) {
        var settings = options || {}, left2 = settings.padLeft === false ? empty : space, right2 = settings.padRight ? space : empty;
        return values[values.length - 1] === empty && (values = values.concat(empty)), values.join(right2 + comma + left2).trim();
      }
    } });
    require_factory = __commonJS2({ "../../node_modules/hastscript/factory.js"(exports, module2) {
      "use strict";
      var find = require_find(), normalize = require_normalize(), parseSelector = require_hast_util_parse_selector(), spaces = require_space_separated_tokens().parse, commas = require_comma_separated_tokens().parse;
      module2.exports = factory;
      var own = {}.hasOwnProperty;
      function factory(schema, defaultTagName, caseSensitive) {
        var adjust = caseSensitive ? createAdjustMap(caseSensitive) : null;
        return h;
        function h(selector, properties) {
          var node = parseSelector(selector, defaultTagName), children = Array.prototype.slice.call(arguments, 2), name = node.tagName.toLowerCase(), property;
          if (node.tagName = adjust && own.call(adjust, name) ? adjust[name] : name, properties && isChildren(properties, node) && (children.unshift(properties), properties = null), properties)
            for (property in properties)
              addProperty(node.properties, property, properties[property]);
          return addChild(node.children, children), node.tagName === "template" && (node.content = { type: "root", children: node.children }, node.children = []), node;
        }
        function addProperty(properties, key, value) {
          var info, property, result;
          value == null || value !== value || (info = find(schema, key), property = info.property, result = value, typeof result == "string" && (info.spaceSeparated ? result = spaces(result) : info.commaSeparated ? result = commas(result) : info.commaOrSpaceSeparated && (result = spaces(commas(result).join(" ")))), property === "style" && typeof value != "string" && (result = style(result)), property === "className" && properties.className && (result = properties.className.concat(result)), properties[property] = parsePrimitives(info, property, result));
        }
      }
      function isChildren(value, node) {
        return typeof value == "string" || "length" in value || isNode(node.tagName, value);
      }
      function isNode(tagName, value) {
        var type = value.type;
        return tagName === "input" || !type || typeof type != "string" ? false : typeof value.children == "object" && "length" in value.children ? true : (type = type.toLowerCase(), tagName === "button" ? type !== "menu" && type !== "submit" && type !== "reset" && type !== "button" : "value" in value);
      }
      function addChild(nodes, value) {
        var index3, length2;
        if (typeof value == "string" || typeof value == "number") {
          nodes.push({ type: "text", value: String(value) });
          return;
        }
        if (typeof value == "object" && "length" in value) {
          for (index3 = -1, length2 = value.length; ++index3 < length2; )
            addChild(nodes, value[index3]);
          return;
        }
        if (typeof value != "object" || !("type" in value))
          throw new Error("Expected node, nodes, or string, got `" + value + "`");
        nodes.push(value);
      }
      function parsePrimitives(info, name, value) {
        var index3, length2, result;
        if (typeof value != "object" || !("length" in value))
          return parsePrimitive(info, name, value);
        for (length2 = value.length, index3 = -1, result = []; ++index3 < length2; )
          result[index3] = parsePrimitive(info, name, value[index3]);
        return result;
      }
      function parsePrimitive(info, name, value) {
        var result = value;
        return info.number || info.positiveNumber ? !isNaN(result) && result !== "" && (result = Number(result)) : (info.boolean || info.overloadedBoolean) && typeof result == "string" && (result === "" || normalize(value) === normalize(name)) && (result = true), result;
      }
      function style(value) {
        var result = [], key;
        for (key in value)
          result.push([key, value[key]].join(": "));
        return result.join("; ");
      }
      function createAdjustMap(values) {
        for (var length2 = values.length, index3 = -1, result = {}, value; ++index3 < length2; )
          value = values[index3], result[value.toLowerCase()] = value;
        return result;
      }
    } });
    require_html3 = __commonJS2({ "../../node_modules/hastscript/html.js"(exports, module2) {
      "use strict";
      var schema = require_html2(), factory = require_factory(), html = factory(schema, "div");
      html.displayName = "html";
      module2.exports = html;
    } });
    require_hastscript = __commonJS2({ "../../node_modules/hastscript/index.js"(exports, module2) {
      "use strict";
      module2.exports = require_html3();
    } });
    require_character_entities_legacy = __commonJS2({ "../../node_modules/character-entities-legacy/index.json"(exports, module2) {
      module2.exports = { AElig: "\xC6", AMP: "&", Aacute: "\xC1", Acirc: "\xC2", Agrave: "\xC0", Aring: "\xC5", Atilde: "\xC3", Auml: "\xC4", COPY: "\xA9", Ccedil: "\xC7", ETH: "\xD0", Eacute: "\xC9", Ecirc: "\xCA", Egrave: "\xC8", Euml: "\xCB", GT: ">", Iacute: "\xCD", Icirc: "\xCE", Igrave: "\xCC", Iuml: "\xCF", LT: "<", Ntilde: "\xD1", Oacute: "\xD3", Ocirc: "\xD4", Ograve: "\xD2", Oslash: "\xD8", Otilde: "\xD5", Ouml: "\xD6", QUOT: '"', REG: "\xAE", THORN: "\xDE", Uacute: "\xDA", Ucirc: "\xDB", Ugrave: "\xD9", Uuml: "\xDC", Yacute: "\xDD", aacute: "\xE1", acirc: "\xE2", acute: "\xB4", aelig: "\xE6", agrave: "\xE0", amp: "&", aring: "\xE5", atilde: "\xE3", auml: "\xE4", brvbar: "\xA6", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", eacute: "\xE9", ecirc: "\xEA", egrave: "\xE8", eth: "\xF0", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", iacute: "\xED", icirc: "\xEE", iexcl: "\xA1", igrave: "\xEC", iquest: "\xBF", iuml: "\xEF", laquo: "\xAB", lt: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", ntilde: "\xF1", oacute: "\xF3", ocirc: "\xF4", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", oslash: "\xF8", otilde: "\xF5", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', raquo: "\xBB", reg: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", thorn: "\xFE", times: "\xD7", uacute: "\xFA", ucirc: "\xFB", ugrave: "\xF9", uml: "\xA8", uuml: "\xFC", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
    } });
    require_character_reference_invalid = __commonJS2({ "../../node_modules/character-reference-invalid/index.json"(exports, module2) {
      module2.exports = { "0": "\uFFFD", "128": "\u20AC", "130": "\u201A", "131": "\u0192", "132": "\u201E", "133": "\u2026", "134": "\u2020", "135": "\u2021", "136": "\u02C6", "137": "\u2030", "138": "\u0160", "139": "\u2039", "140": "\u0152", "142": "\u017D", "145": "\u2018", "146": "\u2019", "147": "\u201C", "148": "\u201D", "149": "\u2022", "150": "\u2013", "151": "\u2014", "152": "\u02DC", "153": "\u2122", "154": "\u0161", "155": "\u203A", "156": "\u0153", "158": "\u017E", "159": "\u0178" };
    } });
    require_is_decimal = __commonJS2({ "../../node_modules/is-decimal/index.js"(exports, module2) {
      "use strict";
      module2.exports = decimal;
      function decimal(character) {
        var code = typeof character == "string" ? character.charCodeAt(0) : character;
        return code >= 48 && code <= 57;
      }
    } });
    require_is_hexadecimal = __commonJS2({ "../../node_modules/is-hexadecimal/index.js"(exports, module2) {
      "use strict";
      module2.exports = hexadecimal;
      function hexadecimal(character) {
        var code = typeof character == "string" ? character.charCodeAt(0) : character;
        return code >= 97 && code <= 102 || code >= 65 && code <= 70 || code >= 48 && code <= 57;
      }
    } });
    require_is_alphabetical = __commonJS2({ "../../node_modules/is-alphabetical/index.js"(exports, module2) {
      "use strict";
      module2.exports = alphabetical;
      function alphabetical(character) {
        var code = typeof character == "string" ? character.charCodeAt(0) : character;
        return code >= 97 && code <= 122 || code >= 65 && code <= 90;
      }
    } });
    require_is_alphanumerical = __commonJS2({ "../../node_modules/is-alphanumerical/index.js"(exports, module2) {
      "use strict";
      var alphabetical = require_is_alphabetical(), decimal = require_is_decimal();
      module2.exports = alphanumerical;
      function alphanumerical(character) {
        return alphabetical(character) || decimal(character);
      }
    } });
    require_character_entities = __commonJS2({ "../../node_modules/character-entities/index.json"(exports, module2) {
      module2.exports = { AEli: "\xC6", AElig: "\xC6", AM: "&", AMP: "&", Aacut: "\xC1", Aacute: "\xC1", Abreve: "\u0102", Acir: "\xC2", Acirc: "\xC2", Acy: "\u0410", Afr: "\u{1D504}", Agrav: "\xC0", Agrave: "\xC0", Alpha: "\u0391", Amacr: "\u0100", And: "\u2A53", Aogon: "\u0104", Aopf: "\u{1D538}", ApplyFunction: "\u2061", Arin: "\xC5", Aring: "\xC5", Ascr: "\u{1D49C}", Assign: "\u2254", Atild: "\xC3", Atilde: "\xC3", Aum: "\xC4", Auml: "\xC4", Backslash: "\u2216", Barv: "\u2AE7", Barwed: "\u2306", Bcy: "\u0411", Because: "\u2235", Bernoullis: "\u212C", Beta: "\u0392", Bfr: "\u{1D505}", Bopf: "\u{1D539}", Breve: "\u02D8", Bscr: "\u212C", Bumpeq: "\u224E", CHcy: "\u0427", COP: "\xA9", COPY: "\xA9", Cacute: "\u0106", Cap: "\u22D2", CapitalDifferentialD: "\u2145", Cayleys: "\u212D", Ccaron: "\u010C", Ccedi: "\xC7", Ccedil: "\xC7", Ccirc: "\u0108", Cconint: "\u2230", Cdot: "\u010A", Cedilla: "\xB8", CenterDot: "\xB7", Cfr: "\u212D", Chi: "\u03A7", CircleDot: "\u2299", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", Colon: "\u2237", Colone: "\u2A74", Congruent: "\u2261", Conint: "\u222F", ContourIntegral: "\u222E", Copf: "\u2102", Coproduct: "\u2210", CounterClockwiseContourIntegral: "\u2233", Cross: "\u2A2F", Cscr: "\u{1D49E}", Cup: "\u22D3", CupCap: "\u224D", DD: "\u2145", DDotrahd: "\u2911", DJcy: "\u0402", DScy: "\u0405", DZcy: "\u040F", Dagger: "\u2021", Darr: "\u21A1", Dashv: "\u2AE4", Dcaron: "\u010E", Dcy: "\u0414", Del: "\u2207", Delta: "\u0394", Dfr: "\u{1D507}", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", Diamond: "\u22C4", DifferentialD: "\u2146", Dopf: "\u{1D53B}", Dot: "\xA8", DotDot: "\u20DC", DotEqual: "\u2250", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", Downarrow: "\u21D3", Dscr: "\u{1D49F}", Dstrok: "\u0110", ENG: "\u014A", ET: "\xD0", ETH: "\xD0", Eacut: "\xC9", Eacute: "\xC9", Ecaron: "\u011A", Ecir: "\xCA", Ecirc: "\xCA", Ecy: "\u042D", Edot: "\u0116", Efr: "\u{1D508}", Egrav: "\xC8", Egrave: "\xC8", Element: "\u2208", Emacr: "\u0112", EmptySmallSquare: "\u25FB", EmptyVerySmallSquare: "\u25AB", Eogon: "\u0118", Eopf: "\u{1D53C}", Epsilon: "\u0395", Equal: "\u2A75", EqualTilde: "\u2242", Equilibrium: "\u21CC", Escr: "\u2130", Esim: "\u2A73", Eta: "\u0397", Eum: "\xCB", Euml: "\xCB", Exists: "\u2203", ExponentialE: "\u2147", Fcy: "\u0424", Ffr: "\u{1D509}", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", Fopf: "\u{1D53D}", ForAll: "\u2200", Fouriertrf: "\u2131", Fscr: "\u2131", GJcy: "\u0403", G: ">", GT: ">", Gamma: "\u0393", Gammad: "\u03DC", Gbreve: "\u011E", Gcedil: "\u0122", Gcirc: "\u011C", Gcy: "\u0413", Gdot: "\u0120", Gfr: "\u{1D50A}", Gg: "\u22D9", Gopf: "\u{1D53E}", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", Gt: "\u226B", HARDcy: "\u042A", Hacek: "\u02C7", Hat: "^", Hcirc: "\u0124", Hfr: "\u210C", HilbertSpace: "\u210B", Hopf: "\u210D", HorizontalLine: "\u2500", Hscr: "\u210B", Hstrok: "\u0126", HumpDownHump: "\u224E", HumpEqual: "\u224F", IEcy: "\u0415", IJlig: "\u0132", IOcy: "\u0401", Iacut: "\xCD", Iacute: "\xCD", Icir: "\xCE", Icirc: "\xCE", Icy: "\u0418", Idot: "\u0130", Ifr: "\u2111", Igrav: "\xCC", Igrave: "\xCC", Im: "\u2111", Imacr: "\u012A", ImaginaryI: "\u2148", Implies: "\u21D2", Int: "\u222C", Integral: "\u222B", Intersection: "\u22C2", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", Iogon: "\u012E", Iopf: "\u{1D540}", Iota: "\u0399", Iscr: "\u2110", Itilde: "\u0128", Iukcy: "\u0406", Ium: "\xCF", Iuml: "\xCF", Jcirc: "\u0134", Jcy: "\u0419", Jfr: "\u{1D50D}", Jopf: "\u{1D541}", Jscr: "\u{1D4A5}", Jsercy: "\u0408", Jukcy: "\u0404", KHcy: "\u0425", KJcy: "\u040C", Kappa: "\u039A", Kcedil: "\u0136", Kcy: "\u041A", Kfr: "\u{1D50E}", Kopf: "\u{1D542}", Kscr: "\u{1D4A6}", LJcy: "\u0409", L: "<", LT: "<", Lacute: "\u0139", Lambda: "\u039B", Lang: "\u27EA", Laplacetrf: "\u2112", Larr: "\u219E", Lcaron: "\u013D", Lcedil: "\u013B", Lcy: "\u041B", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", LeftRightArrow: "\u2194", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", Leftarrow: "\u21D0", Leftrightarrow: "\u21D4", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", LessLess: "\u2AA1", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", Lfr: "\u{1D50F}", Ll: "\u22D8", Lleftarrow: "\u21DA", Lmidot: "\u013F", LongLeftArrow: "\u27F5", LongLeftRightArrow: "\u27F7", LongRightArrow: "\u27F6", Longleftarrow: "\u27F8", Longleftrightarrow: "\u27FA", Longrightarrow: "\u27F9", Lopf: "\u{1D543}", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", Lscr: "\u2112", Lsh: "\u21B0", Lstrok: "\u0141", Lt: "\u226A", Map: "\u2905", Mcy: "\u041C", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", MinusPlus: "\u2213", Mopf: "\u{1D544}", Mscr: "\u2133", Mu: "\u039C", NJcy: "\u040A", Nacute: "\u0143", Ncaron: "\u0147", Ncedil: "\u0145", Ncy: "\u041D", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: `
`, Nfr: "\u{1D511}", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", Not: "\u2AEC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", Nscr: "\u{1D4A9}", Ntild: "\xD1", Ntilde: "\xD1", Nu: "\u039D", OElig: "\u0152", Oacut: "\xD3", Oacute: "\xD3", Ocir: "\xD4", Ocirc: "\xD4", Ocy: "\u041E", Odblac: "\u0150", Ofr: "\u{1D512}", Ograv: "\xD2", Ograve: "\xD2", Omacr: "\u014C", Omega: "\u03A9", Omicron: "\u039F", Oopf: "\u{1D546}", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", Or: "\u2A54", Oscr: "\u{1D4AA}", Oslas: "\xD8", Oslash: "\xD8", Otild: "\xD5", Otilde: "\xD5", Otimes: "\u2A37", Oum: "\xD6", Ouml: "\xD6", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", PartialD: "\u2202", Pcy: "\u041F", Pfr: "\u{1D513}", Phi: "\u03A6", Pi: "\u03A0", PlusMinus: "\xB1", Poincareplane: "\u210C", Popf: "\u2119", Pr: "\u2ABB", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", Prime: "\u2033", Product: "\u220F", Proportion: "\u2237", Proportional: "\u221D", Pscr: "\u{1D4AB}", Psi: "\u03A8", QUO: '"', QUOT: '"', Qfr: "\u{1D514}", Qopf: "\u211A", Qscr: "\u{1D4AC}", RBarr: "\u2910", RE: "\xAE", REG: "\xAE", Racute: "\u0154", Rang: "\u27EB", Rarr: "\u21A0", Rarrtl: "\u2916", Rcaron: "\u0158", Rcedil: "\u0156", Rcy: "\u0420", Re: "\u211C", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", Rfr: "\u211C", Rho: "\u03A1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", Rightarrow: "\u21D2", Ropf: "\u211D", RoundImplies: "\u2970", Rrightarrow: "\u21DB", Rscr: "\u211B", Rsh: "\u21B1", RuleDelayed: "\u29F4", SHCHcy: "\u0429", SHcy: "\u0428", SOFTcy: "\u042C", Sacute: "\u015A", Sc: "\u2ABC", Scaron: "\u0160", Scedil: "\u015E", Scirc: "\u015C", Scy: "\u0421", Sfr: "\u{1D516}", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", Sigma: "\u03A3", SmallCircle: "\u2218", Sopf: "\u{1D54A}", Sqrt: "\u221A", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", Sscr: "\u{1D4AE}", Star: "\u22C6", Sub: "\u22D0", Subset: "\u22D0", SubsetEqual: "\u2286", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", SuchThat: "\u220B", Sum: "\u2211", Sup: "\u22D1", Superset: "\u2283", SupersetEqual: "\u2287", Supset: "\u22D1", THOR: "\xDE", THORN: "\xDE", TRADE: "\u2122", TSHcy: "\u040B", TScy: "\u0426", Tab: "	", Tau: "\u03A4", Tcaron: "\u0164", Tcedil: "\u0162", Tcy: "\u0422", Tfr: "\u{1D517}", Therefore: "\u2234", Theta: "\u0398", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", Topf: "\u{1D54B}", TripleDot: "\u20DB", Tscr: "\u{1D4AF}", Tstrok: "\u0166", Uacut: "\xDA", Uacute: "\xDA", Uarr: "\u219F", Uarrocir: "\u2949", Ubrcy: "\u040E", Ubreve: "\u016C", Ucir: "\xDB", Ucirc: "\xDB", Ucy: "\u0423", Udblac: "\u0170", Ufr: "\u{1D518}", Ugrav: "\xD9", Ugrave: "\xD9", Umacr: "\u016A", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", Uopf: "\u{1D54C}", UpArrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", UpEquilibrium: "\u296E", UpTee: "\u22A5", UpTeeArrow: "\u21A5", Uparrow: "\u21D1", Updownarrow: "\u21D5", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", Upsilon: "\u03A5", Uring: "\u016E", Uscr: "\u{1D4B0}", Utilde: "\u0168", Uum: "\xDC", Uuml: "\xDC", VDash: "\u22AB", Vbar: "\u2AEB", Vcy: "\u0412", Vdash: "\u22A9", Vdashl: "\u2AE6", Vee: "\u22C1", Verbar: "\u2016", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", Vopf: "\u{1D54D}", Vscr: "\u{1D4B1}", Vvdash: "\u22AA", Wcirc: "\u0174", Wedge: "\u22C0", Wfr: "\u{1D51A}", Wopf: "\u{1D54E}", Wscr: "\u{1D4B2}", Xfr: "\u{1D51B}", Xi: "\u039E", Xopf: "\u{1D54F}", Xscr: "\u{1D4B3}", YAcy: "\u042F", YIcy: "\u0407", YUcy: "\u042E", Yacut: "\xDD", Yacute: "\xDD", Ycirc: "\u0176", Ycy: "\u042B", Yfr: "\u{1D51C}", Yopf: "\u{1D550}", Yscr: "\u{1D4B4}", Yuml: "\u0178", ZHcy: "\u0416", Zacute: "\u0179", Zcaron: "\u017D", Zcy: "\u0417", Zdot: "\u017B", ZeroWidthSpace: "\u200B", Zeta: "\u0396", Zfr: "\u2128", Zopf: "\u2124", Zscr: "\u{1D4B5}", aacut: "\xE1", aacute: "\xE1", abreve: "\u0103", ac: "\u223E", acE: "\u223E\u0333", acd: "\u223F", acir: "\xE2", acirc: "\xE2", acut: "\xB4", acute: "\xB4", acy: "\u0430", aeli: "\xE6", aelig: "\xE6", af: "\u2061", afr: "\u{1D51E}", agrav: "\xE0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", amacr: "\u0101", amalg: "\u2A3F", am: "&", amp: "&", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", aogon: "\u0105", aopf: "\u{1D552}", ap: "\u2248", apE: "\u2A70", apacir: "\u2A6F", ape: "\u224A", apid: "\u224B", apos: "'", approx: "\u2248", approxeq: "\u224A", arin: "\xE5", aring: "\xE5", ascr: "\u{1D4B6}", ast: "*", asymp: "\u2248", asympeq: "\u224D", atild: "\xE3", atilde: "\xE3", aum: "\xE4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", bNot: "\u2AED", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", barvee: "\u22BD", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", beta: "\u03B2", beth: "\u2136", between: "\u226C", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxDL: "\u2557", boxDR: "\u2554", boxDl: "\u2556", boxDr: "\u2553", boxH: "\u2550", boxHD: "\u2566", boxHU: "\u2569", boxHd: "\u2564", boxHu: "\u2567", boxUL: "\u255D", boxUR: "\u255A", boxUl: "\u255C", boxUr: "\u2559", boxV: "\u2551", boxVH: "\u256C", boxVL: "\u2563", boxVR: "\u2560", boxVh: "\u256B", boxVl: "\u2562", boxVr: "\u255F", boxbox: "\u29C9", boxdL: "\u2555", boxdR: "\u2552", boxdl: "\u2510", boxdr: "\u250C", boxh: "\u2500", boxhD: "\u2565", boxhU: "\u2568", boxhd: "\u252C", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxuL: "\u255B", boxuR: "\u2558", boxul: "\u2518", boxur: "\u2514", boxv: "\u2502", boxvH: "\u256A", boxvL: "\u2561", boxvR: "\u255E", boxvh: "\u253C", boxvl: "\u2524", boxvr: "\u251C", bprime: "\u2035", breve: "\u02D8", brvba: "\xA6", brvbar: "\xA6", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", bumpeq: "\u224F", cacute: "\u0107", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", ccaps: "\u2A4D", ccaron: "\u010D", ccedi: "\xE7", ccedil: "\xE7", ccirc: "\u0109", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", cedi: "\xB8", cedil: "\xB8", cemptyv: "\u29B2", cen: "\xA2", cent: "\xA2", centerdot: "\xB7", cfr: "\u{1D520}", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", cir: "\u25CB", cirE: "\u29C3", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledR: "\xAE", circledS: "\u24C8", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", clubs: "\u2663", clubsuit: "\u2663", colon: ":", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", conint: "\u222E", copf: "\u{1D554}", coprod: "\u2210", cop: "\xA9", copy: "\xA9", copysr: "\u2117", crarr: "\u21B5", cross: "\u2717", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cup: "\u222A", cupbrcap: "\u2A48", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curre: "\xA4", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dArr: "\u21D3", dHar: "\u2965", dagger: "\u2020", daleth: "\u2138", darr: "\u2193", dash: "\u2010", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", dcaron: "\u010F", dcy: "\u0434", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", ddotseq: "\u2A77", de: "\xB0", deg: "\xB0", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\u{1D521}", dharl: "\u21C3", dharr: "\u21C2", diam: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divid: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\u{1D555}", dot: "\u02D9", doteq: "\u2250", doteqdot: "\u2251", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", downarrow: "\u2193", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", dscr: "\u{1D4B9}", dscy: "\u0455", dsol: "\u29F6", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", dzcy: "\u045F", dzigrarr: "\u27FF", eDDot: "\u2A77", eDot: "\u2251", eacut: "\xE9", eacute: "\xE9", easter: "\u2A6E", ecaron: "\u011B", ecir: "\xEA", ecirc: "\xEA", ecolon: "\u2255", ecy: "\u044D", edot: "\u0117", ee: "\u2147", efDot: "\u2252", efr: "\u{1D522}", eg: "\u2A9A", egrav: "\xE8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", emptyv: "\u2205", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", eng: "\u014B", ensp: "\u2002", eogon: "\u0119", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", equals: "=", equest: "\u225F", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erDot: "\u2253", erarr: "\u2971", escr: "\u212F", esdot: "\u2250", esim: "\u2242", eta: "\u03B7", et: "\xF0", eth: "\xF0", eum: "\xEB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", expectation: "\u2130", exponentiale: "\u2147", fallingdotseq: "\u2252", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\u{1D523}", filig: "\uFB01", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\u{1D557}", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", fpartint: "\u2A0D", frac1: "\xBC", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac3: "\xBE", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", gE: "\u2267", gEl: "\u2A8C", gacute: "\u01F5", gamma: "\u03B3", gammad: "\u03DD", gap: "\u2A86", gbreve: "\u011F", gcirc: "\u011D", gcy: "\u0433", gdot: "\u0121", ge: "\u2265", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\u{1D524}", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", gjcy: "\u0453", gl: "\u2277", glE: "\u2A92", gla: "\u2AA5", glj: "\u2AA4", gnE: "\u2269", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", gopf: "\u{1D558}", grave: "`", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", g: ">", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", hArr: "\u21D4", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", hardcy: "\u044A", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", hbar: "\u210F", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", horbar: "\u2015", hscr: "\u{1D4BD}", hslash: "\u210F", hstrok: "\u0127", hybull: "\u2043", hyphen: "\u2010", iacut: "\xED", iacute: "\xED", ic: "\u2063", icir: "\xEE", icirc: "\xEE", icy: "\u0438", iecy: "\u0435", iexc: "\xA1", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", igrav: "\xEC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", imacr: "\u012B", image: "\u2111", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", int: "\u222B", intcal: "\u22BA", integers: "\u2124", intercal: "\u22BA", intlarhk: "\u2A17", intprod: "\u2A3C", iocy: "\u0451", iogon: "\u012F", iopf: "\u{1D55A}", iota: "\u03B9", iprod: "\u2A3C", iques: "\xBF", iquest: "\xBF", iscr: "\u{1D4BE}", isin: "\u2208", isinE: "\u22F9", isindot: "\u22F5", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", itilde: "\u0129", iukcy: "\u0456", ium: "\xEF", iuml: "\xEF", jcirc: "\u0135", jcy: "\u0439", jfr: "\u{1D527}", jmath: "\u0237", jopf: "\u{1D55B}", jscr: "\u{1D4BF}", jsercy: "\u0458", jukcy: "\u0454", kappa: "\u03BA", kappav: "\u03F0", kcedil: "\u0137", kcy: "\u043A", kfr: "\u{1D528}", kgreen: "\u0138", khcy: "\u0445", kjcy: "\u045C", kopf: "\u{1D55C}", kscr: "\u{1D4C0}", lAarr: "\u21DA", lArr: "\u21D0", lAtail: "\u291B", lBarr: "\u290E", lE: "\u2266", lEg: "\u2A8B", lHar: "\u2962", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", lambda: "\u03BB", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", laqu: "\xAB", laquo: "\xAB", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", lcedil: "\u013C", lceil: "\u2308", lcub: "{", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", leftarrow: "\u2190", leftarrowtail: "\u21A2", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", leftthreetimes: "\u22CB", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", lessgtr: "\u2276", lesssim: "\u2272", lfisht: "\u297C", lfloor: "\u230A", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnE: "\u2268", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", lstrok: "\u0142", l: "<", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltrPar: "\u2996", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", mDDot: "\u223A", mac: "\xAF", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", mdash: "\u2014", measuredangle: "\u2221", mfr: "\u{1D52A}", mho: "\u2127", micr: "\xB5", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middo: "\xB7", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", mstpos: "\u223E", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nGg: "\u22D9\u0338", nGt: "\u226B\u20D2", nGtv: "\u226B\u0338", nLeftarrow: "\u21CD", nLeftrightarrow: "\u21CE", nLl: "\u22D8\u0338", nLt: "\u226A\u20D2", nLtv: "\u226A\u0338", nRightarrow: "\u21CF", nVDash: "\u22AF", nVdash: "\u22AE", nabla: "\u2207", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbs: "\xA0", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", ncaron: "\u0148", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", neArr: "\u21D7", nearhk: "\u2924", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", nexist: "\u2204", nexists: "\u2204", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", ngsim: "\u2275", ngt: "\u226F", ngtr: "\u226F", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", njcy: "\u045A", nlArr: "\u21CD", nlE: "\u2266\u0338", nlarr: "\u219A", nldr: "\u2025", nle: "\u2270", nleftarrow: "\u219A", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nlsim: "\u2274", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nmid: "\u2224", nopf: "\u{1D55F}", no: "\xAC", not: "\xAC", notin: "\u2209", notinE: "\u22F9\u0338", notindot: "\u22F5\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", ntild: "\xF1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvDash: "\u22AD", nvHarr: "\u2904", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwArr: "\u21D6", nwarhk: "\u2923", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", oS: "\u24C8", oacut: "\xF3", oacute: "\xF3", oast: "\u229B", ocir: "\xF4", ocirc: "\xF4", ocy: "\u043E", odash: "\u229D", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", oelig: "\u0153", ofcir: "\u29BF", ofr: "\u{1D52C}", ogon: "\u02DB", ograv: "\xF2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", omacr: "\u014D", omega: "\u03C9", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", oopf: "\u{1D560}", opar: "\u29B7", operp: "\u29B9", oplus: "\u2295", or: "\u2228", orarr: "\u21BB", ord: "\xBA", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oscr: "\u2134", oslas: "\xF8", oslash: "\xF8", osol: "\u2298", otild: "\xF5", otilde: "\xF5", otimes: "\u2297", otimesas: "\u2A36", oum: "\xF6", ouml: "\xF6", ovbar: "\u233D", par: "\xB6", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", pfr: "\u{1D52D}", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", plusm: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", pointint: "\u2A15", popf: "\u{1D561}", poun: "\xA3", pound: "\xA3", pr: "\u227A", prE: "\u2AB3", prap: "\u2AB7", prcue: "\u227C", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", prime: "\u2032", primes: "\u2119", prnE: "\u2AB5", prnap: "\u2AB9", prnsim: "\u22E8", prod: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", pscr: "\u{1D4C5}", psi: "\u03C8", puncsp: "\u2008", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", qprime: "\u2057", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quo: '"', quot: '"', rAarr: "\u21DB", rArr: "\u21D2", rAtail: "\u291C", rBarr: "\u290F", rHar: "\u2964", race: "\u223D\u0331", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raqu: "\xBB", raquo: "\xBB", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", rcedil: "\u0157", rceil: "\u2309", rcub: "}", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", re: "\xAE", reg: "\xAE", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", rho: "\u03C1", rhov: "\u03F1", rightarrow: "\u2192", rightarrowtail: "\u21A3", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", rightthreetimes: "\u22CC", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", rsaquo: "\u203A", rscr: "\u{1D4C7}", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", sbquo: "\u201A", sc: "\u227B", scE: "\u2AB4", scap: "\u2AB8", scaron: "\u0161", sccue: "\u227D", sce: "\u2AB0", scedil: "\u015F", scirc: "\u015D", scnE: "\u2AB6", scnap: "\u2ABA", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", seArr: "\u21D8", searhk: "\u2925", searr: "\u2198", searrow: "\u2198", sec: "\xA7", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", shchcy: "\u0449", shcy: "\u0448", shortmid: "\u2223", shortparallel: "\u2225", sh: "\xAD", shy: "\xAD", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", square: "\u25A1", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", subE: "\u2AC5", subdot: "\u2ABD", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", sum: "\u2211", sung: "\u266A", sup: "\u2283", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supE: "\u2AC6", supdot: "\u2ABE", supdsub: "\u2AD8", supe: "\u2287", supedot: "\u2AC4", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swArr: "\u21D9", swarhk: "\u2926", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szli: "\xDF", szlig: "\xDF", target: "\u2316", tau: "\u03C4", tbrk: "\u23B4", tcaron: "\u0165", tcedil: "\u0163", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", thor: "\xFE", thorn: "\xFE", tilde: "\u02DC", time: "\xD7", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\u{1D4C9}", tscy: "\u0446", tshcy: "\u045B", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", uArr: "\u21D1", uHar: "\u2963", uacut: "\xFA", uacute: "\xFA", uarr: "\u2191", ubrcy: "\u045E", ubreve: "\u016D", ucir: "\xFB", ucirc: "\xFB", ucy: "\u0443", udarr: "\u21C5", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", ufr: "\u{1D532}", ugrav: "\xF9", ugrave: "\xF9", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", um: "\xA8", uml: "\xA8", uogon: "\u0173", uopf: "\u{1D566}", uparrow: "\u2191", updownarrow: "\u2195", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", upsi: "\u03C5", upsih: "\u03D2", upsilon: "\u03C5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", urtri: "\u25F9", uscr: "\u{1D4CA}", utdot: "\u22F0", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", uum: "\xFC", uuml: "\xFC", uwangle: "\u29A7", vArr: "\u21D5", vBar: "\u2AE8", vBarv: "\u2AE9", vDash: "\u22A8", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vcy: "\u0432", vdash: "\u22A2", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", vert: "|", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", vzigzag: "\u299A", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", wfr: "\u{1D534}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", yacut: "\xFD", yacute: "\xFD", yacy: "\u044F", ycirc: "\u0177", ycy: "\u044B", ye: "\xA5", yen: "\xA5", yfr: "\u{1D536}", yicy: "\u0457", yopf: "\u{1D56A}", yscr: "\u{1D4CE}", yucy: "\u044E", yum: "\xFF", yuml: "\xFF", zacute: "\u017A", zcaron: "\u017E", zcy: "\u0437", zdot: "\u017C", zeetrf: "\u2128", zeta: "\u03B6", zfr: "\u{1D537}", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
    } });
    require_decode_entity = __commonJS2({ "../../node_modules/parse-entities/decode-entity.js"(exports, module2) {
      "use strict";
      var characterEntities = require_character_entities();
      module2.exports = decodeEntity;
      var own = {}.hasOwnProperty;
      function decodeEntity(characters) {
        return own.call(characterEntities, characters) ? characterEntities[characters] : false;
      }
    } });
    require_parse_entities = __commonJS2({ "../../node_modules/parse-entities/index.js"(exports, module2) {
      "use strict";
      var legacy = require_character_entities_legacy(), invalid = require_character_reference_invalid(), decimal = require_is_decimal(), hexadecimal = require_is_hexadecimal(), alphanumerical = require_is_alphanumerical(), decodeEntity = require_decode_entity();
      module2.exports = parseEntities;
      var own = {}.hasOwnProperty, fromCharCode = String.fromCharCode, noop3 = Function.prototype, defaults = { warning: null, reference: null, text: null, warningContext: null, referenceContext: null, textContext: null, position: {}, additional: null, attribute: false, nonTerminated: true }, tab = 9, lineFeed = 10, formFeed = 12, space = 32, ampersand = 38, semicolon = 59, lessThan = 60, equalsTo = 61, numberSign = 35, uppercaseX = 88, lowercaseX = 120, replacementCharacter = 65533, name = "named", hexa = "hexadecimal", deci = "decimal", bases = {};
      bases[hexa] = 16;
      bases[deci] = 10;
      var tests = {};
      tests[name] = alphanumerical;
      tests[deci] = decimal;
      tests[hexa] = hexadecimal;
      var namedNotTerminated = 1, numericNotTerminated = 2, namedEmpty = 3, numericEmpty = 4, namedUnknown = 5, numericDisallowed = 6, numericProhibited = 7, messages = {};
      messages[namedNotTerminated] = "Named character references must be terminated by a semicolon";
      messages[numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
      messages[namedEmpty] = "Named character references cannot be empty";
      messages[numericEmpty] = "Numeric character references cannot be empty";
      messages[namedUnknown] = "Named character references must be known";
      messages[numericDisallowed] = "Numeric character references cannot be disallowed";
      messages[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
      function parseEntities(value, options) {
        var settings = {}, option, key;
        options || (options = {});
        for (key in defaults)
          option = options[key], settings[key] = option != null ? option : defaults[key];
        return (settings.position.indent || settings.position.start) && (settings.indent = settings.position.indent || [], settings.position = settings.position.start), parse(value, settings);
      }
      function parse(value, settings) {
        var additional = settings.additional, nonTerminated = settings.nonTerminated, handleText = settings.text, handleReference = settings.reference, handleWarning = settings.warning, textContext = settings.textContext, referenceContext = settings.referenceContext, warningContext = settings.warningContext, pos = settings.position, indent = settings.indent || [], length2 = value.length, index3 = 0, lines = -1, column = pos.column || 1, line = pos.line || 1, queue = "", result = [], entityCharacters, namedEntity, terminated, characters, character, reference2, following, warning, reason, output, entity, begin, start2, type, test, prev, next, diff, end2;
        for (typeof additional == "string" && (additional = additional.charCodeAt(0)), prev = now(), warning = handleWarning ? parseError : noop3, index3--, length2++; ++index3 < length2; )
          if (character === lineFeed && (column = indent[lines] || 1), character = value.charCodeAt(index3), character === ampersand) {
            if (following = value.charCodeAt(index3 + 1), following === tab || following === lineFeed || following === formFeed || following === space || following === ampersand || following === lessThan || following !== following || additional && following === additional) {
              queue += fromCharCode(character), column++;
              continue;
            }
            for (start2 = index3 + 1, begin = start2, end2 = start2, following === numberSign ? (end2 = ++begin, following = value.charCodeAt(end2), following === uppercaseX || following === lowercaseX ? (type = hexa, end2 = ++begin) : type = deci) : type = name, entityCharacters = "", entity = "", characters = "", test = tests[type], end2--; ++end2 < length2 && (following = value.charCodeAt(end2), !!test(following)); )
              characters += fromCharCode(following), type === name && own.call(legacy, characters) && (entityCharacters = characters, entity = legacy[characters]);
            terminated = value.charCodeAt(end2) === semicolon, terminated && (end2++, namedEntity = type === name ? decodeEntity(characters) : false, namedEntity && (entityCharacters = characters, entity = namedEntity)), diff = 1 + end2 - start2, !terminated && !nonTerminated || (characters ? type === name ? (terminated && !entity ? warning(namedUnknown, 1) : (entityCharacters !== characters && (end2 = begin + entityCharacters.length, diff = 1 + end2 - begin, terminated = false), terminated || (reason = entityCharacters ? namedNotTerminated : namedEmpty, settings.attribute ? (following = value.charCodeAt(end2), following === equalsTo ? (warning(reason, diff), entity = null) : alphanumerical(following) ? entity = null : warning(reason, diff)) : warning(reason, diff))), reference2 = entity) : (terminated || warning(numericNotTerminated, diff), reference2 = parseInt(characters, bases[type]), prohibited(reference2) ? (warning(numericProhibited, diff), reference2 = fromCharCode(replacementCharacter)) : reference2 in invalid ? (warning(numericDisallowed, diff), reference2 = invalid[reference2]) : (output = "", disallowed(reference2) && warning(numericDisallowed, diff), reference2 > 65535 && (reference2 -= 65536, output += fromCharCode(reference2 >>> 10 | 55296), reference2 = 56320 | reference2 & 1023), reference2 = output + fromCharCode(reference2))) : type !== name && warning(numericEmpty, diff)), reference2 ? (flush(), prev = now(), index3 = end2 - 1, column += end2 - start2 + 1, result.push(reference2), next = now(), next.offset++, handleReference && handleReference.call(referenceContext, reference2, { start: prev, end: next }, value.slice(start2 - 1, end2)), prev = next) : (characters = value.slice(start2 - 1, end2), queue += characters, column += characters.length, index3 = end2 - 1);
          } else
            character === 10 && (line++, lines++, column = 0), character === character ? (queue += fromCharCode(character), column++) : flush();
        return result.join("");
        function now() {
          return { line, column, offset: index3 + (pos.offset || 0) };
        }
        function parseError(code, offset2) {
          var position = now();
          position.column += offset2, position.offset += offset2, handleWarning.call(warningContext, messages[code], position, code);
        }
        function flush() {
          queue && (result.push(queue), handleText && handleText.call(textContext, queue, { start: prev, end: now() }), queue = "");
        }
      }
      function prohibited(code) {
        return code >= 55296 && code <= 57343 || code > 1114111;
      }
      function disallowed(code) {
        return code >= 1 && code <= 8 || code === 11 || code >= 13 && code <= 31 || code >= 127 && code <= 159 || code >= 64976 && code <= 65007 || (code & 65535) === 65535 || (code & 65535) === 65534;
      }
    } });
    require_prism_core = __commonJS2({ "../../node_modules/refractor/node_modules/prismjs/components/prism-core.js"(exports, module2) {
      var _self = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
      var Prism = function(_self2) {
        var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, uniqueId = 0, plainTextGrammar = {}, _ = { manual: _self2.Prism && _self2.Prism.manual, disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler, util: { encode: function encode(tokens) {
          return tokens instanceof Token ? new Token(tokens.type, encode(tokens.content), tokens.alias) : Array.isArray(tokens) ? tokens.map(encode) : tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        }, type: function(o) {
          return Object.prototype.toString.call(o).slice(8, -1);
        }, objId: function(obj) {
          return obj.__id || Object.defineProperty(obj, "__id", { value: ++uniqueId }), obj.__id;
        }, clone: function deepClone(o, visited) {
          visited = visited || {};
          var clone, id;
          switch (_.util.type(o)) {
            case "Object":
              if (id = _.util.objId(o), visited[id])
                return visited[id];
              clone = {}, visited[id] = clone;
              for (var key in o)
                o.hasOwnProperty(key) && (clone[key] = deepClone(o[key], visited));
              return clone;
            case "Array":
              return id = _.util.objId(o), visited[id] ? visited[id] : (clone = [], visited[id] = clone, o.forEach(function(v, i) {
                clone[i] = deepClone(v, visited);
              }), clone);
            default:
              return o;
          }
        }, getLanguage: function(element) {
          for (; element; ) {
            var m = lang.exec(element.className);
            if (m)
              return m[1].toLowerCase();
            element = element.parentElement;
          }
          return "none";
        }, setLanguage: function(element, language) {
          element.className = element.className.replace(RegExp(lang, "gi"), ""), element.classList.add("language-" + language);
        }, currentScript: function() {
          if (typeof document > "u")
            return null;
          if ("currentScript" in document && 1 < 2)
            return document.currentScript;
          try {
            throw new Error();
          } catch (err) {
            var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
            if (src) {
              var scripts = document.getElementsByTagName("script");
              for (var i in scripts)
                if (scripts[i].src == src)
                  return scripts[i];
            }
            return null;
          }
        }, isActive: function(element, className, defaultActivation) {
          for (var no = "no-" + className; element; ) {
            var classList = element.classList;
            if (classList.contains(className))
              return true;
            if (classList.contains(no))
              return false;
            element = element.parentElement;
          }
          return !!defaultActivation;
        } }, languages: { plain: plainTextGrammar, plaintext: plainTextGrammar, text: plainTextGrammar, txt: plainTextGrammar, extend: function(id, redef) {
          var lang2 = _.util.clone(_.languages[id]);
          for (var key in redef)
            lang2[key] = redef[key];
          return lang2;
        }, insertBefore: function(inside, before, insert, root) {
          root = root || _.languages;
          var grammar = root[inside], ret = {};
          for (var token in grammar)
            if (grammar.hasOwnProperty(token)) {
              if (token == before)
                for (var newToken in insert)
                  insert.hasOwnProperty(newToken) && (ret[newToken] = insert[newToken]);
              insert.hasOwnProperty(token) || (ret[token] = grammar[token]);
            }
          var old = root[inside];
          return root[inside] = ret, _.languages.DFS(_.languages, function(key, value) {
            value === old && key != inside && (this[key] = ret);
          }), ret;
        }, DFS: function DFS(o, callback, type, visited) {
          visited = visited || {};
          var objId = _.util.objId;
          for (var i in o)
            if (o.hasOwnProperty(i)) {
              callback.call(o, i, o[i], type || i);
              var property = o[i], propertyType = _.util.type(property);
              propertyType === "Object" && !visited[objId(property)] ? (visited[objId(property)] = true, DFS(property, callback, null, visited)) : propertyType === "Array" && !visited[objId(property)] && (visited[objId(property)] = true, DFS(property, callback, i, visited));
            }
        } }, plugins: {}, highlightAll: function(async, callback) {
          _.highlightAllUnder(document, async, callback);
        }, highlightAllUnder: function(container, async, callback) {
          var env = { callback, container, selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' };
          _.hooks.run("before-highlightall", env), env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector)), _.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element; element = env.elements[i++]; )
            _.highlightElement(element, async === true, env.callback);
        }, highlightElement: function(element, async, callback) {
          var language = _.util.getLanguage(element), grammar = _.languages[language];
          _.util.setLanguage(element, language);
          var parent = element.parentElement;
          parent && parent.nodeName.toLowerCase() === "pre" && _.util.setLanguage(parent, language);
          var code = element.textContent, env = { element, language, grammar, code };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode, _.hooks.run("before-insert", env), env.element.innerHTML = env.highlightedCode, _.hooks.run("after-highlight", env), _.hooks.run("complete", env), callback && callback.call(env.element);
          }
          if (_.hooks.run("before-sanity-check", env), parent = env.element.parentElement, parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex") && parent.setAttribute("tabindex", "0"), !env.code) {
            _.hooks.run("complete", env), callback && callback.call(env.element);
            return;
          }
          if (_.hooks.run("before-highlight", env), !env.grammar) {
            insertHighlightedCode(_.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            }, worker.postMessage(JSON.stringify({ language: env.language, code: env.code, immediateClose: true }));
          } else
            insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
        }, highlight: function(text, grammar, language) {
          var env = { code: text, grammar, language };
          if (_.hooks.run("before-tokenize", env), !env.grammar)
            throw new Error('The language "' + env.language + '" has no grammar.');
          return env.tokens = _.tokenize(env.code, env.grammar), _.hooks.run("after-tokenize", env), Token.stringify(_.util.encode(env.tokens), env.language);
        }, tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest)
              grammar[token] = rest[token];
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          return addAfter(tokenList, tokenList.head, text), matchGrammar(text, tokenList, grammar, tokenList.head, 0), toArray(tokenList);
        }, hooks: { all: {}, add: function(name, callback) {
          var hooks = _.hooks.all;
          hooks[name] = hooks[name] || [], hooks[name].push(callback);
        }, run: function(name, env) {
          var callbacks = _.hooks.all[name];
          if (!(!callbacks || !callbacks.length))
            for (var i = 0, callback; callback = callbacks[i++]; )
              callback(env);
        } }, Token };
        _self2.Prism = _;
        function Token(type, content, alias, matchedStr) {
          this.type = type, this.content = content, this.alias = alias, this.length = (matchedStr || "").length | 0;
        }
        Token.stringify = function stringify(o, language) {
          if (typeof o == "string")
            return o;
          if (Array.isArray(o)) {
            var s = "";
            return o.forEach(function(e) {
              s += stringify(e, language);
            }), s;
          }
          var env = { type: o.type, content: stringify(o.content, language), tag: "span", classes: ["token", o.type], attributes: {}, language }, aliases = o.alias;
          aliases && (Array.isArray(aliases) ? Array.prototype.push.apply(env.classes, aliases) : env.classes.push(aliases)), _.hooks.run("wrap", env);
          var attributes = "";
          for (var name in env.attributes)
            attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
          return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
        };
        function matchPattern(pattern, pos, text, lookbehind) {
          pattern.lastIndex = pos;
          var match2 = pattern.exec(text);
          if (match2 && lookbehind && match2[1]) {
            var lookbehindLength = match2[1].length;
            match2.index += lookbehindLength, match2[0] = match2[0].slice(lookbehindLength);
          }
          return match2;
        }
        function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
          for (var token in grammar)
            if (!(!grammar.hasOwnProperty(token) || !grammar[token])) {
              var patterns = grammar[token];
              patterns = Array.isArray(patterns) ? patterns : [patterns];
              for (var j = 0; j < patterns.length; ++j) {
                if (rematch && rematch.cause == token + "," + j)
                  return;
                var patternObj = patterns[j], inside = patternObj.inside, lookbehind = !!patternObj.lookbehind, greedy = !!patternObj.greedy, alias = patternObj.alias;
                if (greedy && !patternObj.pattern.global) {
                  var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                  patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
                }
                for (var pattern = patternObj.pattern || patternObj, currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail && !(rematch && pos >= rematch.reach); pos += currentNode.value.length, currentNode = currentNode.next) {
                  var str = currentNode.value;
                  if (tokenList.length > text.length)
                    return;
                  if (!(str instanceof Token)) {
                    var removeCount = 1, match2;
                    if (greedy) {
                      if (match2 = matchPattern(pattern, pos, text, lookbehind), !match2 || match2.index >= text.length)
                        break;
                      var from = match2.index, to = match2.index + match2[0].length, p = pos;
                      for (p += currentNode.value.length; from >= p; )
                        currentNode = currentNode.next, p += currentNode.value.length;
                      if (p -= currentNode.value.length, pos = p, currentNode.value instanceof Token)
                        continue;
                      for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value == "string"); k = k.next)
                        removeCount++, p += k.value.length;
                      removeCount--, str = text.slice(pos, p), match2.index -= pos;
                    } else if (match2 = matchPattern(pattern, 0, str, lookbehind), !match2)
                      continue;
                    var from = match2.index, matchStr = match2[0], before = str.slice(0, from), after = str.slice(from + matchStr.length), reach = pos + str.length;
                    rematch && reach > rematch.reach && (rematch.reach = reach);
                    var removeFrom = currentNode.prev;
                    before && (removeFrom = addAfter(tokenList, removeFrom, before), pos += before.length), removeRange(tokenList, removeFrom, removeCount);
                    var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                    if (currentNode = addAfter(tokenList, removeFrom, wrapped), after && addAfter(tokenList, currentNode, after), removeCount > 1) {
                      var nestedRematch = { cause: token + "," + j, reach };
                      matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch), rematch && nestedRematch.reach > rematch.reach && (rematch.reach = nestedRematch.reach);
                    }
                  }
                }
              }
            }
        }
        function LinkedList() {
          var head = { value: null, prev: null, next: null }, tail = { value: null, prev: head, next: null };
          head.next = tail, this.head = head, this.tail = tail, this.length = 0;
        }
        function addAfter(list, node, value) {
          var next = node.next, newNode = { value, prev: node, next };
          return node.next = newNode, next.prev = newNode, list.length++, newNode;
        }
        function removeRange(list, node, count) {
          for (var next = node.next, i = 0; i < count && next !== list.tail; i++)
            next = next.next;
          node.next = next, next.prev = node, list.length -= i;
        }
        function toArray(list) {
          for (var array = [], node = list.head.next; node !== list.tail; )
            array.push(node.value), node = node.next;
          return array;
        }
        if (!_self2.document)
          return _self2.addEventListener && (_.disableWorkerMessageHandler || _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data), lang2 = message.language, code = message.code, immediateClose = message.immediateClose;
            _self2.postMessage(_.highlight(code, _.languages[lang2], lang2)), immediateClose && _self2.close();
          }, false)), _;
        var script = _.util.currentScript();
        script && (_.filename = script.src, script.hasAttribute("data-manual") && (_.manual = true));
        function highlightAutomaticallyCallback() {
          _.manual || _.highlightAll();
        }
        if (!_.manual) {
          var readyState = document.readyState;
          readyState === "loading" || readyState === "interactive" && script && script.defer ? document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback) : window.requestAnimationFrame ? window.requestAnimationFrame(highlightAutomaticallyCallback) : window.setTimeout(highlightAutomaticallyCallback, 16);
        }
        return _;
      }(_self);
      typeof module2 < "u" && module2.exports && (module2.exports = Prism);
      typeof global < "u" && (global.Prism = Prism);
    } });
    require_core = __commonJS2({ "../../node_modules/refractor/core.js"(exports, module2) {
      var ctx = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof global == "object" ? global : {}, restore = capture();
      ctx.Prism = { manual: true, disableWorkerMessageHandler: true };
      var h = require_hastscript(), decode = require_parse_entities(), Prism = require_prism_core(), markup = require_markup(), css = require_css(), clike = require_clike(), js = require_javascript();
      restore();
      var own = {}.hasOwnProperty;
      function Refractor() {
      }
      Refractor.prototype = Prism;
      var refract = new Refractor();
      module2.exports = refract;
      refract.highlight = highlight;
      refract.register = register;
      refract.alias = alias;
      refract.registered = registered;
      refract.listLanguages = listLanguages;
      register(markup);
      register(css);
      register(clike);
      register(js);
      refract.util.encode = encode;
      refract.Token.stringify = stringify;
      function register(grammar) {
        if (typeof grammar != "function" || !grammar.displayName)
          throw new Error("Expected `function` for `grammar`, got `" + grammar + "`");
        refract.languages[grammar.displayName] === void 0 && grammar(refract);
      }
      function alias(name, alias2) {
        var languages = refract.languages, map = name, key, list, length2, index3;
        alias2 && (map = {}, map[name] = alias2);
        for (key in map)
          for (list = map[key], list = typeof list == "string" ? [list] : list, length2 = list.length, index3 = -1; ++index3 < length2; )
            languages[list[index3]] = languages[key];
      }
      function highlight(value, name) {
        var sup = Prism.highlight, grammar;
        if (typeof value != "string")
          throw new Error("Expected `string` for `value`, got `" + value + "`");
        if (refract.util.type(name) === "Object")
          grammar = name, name = null;
        else {
          if (typeof name != "string")
            throw new Error("Expected `string` for `name`, got `" + name + "`");
          if (own.call(refract.languages, name))
            grammar = refract.languages[name];
          else
            throw new Error("Unknown language: `" + name + "` is not registered");
        }
        return sup.call(this, value, grammar, name);
      }
      function registered(language) {
        if (typeof language != "string")
          throw new Error("Expected `string` for `language`, got `" + language + "`");
        return own.call(refract.languages, language);
      }
      function listLanguages() {
        var languages = refract.languages, list = [], language;
        for (language in languages)
          own.call(languages, language) && typeof languages[language] == "object" && list.push(language);
        return list;
      }
      function stringify(value, language, parent) {
        var env;
        return typeof value == "string" ? { type: "text", value } : refract.util.type(value) === "Array" ? stringifyAll(value, language) : (env = { type: value.type, content: refract.Token.stringify(value.content, language, parent), tag: "span", classes: ["token", value.type], attributes: {}, language, parent }, value.alias && (env.classes = env.classes.concat(value.alias)), refract.hooks.run("wrap", env), h(env.tag + "." + env.classes.join("."), attributes(env.attributes), env.content));
      }
      function stringifyAll(values, language) {
        for (var result = [], length2 = values.length, index3 = -1, value; ++index3 < length2; )
          value = values[index3], value !== "" && value !== null && value !== void 0 && result.push(value);
        for (index3 = -1, length2 = result.length; ++index3 < length2; )
          value = result[index3], result[index3] = refract.Token.stringify(value, language, result);
        return result;
      }
      function encode(tokens) {
        return tokens;
      }
      function attributes(attrs) {
        var key;
        for (key in attrs)
          attrs[key] = decode(attrs[key]);
        return attrs;
      }
      function capture() {
        var defined = "Prism" in ctx, current = defined ? ctx.Prism : void 0;
        return restore2;
        function restore2() {
          defined ? ctx.Prism = current : delete ctx.Prism, defined = void 0, current = void 0;
        }
      }
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-7K7XSER6.mjs
var require_bash;
var init_chunk_7K7XSER6 = __esm({
  "../../node_modules/@storybook/components/dist/chunk-7K7XSER6.mjs"() {
    init_chunk_NNAAFZ4U();
    require_bash = __commonJS2({ "../../node_modules/refractor/lang/bash.js"(exports, module2) {
      module2.exports = bash;
      bash.displayName = "bash";
      bash.aliases = ["shell"];
      function bash(Prism) {
        (function(Prism2) {
          var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b", commandAfterHeredoc = { pattern: /(^(["']?)\w+\2)[ \t]+\S.*/, lookbehind: true, alias: "punctuation", inside: null }, insideString = { bash: commandAfterHeredoc, environment: { pattern: RegExp("\\$" + envVars), alias: "constant" }, variable: [{ pattern: /\$?\(\([\s\S]+?\)\)/, greedy: true, inside: { variable: [{ pattern: /(^\$\(\([\s\S]+)\)\)/, lookbehind: true }, /^\$\(\(/], number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/, operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/, punctuation: /\(\(?|\)\)?|,|;/ } }, { pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/, greedy: true, inside: { variable: /^\$\(|^`|\)$|`$/ } }, { pattern: /\$\{[^}]+\}/, greedy: true, inside: { operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/, punctuation: /[\[\]]/, environment: { pattern: RegExp("(\\{)" + envVars), lookbehind: true, alias: "constant" } } }, /\$(?:\w+|[#?*!@$])/], entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/ };
          Prism2.languages.bash = { shebang: { pattern: /^#!\s*\/.*/, alias: "important" }, comment: { pattern: /(^|[^"{\\$])#.*/, lookbehind: true }, "function-name": [{ pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/, lookbehind: true, alias: "function" }, { pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/, alias: "function" }], "for-or-select": { pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/, alias: "variable", lookbehind: true }, "assign-left": { pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/, inside: { environment: { pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars), lookbehind: true, alias: "constant" } }, alias: "variable", lookbehind: true }, string: [{ pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/, lookbehind: true, greedy: true, inside: insideString }, { pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/, lookbehind: true, greedy: true, inside: { bash: commandAfterHeredoc } }, { pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/, lookbehind: true, greedy: true, inside: insideString }, { pattern: /(^|[^$\\])'[^']*'/, lookbehind: true, greedy: true }, { pattern: /\$'(?:[^'\\]|\\[\s\S])*'/, greedy: true, inside: { entity: insideString.entity } }], environment: { pattern: RegExp("\\$?" + envVars), alias: "constant" }, variable: insideString.variable, function: { pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/, lookbehind: true }, keyword: { pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/, lookbehind: true }, builtin: { pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/, lookbehind: true, alias: "class-name" }, boolean: { pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/, lookbehind: true }, "file-descriptor": { pattern: /\B&\d\b/, alias: "important" }, operator: { pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/, inside: { "file-descriptor": { pattern: /^\d/, alias: "important" } } }, punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/, number: { pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/, lookbehind: true } }, commandAfterHeredoc.inside = Prism2.languages.bash;
          for (var toBeCopied = ["comment", "function-name", "for-or-select", "assign-left", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"], inside = insideString.variable[1].inside, i = 0; i < toBeCopied.length; i++)
            inside[toBeCopied[i]] = Prism2.languages.bash[toBeCopied[i]];
          Prism2.languages.shell = Prism2.languages.bash;
        })(Prism);
      }
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-HNIG72LA.mjs
var require_js_extras;
var init_chunk_HNIG72LA = __esm({
  "../../node_modules/@storybook/components/dist/chunk-HNIG72LA.mjs"() {
    init_chunk_NNAAFZ4U();
    require_js_extras = __commonJS2({ "../../node_modules/refractor/lang/js-extras.js"(exports, module2) {
      module2.exports = jsExtras;
      jsExtras.displayName = "jsExtras";
      jsExtras.aliases = [];
      function jsExtras(Prism) {
        (function(Prism2) {
          Prism2.languages.insertBefore("javascript", "function-variable", { "method-variable": { pattern: RegExp("(\\.\\s*)" + Prism2.languages.javascript["function-variable"].pattern.source), lookbehind: true, alias: ["function-variable", "method", "function", "property-access"] } }), Prism2.languages.insertBefore("javascript", "function", { method: { pattern: RegExp("(\\.\\s*)" + Prism2.languages.javascript.function.source), lookbehind: true, alias: ["function", "property-access"] } }), Prism2.languages.insertBefore("javascript", "constant", { "known-class-name": [{ pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/, alias: "class-name" }, { pattern: /\b(?:[A-Z]\w*)Error\b/, alias: "class-name" }] });
          function withId(source, flags) {
            return RegExp(source.replace(/<ID>/g, function() {
              return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
            }), flags);
          }
          Prism2.languages.insertBefore("javascript", "keyword", { imports: { pattern: withId(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source), lookbehind: true, inside: Prism2.languages.javascript }, exports: { pattern: withId(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source), lookbehind: true, inside: Prism2.languages.javascript } }), Prism2.languages.javascript.keyword.unshift({ pattern: /\b(?:as|default|export|from|import)\b/, alias: "module" }, { pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/, alias: "control-flow" }, { pattern: /\bnull\b/, alias: ["null", "nil"] }, { pattern: /\bundefined\b/, alias: "nil" }), Prism2.languages.insertBefore("javascript", "operator", { spread: { pattern: /\.{3}/, alias: "operator" }, arrow: { pattern: /=>/, alias: "operator" } }), Prism2.languages.insertBefore("javascript", "punctuation", { "property-access": { pattern: withId(/(\.\s*)#?<ID>/.source), lookbehind: true }, "maybe-class-name": { pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/, lookbehind: true }, dom: { pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/, alias: "variable" }, console: { pattern: /\bconsole(?=\s*\.)/, alias: "class-name" } });
          for (var maybeClassNameTokens = ["function", "function-variable", "method", "method-variable", "property-access"], i = 0; i < maybeClassNameTokens.length; i++) {
            var token = maybeClassNameTokens[i], value = Prism2.languages.javascript[token];
            Prism2.util.type(value) === "RegExp" && (value = Prism2.languages.javascript[token] = { pattern: value });
            var inside = value.inside || {};
            value.inside = inside, inside["maybe-class-name"] = /^[A-Z][\s\S]*/;
          }
        })(Prism);
      }
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-3UNGU6BL.mjs
var require_json;
var init_chunk_3UNGU6BL = __esm({
  "../../node_modules/@storybook/components/dist/chunk-3UNGU6BL.mjs"() {
    init_chunk_NNAAFZ4U();
    require_json = __commonJS2({ "../../node_modules/refractor/lang/json.js"(exports, module2) {
      module2.exports = json;
      json.displayName = "json";
      json.aliases = ["webmanifest"];
      function json(Prism) {
        Prism.languages.json = { property: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/, lookbehind: true, greedy: true }, string: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, lookbehind: true, greedy: true }, comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, punctuation: /[{}[\],]/, operator: /:/, boolean: /\b(?:false|true)\b/, null: { pattern: /\bnull\b/, alias: "keyword" } }, Prism.languages.webmanifest = Prism.languages.json;
      }
    } });
  }
});

// ../../node_modules/@storybook/components/dist/chunk-EU3NKDVB.mjs
var require_graphql;
var init_chunk_EU3NKDVB = __esm({
  "../../node_modules/@storybook/components/dist/chunk-EU3NKDVB.mjs"() {
    init_chunk_NNAAFZ4U();
    require_graphql = __commonJS2({ "../../node_modules/refractor/lang/graphql.js"(exports, module2) {
      module2.exports = graphql;
      graphql.displayName = "graphql";
      graphql.aliases = [];
      function graphql(Prism) {
        Prism.languages.graphql = { comment: /#.*/, description: { pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i, greedy: true, alias: "string", inside: { "language-markdown": { pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/, lookbehind: true, inside: Prism.languages.markdown } } }, string: { pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/, greedy: true }, number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, boolean: /\b(?:false|true)\b/, variable: /\$[a-z_]\w*/i, directive: { pattern: /@[a-z_]\w*/i, alias: "function" }, "attr-name": { pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i, greedy: true }, "atom-input": { pattern: /\b[A-Z]\w*Input\b/, alias: "class-name" }, scalar: /\b(?:Boolean|Float|ID|Int|String)\b/, constant: /\b[A-Z][A-Z_\d]*\b/, "class-name": { pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/, lookbehind: true }, fragment: { pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-mutation": { pattern: /(\bmutation\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-query": { pattern: /(\bquery\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/, operator: /[!=|&]|\.{3}/, "property-query": /\w+(?=\s*\()/, object: /\w+(?=\s*\{)/, punctuation: /[!(){}\[\]:=,]/, property: /\w+/ }, Prism.hooks.add("after-tokenize", function(env) {
          if (env.language !== "graphql")
            return;
          var validTokens = env.tokens.filter(function(token) {
            return typeof token != "string" && token.type !== "comment" && token.type !== "scalar";
          }), currentIndex = 0;
          function getToken(offset2) {
            return validTokens[currentIndex + offset2];
          }
          function isTokenType(types, offset2) {
            offset2 = offset2 || 0;
            for (var i2 = 0; i2 < types.length; i2++) {
              var token = getToken(i2 + offset2);
              if (!token || token.type !== types[i2])
                return false;
            }
            return true;
          }
          function findClosingBracket(open, close) {
            for (var stackHeight = 1, i2 = currentIndex; i2 < validTokens.length; i2++) {
              var token = validTokens[i2], content = token.content;
              if (token.type === "punctuation" && typeof content == "string") {
                if (open.test(content))
                  stackHeight++;
                else if (close.test(content) && (stackHeight--, stackHeight === 0))
                  return i2;
              }
            }
            return -1;
          }
          function addAlias(token, alias) {
            var aliases = token.alias;
            aliases ? Array.isArray(aliases) || (token.alias = aliases = [aliases]) : token.alias = aliases = [], aliases.push(alias);
          }
          for (; currentIndex < validTokens.length; ) {
            var startToken = validTokens[currentIndex++];
            if (startToken.type === "keyword" && startToken.content === "mutation") {
              var inputVariables = [];
              if (isTokenType(["definition-mutation", "punctuation"]) && getToken(1).content === "(") {
                currentIndex += 2;
                var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
                if (definitionEnd === -1)
                  continue;
                for (; currentIndex < definitionEnd; currentIndex++) {
                  var t = getToken(0);
                  t.type === "variable" && (addAlias(t, "variable-input"), inputVariables.push(t.content));
                }
                currentIndex = definitionEnd + 1;
              }
              if (isTokenType(["punctuation", "property-query"]) && getToken(0).content === "{" && (currentIndex++, addAlias(getToken(0), "property-mutation"), inputVariables.length > 0)) {
                var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
                if (mutationEnd === -1)
                  continue;
                for (var i = currentIndex; i < mutationEnd; i++) {
                  var varToken = validTokens[i];
                  varToken.type === "variable" && inputVariables.indexOf(varToken.content) >= 0 && addAlias(varToken, "variable-input");
                }
              }
            }
          }
        });
      }
    } });
  }
});

// ../../node_modules/global/window.js
var require_window2 = __commonJS({
  "../../node_modules/global/window.js"(exports, module2) {
    var win;
    if (typeof window !== "undefined") {
      win = window;
    } else if (typeof global !== "undefined") {
      win = global;
    } else if (typeof self !== "undefined") {
      win = self;
    } else {
      win = {};
    }
    module2.exports = win;
  }
});

// ../../node_modules/@storybook/client-logger/dist/index.mjs
var import_global, LOGLEVEL, console2, levels, currentLogLevelString, currentLogLevelNumber, logger, logged, once, deprecate, pretty;
var init_dist = __esm({
  "../../node_modules/@storybook/client-logger/dist/index.mjs"() {
    import_global = __toESM(require_window2(), 1);
    ({ LOGLEVEL, console: console2 } = import_global.default);
    levels = { trace: 1, debug: 2, info: 3, warn: 4, error: 5, silent: 10 };
    currentLogLevelString = LOGLEVEL;
    currentLogLevelNumber = levels[currentLogLevelString] || levels.info;
    logger = { trace: (message, ...rest) => currentLogLevelNumber <= levels.trace && console2.trace(message, ...rest), debug: (message, ...rest) => currentLogLevelNumber <= levels.debug && console2.debug(message, ...rest), info: (message, ...rest) => currentLogLevelNumber <= levels.info && console2.info(message, ...rest), warn: (message, ...rest) => currentLogLevelNumber <= levels.warn && console2.warn(message, ...rest), error: (message, ...rest) => currentLogLevelNumber <= levels.error && console2.error(message, ...rest), log: (message, ...rest) => currentLogLevelNumber < levels.silent && console2.log(message, ...rest) };
    logged = /* @__PURE__ */ new Set();
    once = (type) => (message, ...rest) => {
      if (!logged.has(message))
        return logged.add(message), logger[type](message, ...rest);
    };
    once.clear = () => logged.clear();
    once.trace = once("trace");
    once.debug = once("debug");
    once.info = once("info");
    once.warn = once("warn");
    once.error = once("error");
    once.log = once("log");
    deprecate = once("warn");
    pretty = (type) => (...args) => {
      let argArray = [];
      if (args.length) {
        let startTagRe = /<span\s+style=(['"])([^'"]*)\1\s*>/gi, endTagRe = /<\/span>/gi, reResultArray;
        for (argArray.push(args[0].replace(startTagRe, "%c").replace(endTagRe, "%c")); reResultArray = startTagRe.exec(args[0]); )
          argArray.push(reResultArray[2]), argArray.push("");
        for (let j = 1; j < args.length; j++)
          argArray.push(args[j]);
      }
      logger[type].apply(logger, argArray);
    };
    pretty.trace = pretty("trace");
    pretty.debug = pretty("debug");
    pretty.info = pretty("info");
    pretty.warn = pretty("warn");
    pretty.error = pretty("error");
  }
});

// ../../node_modules/memoizerific/memoizerific.js
var require_memoizerific = __commonJS({
  "../../node_modules/memoizerific/memoizerific.js"(exports, module2) {
    (function(f) {
      if (typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.memoizerific = f();
      }
    })(function() {
      var define2, module3, exports2;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof require == "function" && require;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f = new Error("Cannot find module '" + o2 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o2] = { exports: {} };
            t[o2][0].call(l.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_, module4, exports3) {
        module4.exports = function(forceSimilar) {
          if (typeof Map !== "function" || forceSimilar) {
            var Similar = _dereq_("./similar");
            return new Similar();
          } else {
            return /* @__PURE__ */ new Map();
          }
        };
      }, { "./similar": 2 }], 2: [function(_dereq_, module4, exports3) {
        function Similar() {
          this.list = [];
          this.lastItem = void 0;
          this.size = 0;
          return this;
        }
        Similar.prototype.get = function(key) {
          var index3;
          if (this.lastItem && this.isEqual(this.lastItem.key, key)) {
            return this.lastItem.val;
          }
          index3 = this.indexOf(key);
          if (index3 >= 0) {
            this.lastItem = this.list[index3];
            return this.list[index3].val;
          }
          return void 0;
        };
        Similar.prototype.set = function(key, val) {
          var index3;
          if (this.lastItem && this.isEqual(this.lastItem.key, key)) {
            this.lastItem.val = val;
            return this;
          }
          index3 = this.indexOf(key);
          if (index3 >= 0) {
            this.lastItem = this.list[index3];
            this.list[index3].val = val;
            return this;
          }
          this.lastItem = { key, val };
          this.list.push(this.lastItem);
          this.size++;
          return this;
        };
        Similar.prototype.delete = function(key) {
          var index3;
          if (this.lastItem && this.isEqual(this.lastItem.key, key)) {
            this.lastItem = void 0;
          }
          index3 = this.indexOf(key);
          if (index3 >= 0) {
            this.size--;
            return this.list.splice(index3, 1)[0];
          }
          return void 0;
        };
        Similar.prototype.has = function(key) {
          var index3;
          if (this.lastItem && this.isEqual(this.lastItem.key, key)) {
            return true;
          }
          index3 = this.indexOf(key);
          if (index3 >= 0) {
            this.lastItem = this.list[index3];
            return true;
          }
          return false;
        };
        Similar.prototype.forEach = function(callback, thisArg) {
          var i;
          for (i = 0; i < this.size; i++) {
            callback.call(thisArg || this, this.list[i].val, this.list[i].key, this);
          }
        };
        Similar.prototype.indexOf = function(key) {
          var i;
          for (i = 0; i < this.size; i++) {
            if (this.isEqual(this.list[i].key, key)) {
              return i;
            }
          }
          return -1;
        };
        Similar.prototype.isEqual = function(val1, val2) {
          return val1 === val2 || val1 !== val1 && val2 !== val2;
        };
        module4.exports = Similar;
      }, {}], 3: [function(_dereq_, module4, exports3) {
        var MapOrSimilar = _dereq_("map-or-similar");
        module4.exports = function(limit) {
          var cache = new MapOrSimilar(void 0 === "true"), lru = [];
          return function(fn) {
            var memoizerific = function() {
              var currentCache = cache, newMap, fnResult, argsLengthMinusOne = arguments.length - 1, lruPath = Array(argsLengthMinusOne + 1), isMemoized = true, i;
              if ((memoizerific.numArgs || memoizerific.numArgs === 0) && memoizerific.numArgs !== argsLengthMinusOne + 1) {
                throw new Error("Memoizerific functions should always be called with the same number of arguments");
              }
              for (i = 0; i < argsLengthMinusOne; i++) {
                lruPath[i] = {
                  cacheItem: currentCache,
                  arg: arguments[i]
                };
                if (currentCache.has(arguments[i])) {
                  currentCache = currentCache.get(arguments[i]);
                  continue;
                }
                isMemoized = false;
                newMap = new MapOrSimilar(void 0 === "true");
                currentCache.set(arguments[i], newMap);
                currentCache = newMap;
              }
              if (isMemoized) {
                if (currentCache.has(arguments[argsLengthMinusOne])) {
                  fnResult = currentCache.get(arguments[argsLengthMinusOne]);
                } else {
                  isMemoized = false;
                }
              }
              if (!isMemoized) {
                fnResult = fn.apply(null, arguments);
                currentCache.set(arguments[argsLengthMinusOne], fnResult);
              }
              if (limit > 0) {
                lruPath[argsLengthMinusOne] = {
                  cacheItem: currentCache,
                  arg: arguments[argsLengthMinusOne]
                };
                if (isMemoized) {
                  moveToMostRecentLru(lru, lruPath);
                } else {
                  lru.push(lruPath);
                }
                if (lru.length > limit) {
                  removeCachedResult(lru.shift());
                }
              }
              memoizerific.wasMemoized = isMemoized;
              memoizerific.numArgs = argsLengthMinusOne + 1;
              return fnResult;
            };
            memoizerific.limit = limit;
            memoizerific.wasMemoized = false;
            memoizerific.cache = cache;
            memoizerific.lru = lru;
            return memoizerific;
          };
        };
        function moveToMostRecentLru(lru, lruPath) {
          var lruLen = lru.length, lruPathLen = lruPath.length, isMatch, i, ii;
          for (i = 0; i < lruLen; i++) {
            isMatch = true;
            for (ii = 0; ii < lruPathLen; ii++) {
              if (!isEqual2(lru[i][ii].arg, lruPath[ii].arg)) {
                isMatch = false;
                break;
              }
            }
            if (isMatch) {
              break;
            }
          }
          lru.push(lru.splice(i, 1)[0]);
        }
        function removeCachedResult(removedLru) {
          var removedLruLen = removedLru.length, currentLru = removedLru[removedLruLen - 1], tmp, i;
          currentLru.cacheItem.delete(currentLru.arg);
          for (i = removedLruLen - 2; i >= 0; i--) {
            currentLru = removedLru[i];
            tmp = currentLru.cacheItem.get(currentLru.arg);
            if (!tmp || !tmp.size) {
              currentLru.cacheItem.delete(currentLru.arg);
            } else {
              break;
            }
          }
        }
        function isEqual2(val1, val2) {
          return val1 === val2 || val1 !== val1 && val2 !== val2;
        }
      }, { "map-or-similar": 1 }] }, {}, [3])(3);
    });
  }
});

// ../../node_modules/@storybook/components/dist/GlobalScrollAreaStyles-XIHNDKUY.mjs
var GlobalScrollAreaStyles_XIHNDKUY_exports = {};
__export(GlobalScrollAreaStyles_XIHNDKUY_exports, {
  default: () => GlobalScrollAreaStyles_default,
  getScrollAreaStyles: () => getScrollAreaStyles
});
var import_react, import_theming2, hsResizeObserverDummyAnimation, getScrollAreaStyles, GlobalScrollAreaStyles, GlobalScrollAreaStyles_default;
var init_GlobalScrollAreaStyles_XIHNDKUY = __esm({
  "../../node_modules/@storybook/components/dist/GlobalScrollAreaStyles-XIHNDKUY.mjs"() {
    import_react = __toESM(require("react"), 1);
    import_theming2 = require("@storybook/theming");
    hsResizeObserverDummyAnimation = import_theming2.keyframes`0%{z-index:0}to{z-index:-1}`;
    getScrollAreaStyles = (theme) => ({ "html.os-html, html.os-html>.os-host": { display: "block", overflow: "hidden", boxSizing: "border-box", height: "100%!important", width: "100%!important", minWidth: "100%!important", minHeight: "100%!important", margin: "0!important", position: "absolute!important" }, "html.os-html>.os-host>.os-padding": { position: "absolute" }, "body.os-dragging, body.os-dragging *": { cursor: "default" }, ".os-host, .os-host-textarea": { position: "relative", overflow: "visible!important", flexDirection: "column", flexWrap: "nowrap", justifyContent: "flex-start", alignContent: "flex-start", alignItems: "flex-start" }, ".os-host-flexbox": { overflow: "hidden!important", display: "flex" }, ".os-host-flexbox>.os-size-auto-observer": { height: "inherit!important" }, ".os-host-flexbox>.os-content-glue": { flexGrow: 1, flexShrink: 0 }, ".os-host-flexbox>.os-size-auto-observer, .os-host-flexbox>.os-content-glue": { minHeight: 0, minWidth: 0, flexGrow: 0, flexShrink: 1, flexBasis: "auto" }, "#os-dummy-scrollbar-size": { position: "fixed", opacity: 0, visibility: "hidden", overflow: "scroll", height: 500, width: 500 }, "#os-dummy-scrollbar-size>div": { width: "200%", height: "200%", margin: 10 }, "#os-dummy-scrollbar-size, .os-viewport": {}, ".os-viewport-native-scrollbars-invisible#os-dummy-scrollbar-size, .os-viewport-native-scrollbars-invisible.os-viewport": { scrollbarWidth: "none!important" }, ".os-viewport-native-scrollbars-invisible#os-dummy-scrollbar-size::-webkit-scrollbar, .os-viewport-native-scrollbars-invisible.os-viewport::-webkit-scrollbar, .os-viewport-native-scrollbars-invisible#os-dummy-scrollbar-size::-webkit-scrollbar-corner, .os-viewport-native-scrollbars-invisible.os-viewport::-webkit-scrollbar-corner": { display: "none!important", width: "0!important", height: "0!important", visibility: "hidden!important", background: "0 0!important" }, ".os-content-glue": { boxSizing: "inherit", maxHeight: "100%", maxWidth: "100%", width: "100%", pointerEvents: "none" }, ".os-padding": { boxSizing: "inherit", direction: "inherit", position: "absolute", overflow: "visible", padding: 0, margin: 0, left: 0, top: 0, bottom: 0, right: 0, width: "auto!important", height: "auto!important", zIndex: 1 }, ".os-host-overflow>.os-padding": { overflow: "hidden" }, ".os-viewport": { direction: "inherit!important", boxSizing: "inherit!important", resize: "none!important", outline: "0!important", position: "absolute", overflow: "hidden", top: 0, left: 0, bottom: 0, right: 0, padding: 0, margin: 0 }, ".os-content-arrange": { position: "absolute", zIndex: -1, minHeight: 1, minWidth: 1, pointerEvents: "none" }, ".os-content": { direction: "inherit", boxSizing: "border-box!important", position: "relative", display: "block", height: "100%", width: "100%", visibility: "visible" }, ".os-content:before, .os-content:after": { content: "''", display: "table", width: 0, height: 0, lineHeight: 0, fontSize: 0 }, ".os-content>.os-textarea": { boxSizing: "border-box!important", direction: "inherit!important", background: "0 0!important", outline: "0 transparent!important", overflow: "hidden!important", position: "absolute!important", display: "block!important", top: "0!important", left: "0!important", margin: "0!important", borderRadius: "0!important", float: "none!important", filter: "none!important", border: "0!important", resize: "none!important", transform: "none!important", maxWidth: "none!important", maxHeight: "none!important", boxShadow: "none!important", perspective: "none!important", opacity: "1!important", zIndex: "1!important", clip: "auto!important", verticalAlign: "baseline!important", padding: 0 }, ".os-host-rtl>.os-padding>.os-viewport>.os-content>.os-textarea": { right: "0!important" }, ".os-content>.os-textarea-cover": { zIndex: -1, pointerEvents: "none" }, ".os-content>.os-textarea[wrap=off]": { whiteSpace: "pre!important", margin: "0!important" }, ".os-text-inherit": { fontFamily: "inherit", fontSize: "inherit", fontWeight: "inherit", fontStyle: "inherit", fontVariant: "inherit", textTransform: "inherit", textDecoration: "inherit", textIndent: "inherit", textAlign: "inherit", textShadow: "inherit", textOverflow: "inherit", letterSpacing: "inherit", wordSpacing: "inherit", lineHeight: "inherit", unicodeBidi: "inherit", direction: "inherit", color: "inherit", cursor: "text" }, ".os-resize-observer, .os-resize-observer-host": { boxSizing: "inherit", display: "block", opacity: 0, position: "absolute", top: 0, left: 0, height: "100%", width: "100%", overflow: "hidden", pointerEvents: "none", zIndex: -1 }, ".os-resize-observer-host": { padding: "inherit", border: "inherit", borderColor: "transparent", borderStyle: "solid", boxSizing: "border-box" }, ".os-resize-observer-host:after": { content: "''" }, ".os-resize-observer-host>.os-resize-observer, .os-resize-observer-host:after": { height: "200%", width: "200%", padding: "inherit", border: "inherit", margin: 0, display: "block", boxSizing: "content-box" }, ".os-resize-observer.observed, object.os-resize-observer": { boxSizing: "border-box!important" }, ".os-size-auto-observer": { boxSizing: "inherit!important", height: "100%", width: "inherit", maxWidth: 1, position: "relative", float: "left", maxHeight: 1, overflow: "hidden", zIndex: -1, padding: 0, margin: 0, pointerEvents: "none", flexGrow: "inherit", flexShrink: 0, flexBasis: 0 }, ".os-size-auto-observer>.os-resize-observer": { width: "1000%", height: "1000%", minHeight: 1, minWidth: 1 }, ".os-resize-observer-item": { position: "absolute", top: 0, right: 0, bottom: 0, left: 0, overflow: "hidden", zIndex: -1, opacity: 0, direction: "ltr!important", flex: "none!important" }, ".os-resize-observer-item-final": { position: "absolute", left: 0, top: 0, transition: "none!important", flex: "none!important" }, ".os-resize-observer": { animationDuration: ".001s", animationName: `${hsResizeObserverDummyAnimation}` }, ".os-host-transition>.os-scrollbar, .os-host-transition>.os-scrollbar-corner": { transition: "opacity .3s,visibility .3s,top .3s,right .3s,bottom .3s,left .3s" }, "html.os-html>.os-host>.os-scrollbar": { position: "absolute", zIndex: 999999 }, ".os-scrollbar, .os-scrollbar-corner": { position: "absolute", opacity: 1, zIndex: 1 }, ".os-scrollbar-corner": { bottom: 0, right: 0, height: 10, width: 10, backgroundColor: "transparent" }, ".os-scrollbar": { pointerEvents: "none", padding: 2, boxSizing: "border-box", background: 0 }, ".os-scrollbar-track": { pointerEvents: "auto", position: "relative", height: "100%", width: "100%", padding: "0!important", border: "0!important" }, ".os-scrollbar-handle": { pointerEvents: "auto", position: "absolute", width: "100%", height: "100%" }, ".os-scrollbar-handle-off, .os-scrollbar-track-off": { pointerEvents: "none" }, ".os-scrollbar.os-scrollbar-unusable, .os-scrollbar.os-scrollbar-unusable *": { pointerEvents: "none!important" }, ".os-scrollbar.os-scrollbar-unusable .os-scrollbar-handle": { opacity: "0!important" }, ".os-scrollbar-horizontal": { bottom: 0, left: 0, right: 10, height: 10 }, ".os-scrollbar-vertical": { top: 0, right: 0, bottom: 10, width: 10 }, ".os-host-rtl>.os-scrollbar-horizontal": { right: 0 }, ".os-host-rtl>.os-scrollbar-vertical": { right: "auto", left: 0 }, ".os-host-rtl>.os-scrollbar-corner": { right: "auto", left: 0 }, ".os-scrollbar-auto-hidden, .os-padding+.os-scrollbar-corner, .os-host-resize-disabled.os-host-scrollbar-horizontal-hidden>.os-scrollbar-corner, .os-host-scrollbar-horizontal-hidden>.os-scrollbar-horizontal, .os-host-resize-disabled.os-host-scrollbar-vertical-hidden>.os-scrollbar-corner, .os-host-scrollbar-vertical-hidden>.os-scrollbar-vertical, .os-scrollbar-horizontal.os-scrollbar-auto-hidden+.os-scrollbar-vertical+.os-scrollbar-corner, .os-scrollbar-horizontal+.os-scrollbar-vertical.os-scrollbar-auto-hidden+.os-scrollbar-corner, .os-scrollbar-horizontal.os-scrollbar-auto-hidden+.os-scrollbar-vertical.os-scrollbar-auto-hidden+.os-scrollbar-corner": { opacity: 0, visibility: "hidden", pointerEvents: "none" }, ".os-scrollbar-corner-resize-both": { cursor: "nwse-resize" }, ".os-host-rtl>.os-scrollbar-corner-resize-both": { cursor: "nesw-resize" }, ".os-scrollbar-corner-resize-horizontal": { cursor: "ew-resize" }, ".os-scrollbar-corner-resize-vertical": { cursor: "ns-resize" }, ".os-dragging .os-scrollbar-corner.os-scrollbar-corner-resize": { cursor: "default" }, ".os-host-resize-disabled.os-host-scrollbar-horizontal-hidden>.os-scrollbar-vertical": { top: 0, bottom: 0 }, ".os-host-resize-disabled.os-host-scrollbar-vertical-hidden>.os-scrollbar-horizontal, .os-host-rtl.os-host-resize-disabled.os-host-scrollbar-vertical-hidden>.os-scrollbar-horizontal": { right: 0, left: 0 }, ".os-scrollbar:hover, .os-scrollbar-corner.os-scrollbar-corner-resize": { opacity: "1!important", visibility: "visible!important" }, ".os-scrollbar-corner.os-scrollbar-corner-resize": { backgroundImage: "linear-gradient(135deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0)  50%, rgba(0,0,0,0.4) 50%, rgba(0,0,0,0.4) 100%)", backgroundRepeat: "no-repeat", backgroundPosition: "100% 100%", pointerEvents: "auto!important" }, ".os-host-rtl>.os-scrollbar-corner.os-scrollbar-corner-resize": { transform: "scale(-1,1)" }, ".os-host-overflow": { overflow: "hidden!important" }, ".os-theme-dark.os-host-rtl>.os-scrollbar-horizontal": { left: 10, right: 0 }, ".os-scrollbar.os-scrollbar-unusable": { background: 0 }, ".os-scrollbar>.os-scrollbar-track": { background: 0 }, ".os-scrollbar-horizontal>.os-scrollbar-track>.os-scrollbar-handle": { minWidth: 30 }, ".os-scrollbar-vertical>.os-scrollbar-track>.os-scrollbar-handle": { minHeight: 30 }, ".os-theme-dark.os-host-transition>.os-scrollbar>.os-scrollbar-track>.os-scrollbar-handle": { transition: "background-color .3s" }, ".os-scrollbar>.os-scrollbar-track>.os-scrollbar-handle, .os-scrollbar>.os-scrollbar-track": { borderRadius: 10 }, ".os-scrollbar>.os-scrollbar-track>.os-scrollbar-handle": { background: theme.textMutedColor, opacity: 0.5 }, ".os-scrollbar:hover>.os-scrollbar-track>.os-scrollbar-handle": { opacity: 0.6 }, ".os-scrollbar-horizontal .os-scrollbar-handle:before, .os-scrollbar-vertical .os-scrollbar-handle:before": { content: "''", position: "absolute", left: 0, right: 0, top: 0, bottom: 0, display: "block" }, ".os-theme-dark.os-host-scrollbar-horizontal-hidden>.os-scrollbar-horizontal .os-scrollbar-handle:before, .os-theme-dark.os-host-scrollbar-vertical-hidden>.os-scrollbar-vertical .os-scrollbar-handle:before": { display: "none" }, ".os-scrollbar-horizontal .os-scrollbar-handle:before": { top: -6, bottom: -2 }, ".os-scrollbar-vertical .os-scrollbar-handle:before": { left: -6, right: -2 }, ".os-host-rtl.os-scrollbar-vertical .os-scrollbar-handle:before": { right: -6, left: -2 } });
    GlobalScrollAreaStyles = () => import_react.default.createElement(import_theming2.Global, { styles: getScrollAreaStyles });
    GlobalScrollAreaStyles_default = GlobalScrollAreaStyles;
  }
});

// ../../node_modules/@storybook/components/dist/OverlayScrollbars-VWTZRU7C.mjs
var OverlayScrollbars_VWTZRU7C_exports = {};
__export(OverlayScrollbars_VWTZRU7C_exports, {
  OverlayScrollbarsComponent: () => OverlayScrollbarsComponent,
  default: () => OverlayScrollbars_default
});
function mergeHostClassNames(osInstance, className) {
  if (import_overlayscrollbars.default.valid(osInstance)) {
    let { host } = osInstance.getElements(), regex = new RegExp(`(^os-host([-_].+|)$)|${osInstance.options().className.replace(/\s/g, "$|")}$`, "g"), osClassNames = host.className.split(" ").filter((name) => name.match(regex)).join(" ");
    host.className = `${osClassNames} ${className || ""}`;
  }
}
var import_react2, require_OverlayScrollbars, import_overlayscrollbars, OverlayScrollbarsComponent, OverlayScrollbars_default;
var init_OverlayScrollbars_VWTZRU7C = __esm({
  "../../node_modules/@storybook/components/dist/OverlayScrollbars-VWTZRU7C.mjs"() {
    init_chunk_NNAAFZ4U();
    import_react2 = __toESM(require("react"), 1);
    require_OverlayScrollbars = __commonJS2({ "../../node_modules/overlayscrollbars/js/OverlayScrollbars.js"(exports, module2) {
      (function(global3, factory) {
        typeof define == "function" && define.amd ? define(function() {
          return factory(global3, global3.document, void 0);
        }) : typeof module2 == "object" && typeof module2.exports == "object" ? module2.exports = factory(global3, global3.document, void 0) : factory(global3, global3.document, void 0);
      })(typeof window < "u" ? window : exports, function(window2, document3, undefined2) {
        "use strict";
        var PLUGINNAME = "OverlayScrollbars", TYPES = { o: "object", f: "function", a: "array", s: "string", b: "boolean", n: "number", u: "undefined", z: "null" }, LEXICON = { c: "class", s: "style", i: "id", l: "length", p: "prototype", ti: "tabindex", oH: "offsetHeight", cH: "clientHeight", sH: "scrollHeight", oW: "offsetWidth", cW: "clientWidth", sW: "scrollWidth", hOP: "hasOwnProperty", bCR: "getBoundingClientRect" }, VENDORS = function() {
          var jsCache = {}, cssCache = {}, cssPrefixes = ["-webkit-", "-moz-", "-o-", "-ms-"], jsPrefixes = ["WebKit", "Moz", "O", "MS"];
          function firstLetterToUpper(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
          }
          return { _cssPrefixes: cssPrefixes, _jsPrefixes: jsPrefixes, _cssProperty: function(name) {
            var result = cssCache[name];
            if (cssCache[LEXICON.hOP](name))
              return result;
            for (var uppercasedName = firstLetterToUpper(name), elmStyle = document3.createElement("div")[LEXICON.s], resultPossibilities, i = 0, v, currVendorWithoutDashes; i < cssPrefixes.length; i++)
              for (currVendorWithoutDashes = cssPrefixes[i].replace(/-/g, ""), resultPossibilities = [name, cssPrefixes[i] + name, currVendorWithoutDashes + uppercasedName, firstLetterToUpper(currVendorWithoutDashes) + uppercasedName], v = 0; v < resultPossibilities[LEXICON.l]; v++)
                if (elmStyle[resultPossibilities[v]] !== undefined2) {
                  result = resultPossibilities[v];
                  break;
                }
            return cssCache[name] = result, result;
          }, _cssPropertyValue: function(property, values, suffix) {
            var name = property + " " + values, result = cssCache[name];
            if (cssCache[LEXICON.hOP](name))
              return result;
            for (var dummyStyle = document3.createElement("div")[LEXICON.s], possbleValues = values.split(" "), preparedSuffix = suffix || "", i = 0, v = -1, prop; i < possbleValues[LEXICON.l]; i++)
              for (; v < VENDORS._cssPrefixes[LEXICON.l]; v++)
                if (prop = v < 0 ? possbleValues[i] : VENDORS._cssPrefixes[v] + possbleValues[i], dummyStyle.cssText = property + ":" + prop + preparedSuffix, dummyStyle[LEXICON.l]) {
                  result = prop;
                  break;
                }
            return cssCache[name] = result, result;
          }, _jsAPI: function(name, isInterface, fallback) {
            var i = 0, result = jsCache[name];
            if (!jsCache[LEXICON.hOP](name)) {
              for (result = window2[name]; i < jsPrefixes[LEXICON.l]; i++)
                result = result || window2[(isInterface ? jsPrefixes[i] : jsPrefixes[i].toLowerCase()) + firstLetterToUpper(name)];
              jsCache[name] = result;
            }
            return result || fallback;
          } };
        }(), COMPATIBILITY = function() {
          function windowSize(x) {
            return x ? window2.innerWidth || document3.documentElement[LEXICON.cW] || document3.body[LEXICON.cW] : window2.innerHeight || document3.documentElement[LEXICON.cH] || document3.body[LEXICON.cH];
          }
          function bind(func, thisObj) {
            if (typeof func != TYPES.f)
              throw "Can't bind function!";
            var proto = LEXICON.p, aArgs = Array[proto].slice.call(arguments, 2), fNOP = function() {
            }, fBound = function() {
              return func.apply(this instanceof fNOP ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments)));
            };
            return func[proto] && (fNOP[proto] = func[proto]), fBound[proto] = new fNOP(), fBound;
          }
          return { wW: bind(windowSize, 0, true), wH: bind(windowSize, 0), mO: bind(VENDORS._jsAPI, 0, "MutationObserver", true), rO: bind(VENDORS._jsAPI, 0, "ResizeObserver", true), rAF: bind(VENDORS._jsAPI, 0, "requestAnimationFrame", false, function(func) {
            return window2.setTimeout(func, 1e3 / 60);
          }), cAF: bind(VENDORS._jsAPI, 0, "cancelAnimationFrame", false, function(id) {
            return window2.clearTimeout(id);
          }), now: function() {
            return Date.now && Date.now() || new Date().getTime();
          }, stpP: function(event) {
            event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
          }, prvD: function(event) {
            event.preventDefault && event.cancelable ? event.preventDefault() : event.returnValue = false;
          }, page: function(event) {
            event = event.originalEvent || event;
            var strPage = "page", strClient = "client", strX = "X", strY = "Y", target = event.target || event.srcElement || document3, eventDoc = target.ownerDocument || document3, doc = eventDoc.documentElement, body = eventDoc.body;
            if (event.touches !== undefined2) {
              var touch = event.touches[0];
              return { x: touch[strPage + strX], y: touch[strPage + strY] };
            }
            return !event[strPage + strX] && event[strClient + strX] && event[strClient + strX] != null ? { x: event[strClient + strX] + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0), y: event[strClient + strY] + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0) } : { x: event[strPage + strX], y: event[strPage + strY] };
          }, mBtn: function(event) {
            var button = event.button;
            return !event.which && button !== undefined2 ? button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0 : event.which;
          }, inA: function(item, arr) {
            for (var i = 0; i < arr[LEXICON.l]; i++)
              try {
                if (arr[i] === item)
                  return i;
              } catch {
              }
            return -1;
          }, isA: function(arr) {
            var def = Array.isArray;
            return def ? def(arr) : this.type(arr) == TYPES.a;
          }, type: function(obj) {
            return obj === undefined2 || obj === null ? obj + "" : Object[LEXICON.p].toString.call(obj).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
          }, bind };
        }(), MATH = Math, JQUERY = window2.jQuery, EASING = function() {
          var _easingsMath = { p: MATH.PI, c: MATH.cos, s: MATH.sin, w: MATH.pow, t: MATH.sqrt, n: MATH.asin, a: MATH.abs, o: 1.70158 };
          return { swing: function(x, t, b, c, d) {
            return 0.5 - _easingsMath.c(x * _easingsMath.p) / 2;
          }, linear: function(x, t, b, c, d) {
            return x;
          }, easeInQuad: function(x, t, b, c, d) {
            return c * (t /= d) * t + b;
          }, easeOutQuad: function(x, t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
          }, easeInOutQuad: function(x, t, b, c, d) {
            return (t /= d / 2) < 1 ? c / 2 * t * t + b : -c / 2 * (--t * (t - 2) - 1) + b;
          }, easeInCubic: function(x, t, b, c, d) {
            return c * (t /= d) * t * t + b;
          }, easeOutCubic: function(x, t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
          }, easeInOutCubic: function(x, t, b, c, d) {
            return (t /= d / 2) < 1 ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b;
          }, easeInQuart: function(x, t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
          }, easeOutQuart: function(x, t, b, c, d) {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
          }, easeInOutQuart: function(x, t, b, c, d) {
            return (t /= d / 2) < 1 ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b;
          }, easeInQuint: function(x, t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
          }, easeOutQuint: function(x, t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
          }, easeInOutQuint: function(x, t, b, c, d) {
            return (t /= d / 2) < 1 ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
          }, easeInSine: function(x, t, b, c, d) {
            return -c * _easingsMath.c(t / d * (_easingsMath.p / 2)) + c + b;
          }, easeOutSine: function(x, t, b, c, d) {
            return c * _easingsMath.s(t / d * (_easingsMath.p / 2)) + b;
          }, easeInOutSine: function(x, t, b, c, d) {
            return -c / 2 * (_easingsMath.c(_easingsMath.p * t / d) - 1) + b;
          }, easeInExpo: function(x, t, b, c, d) {
            return t == 0 ? b : c * _easingsMath.w(2, 10 * (t / d - 1)) + b;
          }, easeOutExpo: function(x, t, b, c, d) {
            return t == d ? b + c : c * (-_easingsMath.w(2, -10 * t / d) + 1) + b;
          }, easeInOutExpo: function(x, t, b, c, d) {
            return t == 0 ? b : t == d ? b + c : (t /= d / 2) < 1 ? c / 2 * _easingsMath.w(2, 10 * (t - 1)) + b : c / 2 * (-_easingsMath.w(2, -10 * --t) + 2) + b;
          }, easeInCirc: function(x, t, b, c, d) {
            return -c * (_easingsMath.t(1 - (t /= d) * t) - 1) + b;
          }, easeOutCirc: function(x, t, b, c, d) {
            return c * _easingsMath.t(1 - (t = t / d - 1) * t) + b;
          }, easeInOutCirc: function(x, t, b, c, d) {
            return (t /= d / 2) < 1 ? -c / 2 * (_easingsMath.t(1 - t * t) - 1) + b : c / 2 * (_easingsMath.t(1 - (t -= 2) * t) + 1) + b;
          }, easeInElastic: function(x, t, b, c, d) {
            var s = _easingsMath.o, p = 0, a = c;
            return t == 0 ? b : (t /= d) == 1 ? b + c : (p || (p = d * 0.3), a < _easingsMath.a(c) ? (a = c, s = p / 4) : s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a), -(a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b);
          }, easeOutElastic: function(x, t, b, c, d) {
            var s = _easingsMath.o, p = 0, a = c;
            return t == 0 ? b : (t /= d) == 1 ? b + c : (p || (p = d * 0.3), a < _easingsMath.a(c) ? (a = c, s = p / 4) : s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a), a * _easingsMath.w(2, -10 * t) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) + c + b);
          }, easeInOutElastic: function(x, t, b, c, d) {
            var s = _easingsMath.o, p = 0, a = c;
            return t == 0 ? b : (t /= d / 2) == 2 ? b + c : (p || (p = d * (0.3 * 1.5)), a < _easingsMath.a(c) ? (a = c, s = p / 4) : s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a), t < 1 ? -0.5 * (a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b : a * _easingsMath.w(2, -10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) * 0.5 + c + b);
          }, easeInBack: function(x, t, b, c, d, s) {
            return s = s || _easingsMath.o, c * (t /= d) * t * ((s + 1) * t - s) + b;
          }, easeOutBack: function(x, t, b, c, d, s) {
            return s = s || _easingsMath.o, c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
          }, easeInOutBack: function(x, t, b, c, d, s) {
            return s = s || _easingsMath.o, (t /= d / 2) < 1 ? c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b : c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
          }, easeInBounce: function(x, t, b, c, d) {
            return c - this.easeOutBounce(x, d - t, 0, c, d) + b;
          }, easeOutBounce: function(x, t, b, c, d) {
            var o = 7.5625;
            return (t /= d) < 1 / 2.75 ? c * (o * t * t) + b : t < 2 / 2.75 ? c * (o * (t -= 1.5 / 2.75) * t + 0.75) + b : t < 2.5 / 2.75 ? c * (o * (t -= 2.25 / 2.75) * t + 0.9375) + b : c * (o * (t -= 2.625 / 2.75) * t + 0.984375) + b;
          }, easeInOutBounce: function(x, t, b, c, d) {
            return t < d / 2 ? this.easeInBounce(x, t * 2, 0, c, d) * 0.5 + b : this.easeOutBounce(x, t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
          } };
        }(), FRAMEWORK = function() {
          var _rnothtmlwhite = /[^\x20\t\r\n\f]+/g, _strSpace = " ", _strEmpty = "", _strScrollLeft = "scrollLeft", _strScrollTop = "scrollTop", _animations = [], _type = COMPATIBILITY.type, _cssNumber = { animationIterationCount: true, columnCount: true, fillOpacity: true, flexGrow: true, flexShrink: true, fontWeight: true, lineHeight: true, opacity: true, order: true, orphans: true, widows: true, zIndex: true, zoom: true };
          function extend() {
            var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length2 = arguments[LEXICON.l], deep = false;
            for (_type(target) == TYPES.b && (deep = target, target = arguments[1] || {}, i = 2), _type(target) != TYPES.o && !_type(target) == TYPES.f && (target = {}), length2 === i && (target = FakejQuery, --i); i < length2; i++)
              if ((options = arguments[i]) != null)
                for (name in options)
                  src = target[name], copy = options[name], target !== copy && (deep && copy && (isPlainObject(copy) || (copyIsArray = COMPATIBILITY.isA(copy))) ? (copyIsArray ? (copyIsArray = false, clone = src && COMPATIBILITY.isA(src) ? src : []) : clone = src && isPlainObject(src) ? src : {}, target[name] = extend(deep, clone, copy)) : copy !== undefined2 && (target[name] = copy));
            return target;
          }
          function inArray(item, arr, fromIndex) {
            for (var i = fromIndex || 0; i < arr[LEXICON.l]; i++)
              if (arr[i] === item)
                return i;
            return -1;
          }
          function isFunction(obj) {
            return _type(obj) == TYPES.f;
          }
          function isEmptyObject(obj) {
            for (var name in obj)
              return false;
            return true;
          }
          function isPlainObject(obj) {
            if (!obj || _type(obj) != TYPES.o)
              return false;
            var key, proto = LEXICON.p, hasOwnProperty = Object[proto].hasOwnProperty, hasOwnConstructor = hasOwnProperty.call(obj, "constructor"), hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty.call(obj.constructor[proto], "isPrototypeOf");
            if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf)
              return false;
            for (key in obj)
              ;
            return _type(key) == TYPES.u || hasOwnProperty.call(obj, key);
          }
          function each(obj, callback) {
            var i = 0;
            if (isArrayLike(obj))
              for (; i < obj[LEXICON.l] && callback.call(obj[i], i, obj[i]) !== false; i++)
                ;
            else
              for (i in obj)
                if (callback.call(obj[i], i, obj[i]) === false)
                  break;
            return obj;
          }
          function isArrayLike(obj) {
            var length2 = !!obj && [LEXICON.l] in obj && obj[LEXICON.l], t = _type(obj);
            return isFunction(t) ? false : t == TYPES.a || length2 === 0 || _type(length2) == TYPES.n && length2 > 0 && length2 - 1 in obj;
          }
          function stripAndCollapse(value) {
            var tokens = value.match(_rnothtmlwhite) || [];
            return tokens.join(_strSpace);
          }
          function matches(elem, selector) {
            for (var nodeList = (elem.parentNode || document3).querySelectorAll(selector) || [], i = nodeList[LEXICON.l]; i--; )
              if (nodeList[i] == elem)
                return true;
            return false;
          }
          function insertAdjacentElement(el, strategy, child) {
            if (COMPATIBILITY.isA(child))
              for (var i = 0; i < child[LEXICON.l]; i++)
                insertAdjacentElement(el, strategy, child[i]);
            else
              _type(child) == TYPES.s ? el.insertAdjacentHTML(strategy, child) : el.insertAdjacentElement(strategy, child.nodeType ? child : child[0]);
          }
          function setCSSVal(el, prop, val) {
            try {
              el[LEXICON.s][prop] !== undefined2 && (el[LEXICON.s][prop] = parseCSSVal(prop, val));
            } catch {
            }
          }
          function parseCSSVal(prop, val) {
            return !_cssNumber[prop.toLowerCase()] && _type(val) == TYPES.n && (val += "px"), val;
          }
          function startNextAnimationInQ(animObj, removeFromQ) {
            var index3, nextAnim;
            removeFromQ !== false && animObj.q.splice(0, 1), animObj.q[LEXICON.l] > 0 ? (nextAnim = animObj.q[0], animate(animObj.el, nextAnim.props, nextAnim.duration, nextAnim.easing, nextAnim.complete, true)) : (index3 = inArray(animObj, _animations), index3 > -1 && _animations.splice(index3, 1));
          }
          function setAnimationValue(el, prop, value) {
            prop === _strScrollLeft || prop === _strScrollTop ? el[prop] = value : setCSSVal(el, prop, value);
          }
          function animate(el, props, options, easing, complete, guaranteedNext) {
            var hasOptions = isPlainObject(options), from = {}, to = {}, i = 0, key, animObj, start2, progress, step, specialEasing, duration;
            for (hasOptions ? (easing = options.easing, start2 = options.start, progress = options.progress, step = options.step, specialEasing = options.specialEasing, complete = options.complete, duration = options.duration) : duration = options, specialEasing = specialEasing || {}, duration = duration || 400, easing = easing || "swing", guaranteedNext = guaranteedNext || false; i < _animations[LEXICON.l]; i++)
              if (_animations[i].el === el) {
                animObj = _animations[i];
                break;
              }
            animObj || (animObj = { el, q: [] }, _animations.push(animObj));
            for (key in props)
              key === _strScrollLeft || key === _strScrollTop ? from[key] = el[key] : from[key] = FakejQuery(el).css(key);
            for (key in from)
              from[key] !== props[key] && props[key] !== undefined2 && (to[key] = props[key]);
            if (isEmptyObject(to))
              guaranteedNext && startNextAnimationInQ(animObj);
            else {
              var timeNow, end2, percent, fromVal, toVal, easedVal, timeStart, frame, elapsed, qPos = guaranteedNext ? 0 : inArray(qObj, animObj.q), qObj = { props: to, duration: hasOptions ? options : duration, easing, complete };
              if (qPos === -1 && (qPos = animObj.q[LEXICON.l], animObj.q.push(qObj)), qPos === 0)
                if (duration > 0)
                  timeStart = COMPATIBILITY.now(), frame = function() {
                    timeNow = COMPATIBILITY.now(), elapsed = timeNow - timeStart, end2 = qObj.stop || elapsed >= duration, percent = 1 - (MATH.max(0, timeStart + duration - timeNow) / duration || 0);
                    for (key in to)
                      fromVal = parseFloat(from[key]), toVal = parseFloat(to[key]), easedVal = (toVal - fromVal) * EASING[specialEasing[key] || easing](percent, percent * duration, 0, 1, duration) + fromVal, setAnimationValue(el, key, easedVal), isFunction(step) && step(easedVal, { elem: el, prop: key, start: fromVal, now: easedVal, end: toVal, pos: percent, options: { easing, speacialEasing: specialEasing, duration, complete, step }, startTime: timeStart });
                    isFunction(progress) && progress({}, percent, MATH.max(0, duration - elapsed)), end2 ? (startNextAnimationInQ(animObj), isFunction(complete) && complete()) : qObj.frame = COMPATIBILITY.rAF()(frame);
                  }, qObj.frame = COMPATIBILITY.rAF()(frame);
                else {
                  for (key in to)
                    setAnimationValue(el, key, to[key]);
                  startNextAnimationInQ(animObj);
                }
            }
          }
          function stop(el, clearQ, jumpToEnd) {
            for (var animObj, qObj, key, i = 0; i < _animations[LEXICON.l]; i++)
              if (animObj = _animations[i], animObj.el === el) {
                if (animObj.q[LEXICON.l] > 0) {
                  if (qObj = animObj.q[0], qObj.stop = true, COMPATIBILITY.cAF()(qObj.frame), animObj.q.splice(0, 1), jumpToEnd)
                    for (key in qObj.props)
                      setAnimationValue(el, key, qObj.props[key]);
                  clearQ ? animObj.q = [] : startNextAnimationInQ(animObj, false);
                }
                break;
              }
          }
          function elementIsVisible(el) {
            return !!(el[LEXICON.oW] || el[LEXICON.oH] || el.getClientRects()[LEXICON.l]);
          }
          function FakejQuery(selector) {
            if (arguments[LEXICON.l] === 0)
              return this;
            var base = new FakejQuery(), elements = selector, i = 0, elms, el;
            if (_type(selector) == TYPES.s)
              for (elements = [], selector.charAt(0) === "<" ? (el = document3.createElement("div"), el.innerHTML = selector, elms = el.children) : elms = document3.querySelectorAll(selector); i < elms[LEXICON.l]; i++)
                elements.push(elms[i]);
            if (elements) {
              for (_type(elements) != TYPES.s && (!isArrayLike(elements) || elements === window2 || elements === elements.self) && (elements = [elements]), i = 0; i < elements[LEXICON.l]; i++)
                base[i] = elements[i];
              base[LEXICON.l] = elements[LEXICON.l];
            }
            return base;
          }
          return FakejQuery[LEXICON.p] = { on: function(eventName, handler) {
            eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
            var eventNameLength = eventName[LEXICON.l], i = 0, el;
            return this.each(function() {
              el = this;
              try {
                if (el.addEventListener)
                  for (; i < eventNameLength; i++)
                    el.addEventListener(eventName[i], handler);
                else if (el.detachEvent)
                  for (; i < eventNameLength; i++)
                    el.attachEvent("on" + eventName[i], handler);
              } catch {
              }
            });
          }, off: function(eventName, handler) {
            eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
            var eventNameLength = eventName[LEXICON.l], i = 0, el;
            return this.each(function() {
              el = this;
              try {
                if (el.removeEventListener)
                  for (; i < eventNameLength; i++)
                    el.removeEventListener(eventName[i], handler);
                else if (el.detachEvent)
                  for (; i < eventNameLength; i++)
                    el.detachEvent("on" + eventName[i], handler);
              } catch {
              }
            });
          }, one: function(eventName, handler) {
            return eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty], this.each(function() {
              var el = FakejQuery(this);
              FakejQuery.each(eventName, function(i, oneEventName) {
                var oneHandler = function(e) {
                  handler.call(this, e), el.off(oneEventName, oneHandler);
                };
                el.on(oneEventName, oneHandler);
              });
            });
          }, trigger: function(eventName) {
            var el, event;
            return this.each(function() {
              el = this, document3.createEvent ? (event = document3.createEvent("HTMLEvents"), event.initEvent(eventName, true, false), el.dispatchEvent(event)) : el.fireEvent("on" + eventName);
            });
          }, append: function(child) {
            return this.each(function() {
              insertAdjacentElement(this, "beforeend", child);
            });
          }, prepend: function(child) {
            return this.each(function() {
              insertAdjacentElement(this, "afterbegin", child);
            });
          }, before: function(child) {
            return this.each(function() {
              insertAdjacentElement(this, "beforebegin", child);
            });
          }, after: function(child) {
            return this.each(function() {
              insertAdjacentElement(this, "afterend", child);
            });
          }, remove: function() {
            return this.each(function() {
              var el = this, parentNode = el.parentNode;
              parentNode == null ? void 0 : parentNode.removeChild(el);
            });
          }, unwrap: function() {
            var parents = [], i, el, parent;
            for (this.each(function() {
              parent = this.parentNode, inArray(parent, parents) === -1 && parents.push(parent);
            }), i = 0; i < parents[LEXICON.l]; i++) {
              for (el = parents[i], parent = el.parentNode; el.firstChild; )
                parent.insertBefore(el.firstChild, el);
              parent.removeChild(el);
            }
            return this;
          }, wrapAll: function(wrapperHTML) {
            for (var i, nodes = this, wrapper = FakejQuery(wrapperHTML)[0], deepest = wrapper, parent = nodes[0].parentNode, previousSibling = nodes[0].previousSibling; deepest.childNodes[LEXICON.l] > 0; )
              deepest = deepest.childNodes[0];
            for (i = 0; nodes[LEXICON.l] - i; deepest.firstChild === nodes[0] && i++)
              deepest.appendChild(nodes[i]);
            var nextSibling = previousSibling ? previousSibling.nextSibling : parent.firstChild;
            return parent.insertBefore(wrapper, nextSibling), this;
          }, wrapInner: function(wrapperHTML) {
            return this.each(function() {
              var el = FakejQuery(this), contents = el.contents();
              contents[LEXICON.l] ? contents.wrapAll(wrapperHTML) : el.append(wrapperHTML);
            });
          }, wrap: function(wrapperHTML) {
            return this.each(function() {
              FakejQuery(this).wrapAll(wrapperHTML);
            });
          }, css: function(styles2, val) {
            var el, key, cptStyle, getCptStyle = window2.getComputedStyle;
            return _type(styles2) == TYPES.s ? val === undefined2 ? (el = this[0], cptStyle = getCptStyle ? getCptStyle(el, null) : el.currentStyle[styles2], getCptStyle ? cptStyle != null ? cptStyle.getPropertyValue(styles2) : el[LEXICON.s][styles2] : cptStyle) : this.each(function() {
              setCSSVal(this, styles2, val);
            }) : this.each(function() {
              for (key in styles2)
                setCSSVal(this, key, styles2[key]);
            });
          }, hasClass: function(className) {
            for (var elem, i = 0, classNamePrepared = _strSpace + className + _strSpace, classList; elem = this[i++]; ) {
              if (classList = elem.classList, classList && classList.contains(className))
                return true;
              if (elem.nodeType === 1 && (_strSpace + stripAndCollapse(elem.className + _strEmpty) + _strSpace).indexOf(classNamePrepared) > -1)
                return true;
            }
            return false;
          }, addClass: function(className) {
            var classes, elem, cur, curValue, clazz, finalValue, supportClassList, elmClassList, i = 0, v = 0;
            if (className) {
              for (classes = className.match(_rnothtmlwhite) || []; elem = this[i++]; )
                if (elmClassList = elem.classList, supportClassList === undefined2 && (supportClassList = elmClassList !== undefined2), supportClassList)
                  for (; clazz = classes[v++]; )
                    elmClassList.add(clazz);
                else if (curValue = elem.className + _strEmpty, cur = elem.nodeType === 1 && _strSpace + stripAndCollapse(curValue) + _strSpace, cur) {
                  for (; clazz = classes[v++]; )
                    cur.indexOf(_strSpace + clazz + _strSpace) < 0 && (cur += clazz + _strSpace);
                  finalValue = stripAndCollapse(cur), curValue !== finalValue && (elem.className = finalValue);
                }
            }
            return this;
          }, removeClass: function(className) {
            var classes, elem, cur, curValue, clazz, finalValue, supportClassList, elmClassList, i = 0, v = 0;
            if (className) {
              for (classes = className.match(_rnothtmlwhite) || []; elem = this[i++]; )
                if (elmClassList = elem.classList, supportClassList === undefined2 && (supportClassList = elmClassList !== undefined2), supportClassList)
                  for (; clazz = classes[v++]; )
                    elmClassList.remove(clazz);
                else if (curValue = elem.className + _strEmpty, cur = elem.nodeType === 1 && _strSpace + stripAndCollapse(curValue) + _strSpace, cur) {
                  for (; clazz = classes[v++]; )
                    for (; cur.indexOf(_strSpace + clazz + _strSpace) > -1; )
                      cur = cur.replace(_strSpace + clazz + _strSpace, _strSpace);
                  finalValue = stripAndCollapse(cur), curValue !== finalValue && (elem.className = finalValue);
                }
            }
            return this;
          }, hide: function() {
            return this.each(function() {
              this[LEXICON.s].display = "none";
            });
          }, show: function() {
            return this.each(function() {
              this[LEXICON.s].display = "block";
            });
          }, attr: function(attrName, value) {
            for (var i = 0, el; el = this[i++]; ) {
              if (value === undefined2)
                return el.getAttribute(attrName);
              el.setAttribute(attrName, value);
            }
            return this;
          }, removeAttr: function(attrName) {
            return this.each(function() {
              this.removeAttribute(attrName);
            });
          }, offset: function() {
            var el = this[0], rect = el[LEXICON.bCR](), scrollLeft = window2.pageXOffset || document3.documentElement[_strScrollLeft], scrollTop = window2.pageYOffset || document3.documentElement[_strScrollTop];
            return { top: rect.top + scrollTop, left: rect.left + scrollLeft };
          }, position: function() {
            var el = this[0];
            return { top: el.offsetTop, left: el.offsetLeft };
          }, scrollLeft: function(value) {
            for (var i = 0, el; el = this[i++]; ) {
              if (value === undefined2)
                return el[_strScrollLeft];
              el[_strScrollLeft] = value;
            }
            return this;
          }, scrollTop: function(value) {
            for (var i = 0, el; el = this[i++]; ) {
              if (value === undefined2)
                return el[_strScrollTop];
              el[_strScrollTop] = value;
            }
            return this;
          }, val: function(value) {
            var el = this[0];
            return value ? (el.value = value, this) : el.value;
          }, first: function() {
            return this.eq(0);
          }, last: function() {
            return this.eq(-1);
          }, eq: function(index3) {
            return FakejQuery(this[index3 >= 0 ? index3 : this[LEXICON.l] + index3]);
          }, find: function(selector) {
            var children = [], i;
            return this.each(function() {
              var el = this, ch = el.querySelectorAll(selector);
              for (i = 0; i < ch[LEXICON.l]; i++)
                children.push(ch[i]);
            }), FakejQuery(children);
          }, children: function(selector) {
            var children = [], el, ch, i;
            return this.each(function() {
              for (ch = this.children, i = 0; i < ch[LEXICON.l]; i++)
                el = ch[i], selector ? (el.matches && el.matches(selector) || matches(el, selector)) && children.push(el) : children.push(el);
            }), FakejQuery(children);
          }, parent: function(selector) {
            var parents = [], parent;
            return this.each(function() {
              parent = this.parentNode, (!selector || FakejQuery(parent).is(selector)) && parents.push(parent);
            }), FakejQuery(parents);
          }, is: function(selector) {
            var el, i;
            for (i = 0; i < this[LEXICON.l]; i++) {
              if (el = this[i], selector === ":visible")
                return elementIsVisible(el);
              if (selector === ":hidden")
                return !elementIsVisible(el);
              if (el.matches && el.matches(selector) || matches(el, selector))
                return true;
            }
            return false;
          }, contents: function() {
            var contents = [], childs, i;
            return this.each(function() {
              for (childs = this.childNodes, i = 0; i < childs[LEXICON.l]; i++)
                contents.push(childs[i]);
            }), FakejQuery(contents);
          }, each: function(callback) {
            return each(this, callback);
          }, animate: function(props, duration, easing, complete) {
            return this.each(function() {
              animate(this, props, duration, easing, complete);
            });
          }, stop: function(clearQ, jump) {
            return this.each(function() {
              stop(this, clearQ, jump);
            });
          } }, extend(FakejQuery, { extend, inArray, isEmptyObject, isPlainObject, each }), FakejQuery;
        }(), INSTANCES = function() {
          var _targets = [], _instancePropertyString = "__overlayScrollbars__";
          return function(target, instance) {
            var argLen = arguments[LEXICON.l];
            if (argLen < 1)
              return _targets;
            if (instance)
              target[_instancePropertyString] = instance, _targets.push(target);
            else {
              var index3 = COMPATIBILITY.inA(target, _targets);
              if (index3 > -1)
                if (argLen > 1)
                  delete target[_instancePropertyString], _targets.splice(index3, 1);
                else
                  return _targets[index3][_instancePropertyString];
            }
          };
        }(), PLUGIN = function() {
          var _plugin, _pluginsGlobals, _pluginsAutoUpdateLoop, _pluginsExtensions = [], _pluginsOptions = function() {
            var type = COMPATIBILITY.type, possibleTemplateTypes = [TYPES.b, TYPES.n, TYPES.s, TYPES.a, TYPES.o, TYPES.f, TYPES.z], restrictedStringsSplit = " ", restrictedStringsPossibilitiesSplit = ":", classNameAllowedValues = [TYPES.z, TYPES.s], numberAllowedValues = TYPES.n, booleanNullAllowedValues = [TYPES.z, TYPES.b], booleanTrueTemplate = [true, TYPES.b], booleanFalseTemplate = [false, TYPES.b], callbackTemplate = [null, [TYPES.z, TYPES.f]], updateOnLoadTemplate = [["img"], [TYPES.s, TYPES.a, TYPES.z]], inheritedAttrsTemplate = [["style", "class"], [TYPES.s, TYPES.a, TYPES.z]], resizeAllowedValues = "n:none b:both h:horizontal v:vertical", overflowBehaviorAllowedValues = "v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden", scrollbarsVisibilityAllowedValues = "v:visible h:hidden a:auto", scrollbarsAutoHideAllowedValues = "n:never s:scroll l:leave m:move", optionsDefaultsAndTemplate = { className: ["os-theme-dark", classNameAllowedValues], resize: ["none", resizeAllowedValues], sizeAutoCapable: booleanTrueTemplate, clipAlways: booleanTrueTemplate, normalizeRTL: booleanTrueTemplate, paddingAbsolute: booleanFalseTemplate, autoUpdate: [null, booleanNullAllowedValues], autoUpdateInterval: [33, numberAllowedValues], updateOnLoad: updateOnLoadTemplate, nativeScrollbarsOverlaid: { showNativeScrollbars: booleanFalseTemplate, initialize: booleanTrueTemplate }, overflowBehavior: { x: ["scroll", overflowBehaviorAllowedValues], y: ["scroll", overflowBehaviorAllowedValues] }, scrollbars: { visibility: ["auto", scrollbarsVisibilityAllowedValues], autoHide: ["never", scrollbarsAutoHideAllowedValues], autoHideDelay: [800, numberAllowedValues], dragScrolling: booleanTrueTemplate, clickScrolling: booleanFalseTemplate, touchSupport: booleanTrueTemplate, snapHandle: booleanFalseTemplate }, textarea: { dynWidth: booleanFalseTemplate, dynHeight: booleanFalseTemplate, inheritedAttrs: inheritedAttrsTemplate }, callbacks: { onInitialized: callbackTemplate, onInitializationWithdrawn: callbackTemplate, onDestroyed: callbackTemplate, onScrollStart: callbackTemplate, onScroll: callbackTemplate, onScrollStop: callbackTemplate, onOverflowChanged: callbackTemplate, onOverflowAmountChanged: callbackTemplate, onDirectionChanged: callbackTemplate, onContentSizeChanged: callbackTemplate, onHostSizeChanged: callbackTemplate, onUpdated: callbackTemplate } }, convert = function(template) {
              var recursive = function(obj) {
                var key, val, valType;
                for (key in obj)
                  !obj[LEXICON.hOP](key) || (val = obj[key], valType = type(val), valType == TYPES.a ? obj[key] = val[template ? 1 : 0] : valType == TYPES.o && (obj[key] = recursive(val)));
                return obj;
              };
              return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));
            };
            return { _defaults: convert(), _template: convert(true), _validate: function(obj, template, writeErrors, diffObj) {
              var validatedOptions = {}, validatedOptionsPrepared = {}, objectCopy = FRAMEWORK.extend(true, {}, obj), inArray = FRAMEWORK.inArray, isEmptyObj = FRAMEWORK.isEmptyObject, checkObjectProps = function(data, template2, diffData, validatedOptions2, validatedOptionsPrepared2, prevPropName) {
                for (var prop in template2)
                  if (template2[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {
                    var isValid = false, isDiff = false, templateValue = template2[prop], templateValueType = type(templateValue), templateIsComplex = templateValueType == TYPES.o, templateTypes = COMPATIBILITY.isA(templateValue) ? templateValue : [templateValue], dataDiffValue = diffData[prop], dataValue = data[prop], dataValueType = type(dataValue), propPrefix = prevPropName ? prevPropName + "." : "", error = 'The option "' + propPrefix + prop + `" wasn't set, because`, errorPossibleTypes = [], errorRestrictedStrings = [], restrictedStringValuesSplit, restrictedStringValuesPossibilitiesSplit, isRestrictedValue, mainPossibility, currType, i, v, j;
                    if (dataDiffValue = dataDiffValue === undefined2 ? {} : dataDiffValue, templateIsComplex && dataValueType == TYPES.o)
                      validatedOptions2[prop] = {}, validatedOptionsPrepared2[prop] = {}, checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions2[prop], validatedOptionsPrepared2[prop], propPrefix + prop), FRAMEWORK.each([data, validatedOptions2, validatedOptionsPrepared2], function(index3, value) {
                        isEmptyObj(value[prop]) && delete value[prop];
                      });
                    else if (!templateIsComplex) {
                      for (i = 0; i < templateTypes[LEXICON.l]; i++)
                        if (currType = templateTypes[i], templateValueType = type(currType), isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1, isRestrictedValue)
                          for (errorPossibleTypes.push(TYPES.s), restrictedStringValuesSplit = currType.split(restrictedStringsSplit), errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit), v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {
                            for (restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit), mainPossibility = restrictedStringValuesPossibilitiesSplit[0], j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++)
                              if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {
                                isValid = true;
                                break;
                              }
                            if (isValid)
                              break;
                          }
                        else if (errorPossibleTypes.push(currType), dataValueType === currType) {
                          isValid = true;
                          break;
                        }
                      isValid ? (isDiff = dataValue !== dataDiffValue, isDiff && (validatedOptions2[prop] = dataValue), (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff) && (validatedOptionsPrepared2[prop] = isRestrictedValue ? mainPossibility : dataValue)) : writeErrors && console.warn(error + " it doesn't accept the type [ " + dataValueType.toUpperCase() + ' ] with the value of "' + dataValue + `".\r
Accepted types are: [ ` + errorPossibleTypes.join(", ").toUpperCase() + " ]." + (errorRestrictedStrings[length] > 0 ? `\r
Valid strings are: [ ` + errorRestrictedStrings.join(", ").split(restrictedStringsPossibilitiesSplit).join(", ") + " ]." : "")), delete data[prop];
                    }
                  }
              };
              return checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared), !isEmptyObj(objectCopy) && writeErrors && console.warn(`The following options are discarded due to invalidity:\r
` + window2.JSON.stringify(objectCopy, null, 2)), { _default: validatedOptions, _prepared: validatedOptionsPrepared };
            } };
          }();
          function initOverlayScrollbarsStatics() {
            _pluginsGlobals || (_pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults)), _pluginsAutoUpdateLoop || (_pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals));
          }
          function OverlayScrollbarsGlobals(defaultOptions) {
            var _base = this, strOverflow = "overflow", strHidden = "hidden", strScroll = "scroll", bodyElement = FRAMEWORK("body"), scrollbarDummyElement = FRAMEWORK('<div id="os-dummy-scrollbar-size"><div></div></div>'), scrollbarDummyElement0 = scrollbarDummyElement[0], dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children("div").eq(0));
            bodyElement.append(scrollbarDummyElement), scrollbarDummyElement.hide().show();
            var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0), nativeScrollbarIsOverlaid = { x: nativeScrollbarSize.x === 0, y: nativeScrollbarSize.y === 0 }, msie = function() {
              var ua = window2.navigator.userAgent, strIndexOf = "indexOf", strSubString = "substring", msie2 = ua[strIndexOf]("MSIE "), trident = ua[strIndexOf]("Trident/"), edge = ua[strIndexOf]("Edge/"), rv = ua[strIndexOf]("rv:"), result, parseIntFunc = parseInt;
              return msie2 > 0 ? result = parseIntFunc(ua[strSubString](msie2 + 5, ua[strIndexOf](".", msie2)), 10) : trident > 0 ? result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf](".", rv)), 10) : edge > 0 && (result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf](".", edge)), 10)), result;
            }();
            FRAMEWORK.extend(_base, { defaultOptions, msie, autoUpdateLoop: false, autoUpdateRecommended: !COMPATIBILITY.mO(), nativeScrollbarSize, nativeScrollbarIsOverlaid, nativeScrollbarStyling: function() {
              var result = false;
              scrollbarDummyElement.addClass("os-viewport-native-scrollbars-invisible");
              try {
                result = scrollbarDummyElement.css("scrollbar-width") === "none" && (msie > 9 || !msie) || window2.getComputedStyle(scrollbarDummyElement0, "::-webkit-scrollbar").getPropertyValue("display") === "none";
              } catch {
              }
              return result;
            }(), overlayScrollbarDummySize: { x: 30, y: 30 }, cssCalc: VENDORS._cssPropertyValue("width", "calc", "(1px)") || null, restrictedMeasuring: function() {
              scrollbarDummyElement.css(strOverflow, strHidden);
              var scrollSize = { w: scrollbarDummyElement0[LEXICON.sW], h: scrollbarDummyElement0[LEXICON.sH] };
              scrollbarDummyElement.css(strOverflow, "visible");
              var scrollSize2 = { w: scrollbarDummyElement0[LEXICON.sW], h: scrollbarDummyElement0[LEXICON.sH] };
              return scrollSize.w - scrollSize2.w !== 0 || scrollSize.h - scrollSize2.h !== 0;
            }(), rtlScrollBehavior: function() {
              scrollbarDummyElement.css({ "overflow-y": strHidden, "overflow-x": strScroll, direction: "rtl" }).scrollLeft(0);
              var dummyContainerOffset = scrollbarDummyElement.offset(), dummyContainerChildOffset = dummyContainerChild.offset();
              scrollbarDummyElement.scrollLeft(-999);
              var dummyContainerChildOffsetAfterScroll = dummyContainerChild.offset();
              return { i: dummyContainerOffset.left === dummyContainerChildOffset.left, n: dummyContainerChildOffset.left !== dummyContainerChildOffsetAfterScroll.left };
            }(), supportTransform: !!VENDORS._cssProperty("transform"), supportTransition: !!VENDORS._cssProperty("transition"), supportPassiveEvents: function() {
              var supportsPassive = false;
              try {
                window2.addEventListener("test", null, Object.defineProperty({}, "passive", { get: function() {
                  supportsPassive = true;
                } }));
              } catch {
              }
              return supportsPassive;
            }(), supportResizeObserver: !!COMPATIBILITY.rO(), supportMutationObserver: !!COMPATIBILITY.mO() }), scrollbarDummyElement.removeAttr(LEXICON.s).remove(), function() {
              if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y)
                return;
              var abs = MATH.abs, windowWidth = COMPATIBILITY.wW(), windowHeight = COMPATIBILITY.wH(), windowDpr = getWindowDPR(), onResize = function() {
                if (INSTANCES().length > 0) {
                  var newW = COMPATIBILITY.wW(), newH = COMPATIBILITY.wH(), deltaW = newW - windowWidth, deltaH = newH - windowHeight;
                  if (deltaW === 0 && deltaH === 0)
                    return;
                  var deltaWRatio = MATH.round(newW / (windowWidth / 100)), deltaHRatio = MATH.round(newH / (windowHeight / 100)), absDeltaW = abs(deltaW), absDeltaH = abs(deltaH), absDeltaWRatio = abs(deltaWRatio), absDeltaHRatio = abs(deltaHRatio), newDPR = getWindowDPR(), deltaIsBigger = absDeltaW > 2 && absDeltaH > 2, difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio), dprChanged = newDPR !== windowDpr && windowDpr > 0, isZoom = deltaIsBigger && difference && dprChanged, oldScrollbarSize = _base.nativeScrollbarSize, newScrollbarSize;
                  isZoom && (bodyElement.append(scrollbarDummyElement), newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]), scrollbarDummyElement.remove(), (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) && FRAMEWORK.each(INSTANCES(), function() {
                    INSTANCES(this) && INSTANCES(this).update("zoom");
                  })), windowWidth = newW, windowHeight = newH, windowDpr = newDPR;
                }
              };
              function differenceIsBiggerThanOne(valOne, valTwo) {
                var absValOne = abs(valOne), absValTwo = abs(valTwo);
                return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);
              }
              function getWindowDPR() {
                var dDPI = window2.screen.deviceXDPI || 0, sDPI = window2.screen.logicalXDPI || 1;
                return window2.devicePixelRatio || dDPI / sDPI;
              }
              FRAMEWORK(window2).on("resize", onResize);
            }();
            function calcNativeScrollbarSize(measureElement) {
              return { x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH], y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW] };
            }
          }
          function OverlayScrollbarsAutoUpdateLoop(globals) {
            var _base = this, _inArray = FRAMEWORK.inArray, _getNow = COMPATIBILITY.now, _strAutoUpdate = "autoUpdate", _strAutoUpdateInterval = _strAutoUpdate + "Interval", _strLength = LEXICON.l, _loopingInstances = [], _loopingInstancesIntervalCache = [], _loopIsActive = false, _loopIntervalDefault = 33, _loopInterval = _loopIntervalDefault, _loopTimeOld = _getNow(), _loopID, loop = function() {
              if (_loopingInstances[_strLength] > 0 && _loopIsActive) {
                _loopID = COMPATIBILITY.rAF()(function() {
                  loop();
                });
                var timeNew = _getNow(), timeDelta = timeNew - _loopTimeOld, lowestInterval, instance, instanceOptions, instanceAutoUpdateAllowed, instanceAutoUpdateInterval, now;
                if (timeDelta > _loopInterval) {
                  _loopTimeOld = timeNew - timeDelta % _loopInterval, lowestInterval = _loopIntervalDefault;
                  for (var i = 0; i < _loopingInstances[_strLength]; i++)
                    instance = _loopingInstances[i], instance !== undefined2 && (instanceOptions = instance.options(), instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate], instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]), now = _getNow(), (instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) && now - _loopingInstancesIntervalCache[i] > instanceAutoUpdateInterval && (instance.update("auto"), _loopingInstancesIntervalCache[i] = new Date(now += instanceAutoUpdateInterval)), lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval)));
                  _loopInterval = lowestInterval;
                }
              } else
                _loopInterval = _loopIntervalDefault;
            };
            _base.add = function(instance) {
              _inArray(instance, _loopingInstances) === -1 && (_loopingInstances.push(instance), _loopingInstancesIntervalCache.push(_getNow()), _loopingInstances[_strLength] > 0 && !_loopIsActive && (_loopIsActive = true, globals.autoUpdateLoop = _loopIsActive, loop()));
            }, _base.remove = function(instance) {
              var index3 = _inArray(instance, _loopingInstances);
              index3 > -1 && (_loopingInstancesIntervalCache.splice(index3, 1), _loopingInstances.splice(index3, 1), _loopingInstances[_strLength] === 0 && _loopIsActive && (_loopIsActive = false, globals.autoUpdateLoop = _loopIsActive, _loopID !== undefined2 && (COMPATIBILITY.cAF()(_loopID), _loopID = -1)));
            };
          }
          function OverlayScrollbarsInstance(pluginTargetElement, options, extensions, globals, autoUpdateLoop) {
            var type = COMPATIBILITY.type, inArray = FRAMEWORK.inArray, each = FRAMEWORK.each, _base = new _plugin(), _frameworkProto = FRAMEWORK[LEXICON.p];
            if (!isHTMLElement2(pluginTargetElement))
              return;
            if (INSTANCES(pluginTargetElement)) {
              var inst = INSTANCES(pluginTargetElement);
              return inst.options(options), inst;
            }
            var _nativeScrollbarIsOverlaid, _overlayScrollbarDummySize, _rtlScrollBehavior, _autoUpdateRecommended, _msieVersion, _nativeScrollbarStyling, _cssCalc, _nativeScrollbarSize, _supportTransition, _supportTransform, _supportPassiveEvents, _supportResizeObserver, _supportMutationObserver, _restrictedMeasuring, _initialized, _destroyed, _isTextarea, _isBody, _documentMixed, _domExists, _isBorderBox, _sizeAutoObserverAdded, _paddingX, _paddingY, _borderX, _borderY, _marginX, _marginY, _isRTL, _sleeping, _contentBorderSize = {}, _scrollHorizontalInfo = {}, _scrollVerticalInfo = {}, _viewportSize = {}, _nativeScrollbarMinSize = {}, _strMinusHidden = "-hidden", _strMarginMinus = "margin-", _strPaddingMinus = "padding-", _strBorderMinus = "border-", _strTop = "top", _strRight = "right", _strBottom = "bottom", _strLeft = "left", _strMinMinus = "min-", _strMaxMinus = "max-", _strWidth = "width", _strHeight = "height", _strFloat = "float", _strEmpty = "", _strAuto = "auto", _strSync = "sync", _strScroll = "scroll", _strHundredPercent = "100%", _strX = "x", _strY = "y", _strDot = ".", _strSpace = " ", _strScrollbar = "scrollbar", _strMinusHorizontal = "-horizontal", _strMinusVertical = "-vertical", _strScrollLeft = _strScroll + "Left", _strScrollTop = _strScroll + "Top", _strMouseTouchDownEvent = "mousedown touchstart", _strMouseTouchUpEvent = "mouseup touchend touchcancel", _strMouseTouchMoveEvent = "mousemove touchmove", _strMouseEnter = "mouseenter", _strMouseLeave = "mouseleave", _strKeyDownEvent = "keydown", _strKeyUpEvent = "keyup", _strSelectStartEvent = "selectstart", _strTransitionEndEvent = "transitionend webkitTransitionEnd oTransitionEnd", _strResizeObserverProperty = "__overlayScrollbarsRO__", _cassNamesPrefix = "os-", _classNameHTMLElement = _cassNamesPrefix + "html", _classNameHostElement = _cassNamesPrefix + "host", _classNameHostElementForeign = _classNameHostElement + "-foreign", _classNameHostTextareaElement = _classNameHostElement + "-textarea", _classNameHostScrollbarHorizontalHidden = _classNameHostElement + "-" + _strScrollbar + _strMinusHorizontal + _strMinusHidden, _classNameHostScrollbarVerticalHidden = _classNameHostElement + "-" + _strScrollbar + _strMinusVertical + _strMinusHidden, _classNameHostTransition = _classNameHostElement + "-transition", _classNameHostRTL = _classNameHostElement + "-rtl", _classNameHostResizeDisabled = _classNameHostElement + "-resize-disabled", _classNameHostScrolling = _classNameHostElement + "-scrolling", _classNameHostOverflow = _classNameHostElement + "-overflow", _classNameHostOverflow = _classNameHostElement + "-overflow", _classNameHostOverflowX = _classNameHostOverflow + "-x", _classNameHostOverflowY = _classNameHostOverflow + "-y", _classNameTextareaElement = _cassNamesPrefix + "textarea", _classNameTextareaCoverElement = _classNameTextareaElement + "-cover", _classNamePaddingElement = _cassNamesPrefix + "padding", _classNameViewportElement = _cassNamesPrefix + "viewport", _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + "-native-scrollbars-invisible", _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + "-native-scrollbars-overlaid", _classNameContentElement = _cassNamesPrefix + "content", _classNameContentArrangeElement = _cassNamesPrefix + "content-arrange", _classNameContentGlueElement = _cassNamesPrefix + "content-glue", _classNameSizeAutoObserverElement = _cassNamesPrefix + "size-auto-observer", _classNameResizeObserverElement = _cassNamesPrefix + "resize-observer", _classNameResizeObserverItemElement = _cassNamesPrefix + "resize-observer-item", _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + "-final", _classNameTextInherit = _cassNamesPrefix + "text-inherit", _classNameScrollbar = _cassNamesPrefix + _strScrollbar, _classNameScrollbarTrack = _classNameScrollbar + "-track", _classNameScrollbarTrackOff = _classNameScrollbarTrack + "-off", _classNameScrollbarHandle = _classNameScrollbar + "-handle", _classNameScrollbarHandleOff = _classNameScrollbarHandle + "-off", _classNameScrollbarUnusable = _classNameScrollbar + "-unusable", _classNameScrollbarAutoHidden = _classNameScrollbar + "-" + _strAuto + _strMinusHidden, _classNameScrollbarCorner = _classNameScrollbar + "-corner", _classNameScrollbarCornerResize = _classNameScrollbarCorner + "-resize", _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + "-both", _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal, _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical, _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal, _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical, _classNameDragging = _cassNamesPrefix + "dragging", _classNameThemeNone = _cassNamesPrefix + "theme-none", _classNamesDynamicDestroy = [_classNameViewportNativeScrollbarsInvisible, _classNameViewportNativeScrollbarsOverlaid, _classNameScrollbarTrackOff, _classNameScrollbarHandleOff, _classNameScrollbarUnusable, _classNameScrollbarAutoHidden, _classNameScrollbarCornerResize, _classNameScrollbarCornerResizeB, _classNameScrollbarCornerResizeH, _classNameScrollbarCornerResizeV, _classNameDragging].join(_strSpace), _callbacksInitQeueue = [], _viewportAttrsFromTarget = [LEXICON.ti], _defaultOptions, _currentOptions, _currentPreparedOptions, _extensions = {}, _extensionsPrivateMethods = "added removed on contract", _lastUpdateTime, _swallowedUpdateHints = {}, _swallowedUpdateTimeout, _swallowUpdateLag = 42, _updateOnLoadEventName = "load", _updateOnLoadElms = [], _windowElement, _documentElement, _htmlElement, _bodyElement, _targetElement, _hostElement, _sizeAutoObserverElement, _sizeObserverElement, _paddingElement, _viewportElement, _contentElement, _contentArrangeElement, _contentGlueElement, _textareaCoverElement, _scrollbarCornerElement, _scrollbarHorizontalElement, _scrollbarHorizontalTrackElement, _scrollbarHorizontalHandleElement, _scrollbarVerticalElement, _scrollbarVerticalTrackElement, _scrollbarVerticalHandleElement, _windowElementNative, _documentElementNative, _targetElementNative, _hostElementNative, _sizeAutoObserverElementNative, _sizeObserverElementNative, _paddingElementNative, _viewportElementNative, _contentElementNative, _hostSizeCache, _contentScrollSizeCache, _arrangeContentSizeCache, _hasOverflowCache, _hideOverflowCache, _widthAutoCache, _heightAutoCache, _cssBoxSizingCache, _cssPaddingCache, _cssBorderCache, _cssMarginCache, _cssDirectionCache, _cssDirectionDetectedCache, _paddingAbsoluteCache, _clipAlwaysCache, _contentGlueSizeCache, _overflowBehaviorCache, _overflowAmountCache, _ignoreOverlayScrollbarHidingCache, _autoUpdateCache, _sizeAutoCapableCache, _contentElementScrollSizeChangeDetectedCache, _hostElementSizeChangeDetectedCache, _scrollbarsVisibilityCache, _scrollbarsAutoHideCache, _scrollbarsClickScrollingCache, _scrollbarsDragScrollingCache, _resizeCache, _normalizeRTLCache, _classNameCache, _oldClassName, _textareaAutoWrappingCache, _textareaInfoCache, _textareaSizeCache, _textareaDynHeightCache, _textareaDynWidthCache, _bodyMinSizeCache, _updateAutoCache = {}, _mutationObserverHost, _mutationObserverContent, _mutationObserverHostCallback, _mutationObserverContentCallback, _mutationObserversConnected, _mutationObserverAttrsTextarea = ["wrap", "cols", "rows"], _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, "open"].concat(_viewportAttrsFromTarget), _destroyEvents = [], _textareaHasFocus, _scrollbarsAutoHideTimeoutId, _scrollbarsAutoHideMoveTimeoutId, _scrollbarsAutoHideDelay, _scrollbarsAutoHideNever, _scrollbarsAutoHideScroll, _scrollbarsAutoHideMove, _scrollbarsAutoHideLeave, _scrollbarsHandleHovered, _scrollbarsHandlesDefineScrollPos, _resizeNone, _resizeBoth, _resizeHorizontal, _resizeVertical;
            function setupResponsiveEventListener(element, eventNames, listener, remove2, passiveOrOptions) {
              var collected = COMPATIBILITY.isA(eventNames) && COMPATIBILITY.isA(listener), method = remove2 ? "removeEventListener" : "addEventListener", onOff = remove2 ? "off" : "on", events = collected ? false : eventNames.split(_strSpace), i = 0, passiveOrOptionsIsObj = FRAMEWORK.isPlainObject(passiveOrOptions), passive2 = _supportPassiveEvents && (passiveOrOptionsIsObj ? passiveOrOptions._passive : passiveOrOptions) || false, capture = passiveOrOptionsIsObj && (passiveOrOptions._capture || false), nativeParam = _supportPassiveEvents ? { passive: passive2, capture } : capture;
              if (collected)
                for (; i < eventNames[LEXICON.l]; i++)
                  setupResponsiveEventListener(element, eventNames[i], listener[i], remove2, passiveOrOptions);
              else
                for (; i < events[LEXICON.l]; i++)
                  _supportPassiveEvents ? element[0][method](events[i], listener, nativeParam) : element[onOff](events[i], listener);
            }
            function addDestroyEventListener(element, eventNames, listener, passive2) {
              setupResponsiveEventListener(element, eventNames, listener, false, passive2), _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive2));
            }
            function setupResizeObserver(targetElement, onElementResizedCallback) {
              if (targetElement) {
                var resizeObserver = COMPATIBILITY.rO(), strAnimationStartEvent = "animationstart mozAnimationStart webkitAnimationStart MSAnimationStart", strChildNodes = "childNodes", constScroll = 3333333, callback = function() {
                  targetElement[_strScrollTop](constScroll)[_strScrollLeft](_isRTL ? _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll : constScroll), onElementResizedCallback();
                };
                if (onElementResizedCallback) {
                  if (_supportResizeObserver) {
                    var element = targetElement.addClass("observed").append(generateDiv(_classNameResizeObserverElement)).contents()[0], observer = element[_strResizeObserverProperty] = new resizeObserver(callback);
                    observer.observe(element);
                  } else if (_msieVersion > 9 || !_autoUpdateRecommended) {
                    targetElement.prepend(generateDiv(_classNameResizeObserverElement, generateDiv({ c: _classNameResizeObserverItemElement, dir: "ltr" }, generateDiv(_classNameResizeObserverItemElement, generateDiv(_classNameResizeObserverItemFinalElement)) + generateDiv(_classNameResizeObserverItemElement, generateDiv({ c: _classNameResizeObserverItemFinalElement, style: "width: 200%; height: 200%" })))));
                    var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0], shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]), expandElement = FRAMEWORK(observerElement[strChildNodes][0]), expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]), widthCache = observerElement[LEXICON.oW], heightCache = observerElement[LEXICON.oH], isDirty, rAFId, currWidth, currHeight, factor = 2, nativeScrollbarSize = globals.nativeScrollbarSize, reset = function() {
                      expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll), shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                    }, onResized = function() {
                      rAFId = 0, isDirty && (widthCache = currWidth, heightCache = currHeight, callback());
                    }, onScroll = function(event) {
                      return currWidth = observerElement[LEXICON.oW], currHeight = observerElement[LEXICON.oH], isDirty = currWidth != widthCache || currHeight != heightCache, event && isDirty && !rAFId ? (COMPATIBILITY.cAF()(rAFId), rAFId = COMPATIBILITY.rAF()(onResized)) : event || onResized(), reset(), event && (COMPATIBILITY.prvD(event), COMPATIBILITY.stpP(event)), false;
                    }, expandChildCSS = {}, observerElementCSS = {};
                    setTopRightBottomLeft(observerElementCSS, _strEmpty, [-((nativeScrollbarSize.y + 1) * factor), nativeScrollbarSize.x * -factor, nativeScrollbarSize.y * -factor, -((nativeScrollbarSize.x + 1) * factor)]), FRAMEWORK(observerElement).css(observerElementCSS), expandElement.on(_strScroll, onScroll), shrinkElement.on(_strScroll, onScroll), targetElement.on(strAnimationStartEvent, function() {
                      onScroll(false);
                    }), expandChildCSS[_strWidth] = constScroll, expandChildCSS[_strHeight] = constScroll, expandElementChild.css(expandChildCSS), reset();
                  } else {
                    var attachEvent = _documentElementNative.attachEvent, isIE2 = _msieVersion !== undefined2;
                    if (attachEvent)
                      targetElement.prepend(generateDiv(_classNameResizeObserverElement)), findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent("onresize", callback);
                    else {
                      var obj = _documentElementNative.createElement(TYPES.o);
                      obj.setAttribute(LEXICON.ti, "-1"), obj.setAttribute(LEXICON.c, _classNameResizeObserverElement), obj.onload = function() {
                        var wnd = this.contentDocument.defaultView;
                        wnd.addEventListener("resize", callback), wnd.document.documentElement.style.display = "none";
                      }, obj.type = "text/html", isIE2 && targetElement.prepend(obj), obj.data = "about:blank", isIE2 || targetElement.prepend(obj), targetElement.on(strAnimationStartEvent, callback);
                    }
                  }
                  if (targetElement[0] === _sizeObserverElementNative) {
                    var directionChanged = function() {
                      var dir = _hostElement.css("direction"), css = {}, scrollLeftValue = 0, result = false;
                      return dir !== _cssDirectionDetectedCache && (dir === "ltr" ? (css[_strLeft] = 0, css[_strRight] = _strAuto, scrollLeftValue = constScroll) : (css[_strLeft] = _strAuto, css[_strRight] = 0, scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll), _sizeObserverElement.children().eq(0).css(css), _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll), _cssDirectionDetectedCache = dir, result = true), result;
                    };
                    directionChanged(), addDestroyEventListener(targetElement, _strScroll, function(event) {
                      return directionChanged() && update(), COMPATIBILITY.prvD(event), COMPATIBILITY.stpP(event), false;
                    });
                  }
                } else if (_supportResizeObserver) {
                  var element = targetElement.contents()[0], resizeObserverObj = element[_strResizeObserverProperty];
                  resizeObserverObj && (resizeObserverObj.disconnect(), delete element[_strResizeObserverProperty]);
                } else
                  remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));
              }
            }
            function createMutationObservers() {
              if (_supportMutationObserver) {
                var mutationObserverContentLag = 11, mutationObserver = COMPATIBILITY.mO(), contentLastUpdate = COMPATIBILITY.now(), mutationTarget, mutationAttrName, mutationIsClass, oldMutationVal, newClassVal, hostClassNameRegex, contentTimeout, now, sizeAuto, action;
                _mutationObserverHostCallback = function(mutations) {
                  var doUpdate = false, doUpdateForce = false, mutation, mutatedAttrs = [];
                  return _initialized && !_sleeping && (each(mutations, function() {
                    mutation = this, mutationTarget = mutation.target, mutationAttrName = mutation.attributeName, mutationIsClass = mutationAttrName === LEXICON.c, oldMutationVal = mutation.oldValue, newClassVal = mutationTarget.className, _domExists && mutationIsClass && !doUpdateForce && oldMutationVal.indexOf(_classNameHostElementForeign) > -1 && newClassVal.indexOf(_classNameHostElementForeign) < 0 && (hostClassNameRegex = createHostClassNameRegExp(true), _hostElementNative.className = newClassVal.split(_strSpace).concat(oldMutationVal.split(_strSpace).filter(function(name) {
                      return name.match(hostClassNameRegex);
                    })).join(_strSpace), doUpdate = doUpdateForce = true), doUpdate || (doUpdate = mutationIsClass ? hostClassNamesChanged(oldMutationVal, newClassVal) : mutationAttrName === LEXICON.s ? oldMutationVal !== mutationTarget[LEXICON.s].cssText : true), mutatedAttrs.push(mutationAttrName);
                  }), updateViewportAttrsFromTarget(mutatedAttrs), doUpdate && _base.update(doUpdateForce || _strAuto)), doUpdate;
                }, _mutationObserverContentCallback = function(mutations) {
                  var doUpdate = false, mutation;
                  return _initialized && !_sleeping && (each(mutations, function() {
                    return mutation = this, doUpdate = isUnknownMutation(mutation), !doUpdate;
                  }), doUpdate && (now = COMPATIBILITY.now(), sizeAuto = _heightAutoCache || _widthAutoCache, action = function() {
                    _destroyed || (contentLastUpdate = now, _isTextarea && textareaUpdate(), sizeAuto ? update() : _base.update(_strAuto));
                  }, clearTimeout(contentTimeout), mutationObserverContentLag <= 0 || now - contentLastUpdate > mutationObserverContentLag || !sizeAuto ? action() : contentTimeout = setTimeout(action, mutationObserverContentLag))), doUpdate;
                }, _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback), _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);
              }
            }
            function connectMutationObservers() {
              _supportMutationObserver && !_mutationObserversConnected && (_mutationObserverHost.observe(_hostElementNative, { attributes: true, attributeOldValue: true, attributeFilter: _mutationObserverAttrsHost }), _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, { attributes: true, attributeOldValue: true, subtree: !_isTextarea, childList: !_isTextarea, characterData: !_isTextarea, attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost }), _mutationObserversConnected = true);
            }
            function disconnectMutationObservers() {
              _supportMutationObserver && _mutationObserversConnected && (_mutationObserverHost.disconnect(), _mutationObserverContent.disconnect(), _mutationObserversConnected = false);
            }
            function hostOnResized() {
              if (!_sleeping) {
                var changed, hostSize = { w: _sizeObserverElementNative[LEXICON.sW], h: _sizeObserverElementNative[LEXICON.sH] };
                changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache), _hostElementSizeChangeDetectedCache = hostSize, changed && update({ _hostSizeChanged: true });
              }
            }
            function hostOnMouseEnter() {
              _scrollbarsAutoHideLeave && refreshScrollbarsAutoHide(true);
            }
            function hostOnMouseLeave() {
              _scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging) && refreshScrollbarsAutoHide(false);
            }
            function hostOnMouseMove() {
              _scrollbarsAutoHideMove && (refreshScrollbarsAutoHide(true), clearTimeout(_scrollbarsAutoHideMoveTimeoutId), _scrollbarsAutoHideMoveTimeoutId = setTimeout(function() {
                _scrollbarsAutoHideMove && !_destroyed && refreshScrollbarsAutoHide(false);
              }, 100));
            }
            function documentOnSelectStart(event) {
              return COMPATIBILITY.prvD(event), false;
            }
            function updateOnLoadCallback(event) {
              if (!_destroyed) {
                var target = event.target, elm = FRAMEWORK(event.target), index3 = FRAMEWORK.inArray(target, _updateOnLoadElms);
                index3 > -1 && _updateOnLoadElms.splice(index3, 1), eachUpdateOnLoad(function(i, updateOnLoadSelector) {
                  elm.is(updateOnLoadSelector) && update({ _contentSizeChanged: true });
                });
              }
            }
            function setupHostMouseTouchEvents(destroy) {
              destroy || setupHostMouseTouchEvents(true), setupResponsiveEventListener(_hostElement, _strMouseTouchMoveEvent.split(_strSpace)[0], hostOnMouseMove, !_scrollbarsAutoHideMove || destroy, true), setupResponsiveEventListener(_hostElement, [_strMouseEnter, _strMouseLeave], [hostOnMouseEnter, hostOnMouseLeave], !_scrollbarsAutoHideLeave || destroy, true), !_initialized && !destroy && _hostElement.one("mouseover", hostOnMouseEnter);
            }
            function bodyMinSizeChanged() {
              var bodyMinSize = {};
              return _isBody && _contentArrangeElement && (bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth)), bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight)), bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache), bodyMinSize.f = true), _bodyMinSizeCache = bodyMinSize, !!bodyMinSize.c;
            }
            function hostClassNamesChanged(oldClassNames, newClassNames) {
              var currClasses = typeof newClassNames == TYPES.s ? newClassNames.split(_strSpace) : [], oldClasses = typeof oldClassNames == TYPES.s ? oldClassNames.split(_strSpace) : [], diff = getArrayDifferences(oldClasses, currClasses), idx = inArray(_classNameThemeNone, diff), i, regex;
              if (idx > -1 && diff.splice(idx, 1), diff[LEXICON.l] > 0) {
                for (regex = createHostClassNameRegExp(true, true), i = 0; i < diff.length; i++)
                  if (!diff[i].match(regex))
                    return true;
              }
              return false;
            }
            function isUnknownMutation(mutation) {
              var attributeName = mutation.attributeName, mutationTarget = mutation.target, mutationType = mutation.type, strClosest = "closest";
              if (mutationTarget === _contentElementNative)
                return attributeName === null;
              if (mutationType === "attributes" && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {
                if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement))
                  return hostClassNamesChanged(mutation.oldValue, mutationTarget.className);
                if (typeof mutationTarget[strClosest] != TYPES.f)
                  return true;
                if (mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null || mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null || mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null)
                  return false;
              }
              return true;
            }
            function updateAutoContentSizeChanged() {
              if (_sleeping)
                return false;
              var contentMeasureElement = getContentMeasureElement(), textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0, setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea, css = {}, float, bodyMinSizeC, changed, contentElementScrollSize;
              return setCSS && (float = _contentElement.css(_strFloat), css[_strFloat] = _isRTL ? _strRight : _strLeft, css[_strWidth] = _strAuto, _contentElement.css(css)), contentElementScrollSize = { w: contentMeasureElement[LEXICON.sW] + textareaValueLength, h: contentMeasureElement[LEXICON.sH] + textareaValueLength }, setCSS && (css[_strFloat] = float, css[_strWidth] = _strHundredPercent, _contentElement.css(css)), bodyMinSizeC = bodyMinSizeChanged(), changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache), _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize, changed || bodyMinSizeC;
            }
            function meaningfulAttrsChanged() {
              if (!(_sleeping || _mutationObserversConnected)) {
                var elem, curr, cache, changedAttrs = [], checks = [{ _elem: _hostElement, _attrs: _mutationObserverAttrsHost.concat(":visible") }, { _elem: _isTextarea ? _targetElement : undefined2, _attrs: _mutationObserverAttrsTextarea }];
                return each(checks, function(index3, check) {
                  elem = check._elem, elem && each(check._attrs, function(index22, attr) {
                    curr = attr.charAt(0) === ":" ? elem.is(attr) : elem.attr(attr), cache = _updateAutoCache[attr], checkCache(curr, cache) && changedAttrs.push(attr), _updateAutoCache[attr] = curr;
                  });
                }), updateViewportAttrsFromTarget(changedAttrs), changedAttrs[LEXICON.l] > 0;
              }
            }
            function isSizeAffectingCSSProperty(propertyName) {
              if (!_initialized)
                return true;
              var flexGrow = "flex-grow", flexShrink = "flex-shrink", flexBasis = "flex-basis", affectingPropsX = [_strWidth, _strMinMinus + _strWidth, _strMaxMinus + _strWidth, _strMarginMinus + _strLeft, _strMarginMinus + _strRight, _strLeft, _strRight, "font-weight", "word-spacing", flexGrow, flexShrink, flexBasis], affectingPropsXContentBox = [_strPaddingMinus + _strLeft, _strPaddingMinus + _strRight, _strBorderMinus + _strLeft + _strWidth, _strBorderMinus + _strRight + _strWidth], affectingPropsY = [_strHeight, _strMinMinus + _strHeight, _strMaxMinus + _strHeight, _strMarginMinus + _strTop, _strMarginMinus + _strBottom, _strTop, _strBottom, "line-height", flexGrow, flexShrink, flexBasis], affectingPropsYContentBox = [_strPaddingMinus + _strTop, _strPaddingMinus + _strBottom, _strBorderMinus + _strTop + _strWidth, _strBorderMinus + _strBottom + _strWidth], _strS = "s", _strVS = "v-s", checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS, checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS, sizeIsAffected = false, checkPropertyName = function(arr, name) {
                for (var i = 0; i < arr[LEXICON.l]; i++)
                  if (arr[i] === name)
                    return true;
                return false;
              };
              return checkY && (sizeIsAffected = checkPropertyName(affectingPropsY, propertyName), !sizeIsAffected && !_isBorderBox && (sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName))), checkX && !sizeIsAffected && (sizeIsAffected = checkPropertyName(affectingPropsX, propertyName), !sizeIsAffected && !_isBorderBox && (sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName))), sizeIsAffected;
            }
            function updateViewportAttrsFromTarget(attrs) {
              attrs = attrs || _viewportAttrsFromTarget, each(attrs, function(index3, attr) {
                if (COMPATIBILITY.inA(attr, _viewportAttrsFromTarget) > -1) {
                  var targetAttr = _targetElement.attr(attr);
                  type(targetAttr) == TYPES.s ? _viewportElement.attr(attr, targetAttr) : _viewportElement.removeAttr(attr);
                }
              });
            }
            function textareaUpdate() {
              if (!_sleeping) {
                var wrapAttrOff = !_textareaAutoWrappingCache, minWidth = _viewportSize.w, minHeight = _viewportSize.h, css = {}, doMeasure = _widthAutoCache || wrapAttrOff, origWidth, width, origHeight, height;
                return css[_strMinMinus + _strWidth] = _strEmpty, css[_strMinMinus + _strHeight] = _strEmpty, css[_strWidth] = _strAuto, _targetElement.css(css), origWidth = _targetElementNative[LEXICON.oW], width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1, css[_strWidth] = _widthAutoCache ? _strAuto : _strHundredPercent, css[_strMinMinus + _strWidth] = _strHundredPercent, css[_strHeight] = _strAuto, _targetElement.css(css), origHeight = _targetElementNative[LEXICON.oH], height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1), css[_strWidth] = width, css[_strHeight] = height, _textareaCoverElement.css(css), css[_strMinMinus + _strWidth] = minWidth, css[_strMinMinus + _strHeight] = minHeight, _targetElement.css(css), { _originalWidth: origWidth, _originalHeight: origHeight, _dynamicWidth: width, _dynamicHeight: height };
              }
            }
            function update(updateHints) {
              clearTimeout(_swallowedUpdateTimeout), updateHints = updateHints || {}, _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged, _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged, _swallowedUpdateHints._force |= updateHints._force;
              var now = COMPATIBILITY.now(), hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged, contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged, force = !!_swallowedUpdateHints._force, changedOptions = updateHints._changedOptions, swallow = _swallowUpdateLag > 0 && _initialized && !_destroyed && !force && !changedOptions && now - _lastUpdateTime < _swallowUpdateLag && !_heightAutoCache && !_widthAutoCache, displayIsHidden;
              if (swallow && (_swallowedUpdateTimeout = setTimeout(update, _swallowUpdateLag)), !(_destroyed || swallow || _sleeping && !changedOptions || _initialized && !force && (displayIsHidden = _hostElement.is(":hidden")) || _hostElement.css("display") === "inline")) {
                _lastUpdateTime = now, _swallowedUpdateHints = {}, _nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y) ? (_nativeScrollbarSize.x = 0, _nativeScrollbarSize.y = 0) : _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize), _nativeScrollbarMinSize = { x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3, y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3 }, changedOptions = changedOptions || {};
                var checkCacheAutoForce = function() {
                  return checkCache.apply(this, [].slice.call(arguments).concat([force]));
                }, currScroll = { x: _viewportElement[_strScrollLeft](), y: _viewportElement[_strScrollTop]() }, currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars, currentPreparedOptionsTextarea = _currentPreparedOptions.textarea, scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility, scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache), scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide, scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache), scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling, scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache), scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling, scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache), className = _currentPreparedOptions.className, classNameChanged = checkCacheAutoForce(className, _classNameCache), resize = _currentPreparedOptions.resize, resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody, paddingAbsolute = _currentPreparedOptions.paddingAbsolute, paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache), clipAlways = _currentPreparedOptions.clipAlways, clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache), sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody, sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache), ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars, ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache), autoUpdate = _currentPreparedOptions.autoUpdate, autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache), overflowBehavior = _currentPreparedOptions.overflowBehavior, overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force), textareaDynWidth = currentPreparedOptionsTextarea.dynWidth, textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth), textareaDynHeight = currentPreparedOptionsTextarea.dynHeight, textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight);
                if (_scrollbarsAutoHideNever = scrollbarsAutoHide === "n", _scrollbarsAutoHideScroll = scrollbarsAutoHide === "s", _scrollbarsAutoHideMove = scrollbarsAutoHide === "m", _scrollbarsAutoHideLeave = scrollbarsAutoHide === "l", _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay, _oldClassName = _classNameCache, _resizeNone = resize === "n", _resizeBoth = resize === "b", _resizeHorizontal = resize === "h", _resizeVertical = resize === "v", _normalizeRTLCache = _currentPreparedOptions.normalizeRTL, ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && _nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y, _scrollbarsVisibilityCache = scrollbarsVisibility, _scrollbarsAutoHideCache = scrollbarsAutoHide, _scrollbarsClickScrollingCache = scrollbarsClickScrolling, _scrollbarsDragScrollingCache = scrollbarsDragScrolling, _classNameCache = className, _resizeCache = resize, _paddingAbsoluteCache = paddingAbsolute, _clipAlwaysCache = clipAlways, _sizeAutoCapableCache = sizeAutoCapable, _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding, _autoUpdateCache = autoUpdate, _overflowBehaviorCache = extendDeep({}, overflowBehavior), _textareaDynWidthCache = textareaDynWidth, _textareaDynHeightCache = textareaDynHeight, _hasOverflowCache = _hasOverflowCache || { x: false, y: false }, classNameChanged && (removeClass(_hostElement, _oldClassName + _strSpace + _classNameThemeNone), addClass(_hostElement, className !== undefined2 && className !== null && className.length > 0 ? className : _classNameThemeNone)), autoUpdateChanged && (autoUpdate === true || autoUpdate === null && _autoUpdateRecommended ? (disconnectMutationObservers(), autoUpdateLoop.add(_base)) : (autoUpdateLoop.remove(_base), connectMutationObservers())), sizeAutoCapableChanged)
                  if (sizeAutoCapable)
                    if (_contentGlueElement ? _contentGlueElement.show() : (_contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement)), _paddingElement.before(_contentGlueElement)), _sizeAutoObserverAdded)
                      _sizeAutoObserverElement.show();
                    else {
                      _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement)), _sizeAutoObserverElementNative = _sizeAutoObserverElement[0], _contentGlueElement.before(_sizeAutoObserverElement);
                      var oldSize = { w: -1, h: -1 };
                      setupResizeObserver(_sizeAutoObserverElement, function() {
                        var newSize = { w: _sizeAutoObserverElementNative[LEXICON.oW], h: _sizeAutoObserverElementNative[LEXICON.oH] };
                        checkCache(newSize, oldSize) && (_initialized && _heightAutoCache && newSize.h > 0 || _widthAutoCache && newSize.w > 0 || _initialized && !_heightAutoCache && newSize.h === 0 || !_widthAutoCache && newSize.w === 0) && update(), oldSize = newSize;
                      }), _sizeAutoObserverAdded = true, _cssCalc !== null && _sizeAutoObserverElement.css(_strHeight, _cssCalc + "(100% + 1px)");
                    }
                  else
                    _sizeAutoObserverAdded && _sizeAutoObserverElement.hide(), _contentGlueElement && _contentGlueElement.hide();
                force && (_sizeObserverElement.find("*").trigger(_strScroll), _sizeAutoObserverAdded && _sizeAutoObserverElement.find("*").trigger(_strScroll)), displayIsHidden = displayIsHidden === undefined2 ? _hostElement.is(":hidden") : displayIsHidden;
                var textareaAutoWrapping = _isTextarea ? _targetElement.attr("wrap") !== "off" : false, textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache), cssDirection = _hostElement.css("direction"), cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache), boxSizing = _hostElement.css("box-sizing"), boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache), padding = getTopRightBottomLeftHost(_strPaddingMinus), sizeAutoObserverElementBCRect;
                try {
                  sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;
                } catch {
                  return;
                }
                _isRTL = cssDirection === "rtl", _isBorderBox = boxSizing === "border-box";
                var isRTLLeft = _isRTL ? _strLeft : _strRight, isRTLRight = _isRTL ? _strRight : _strLeft, widthAutoResizeDetection = false, widthAutoObserverDetection = _sizeAutoObserverAdded && _hostElement.css(_strFloat) !== "none" ? MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0 && (paddingAbsolute ? true : _hostElementNative[LEXICON.cW] - _paddingX > 0) : false;
                if (sizeAutoCapable && !widthAutoObserverDetection) {
                  var tmpCurrHostWidth = _hostElementNative[LEXICON.oW], tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);
                  _contentGlueElement.css(_strWidth, _strAuto);
                  var tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                  _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth), widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth, widthAutoResizeDetection || (_contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1), tmpNewHostWidth = _hostElementNative[LEXICON.oW], _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth), widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth);
                }
                var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden, widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache), wasWidthAuto = !widthAuto && _widthAutoCache, heightAuto = _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden ? MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0 : false, heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache), wasHeightAuto = !heightAuto && _heightAutoCache, updateBorderX = widthAuto && _isBorderBox || !_isBorderBox, updateBorderY = heightAuto && _isBorderBox || !_isBorderBox, border = getTopRightBottomLeftHost(_strBorderMinus, "-" + _strWidth, !updateBorderX, !updateBorderY), margin = getTopRightBottomLeftHost(_strMarginMinus), contentElementCSS = {}, contentGlueElementCSS = {}, getHostSize = function() {
                  return { w: _hostElementNative[LEXICON.cW], h: _hostElementNative[LEXICON.cH] };
                }, getViewportSize = function() {
                  return { w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]), h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH]) };
                }, paddingAbsoluteX = _paddingX = padding.l + padding.r, paddingAbsoluteY = _paddingY = padding.t + padding.b;
                if (paddingAbsoluteX *= paddingAbsolute ? 1 : 0, paddingAbsoluteY *= paddingAbsolute ? 1 : 0, padding.c = checkCacheAutoForce(padding, _cssPaddingCache), _borderX = border.l + border.r, _borderY = border.t + border.b, border.c = checkCacheAutoForce(border, _cssBorderCache), _marginX = margin.l + margin.r, _marginY = margin.t + margin.b, margin.c = checkCacheAutoForce(margin, _cssMarginCache), _textareaAutoWrappingCache = textareaAutoWrapping, _cssDirectionCache = cssDirection, _cssBoxSizingCache = boxSizing, _widthAutoCache = widthAuto, _heightAutoCache = heightAuto, _cssPaddingCache = padding, _cssBorderCache = border, _cssMarginCache = margin, cssDirectionChanged && _sizeAutoObserverAdded && _sizeAutoObserverElement.css(_strFloat, isRTLRight), padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {
                  var paddingElementCSS = {}, textareaCSS = {}, paddingValues = [padding.t, padding.r, padding.b, padding.l];
                  setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]), paddingAbsolute ? (setTopRightBottomLeft(paddingElementCSS, _strEmpty, paddingValues), setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus)) : (setTopRightBottomLeft(paddingElementCSS, _strEmpty), setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus, paddingValues)), _paddingElement.css(paddingElementCSS), _targetElement.css(textareaCSS);
                }
                _viewportSize = getViewportSize();
                var textareaSize = _isTextarea ? textareaUpdate() : false, textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache), textareaDynOrigSize = _isTextarea && textareaSize ? { w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth, h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight } : {};
                if (_textareaSizeCache = textareaSize, heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c) ? contentElementCSS[_strHeight] = _strAuto : (heightAutoChanged || paddingAbsoluteChanged) && (contentElementCSS[_strHeight] = _strHundredPercent), widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c || cssDirectionChanged) ? (contentElementCSS[_strWidth] = _strAuto, contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent) : (widthAutoChanged || paddingAbsoluteChanged) && (contentElementCSS[_strWidth] = _strHundredPercent, contentElementCSS[_strFloat] = _strEmpty, contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty), widthAuto ? (contentGlueElementCSS[_strWidth] = _strAuto, contentElementCSS[_strWidth] = VENDORS._cssPropertyValue(_strWidth, "max-content intrinsic") || _strAuto, contentElementCSS[_strFloat] = isRTLRight) : contentGlueElementCSS[_strWidth] = _strEmpty, heightAuto ? contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH] : contentGlueElementCSS[_strHeight] = _strEmpty, sizeAutoCapable && _contentGlueElement.css(contentGlueElementCSS), _contentElement.css(contentElementCSS), contentElementCSS = {}, contentGlueElementCSS = {}, hostSizeChanged || contentSizeChanged || textareaSizeChanged || cssDirectionChanged || boxSizingChanged || paddingAbsoluteChanged || widthAutoChanged || widthAuto || heightAutoChanged || heightAuto || ignoreOverlayScrollbarHidingChanged || overflowBehaviorChanged || clipAlwaysChanged || resizeChanged || scrollbarsVisibilityChanged || scrollbarsAutoHideChanged || scrollbarsDragScrollingChanged || scrollbarsClickScrollingChanged || textareaDynWidthChanged || textareaDynHeightChanged || textareaAutoWrappingChanged) {
                  var strOverflow = "overflow", strOverflowX = strOverflow + "-x", strOverflowY = strOverflow + "-y", strHidden = "hidden", strVisible = "visible";
                  if (!_nativeScrollbarStyling) {
                    var viewportElementResetCSS = {}, resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? _nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y : 0, resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? _nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x : 0;
                    setTopRightBottomLeft(viewportElementResetCSS, _strEmpty), _viewportElement.css(viewportElementResetCSS);
                  }
                  var contentMeasureElement = getContentMeasureElement(), contentSize = { w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW], h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH] }, scrollSize = { w: contentMeasureElement[LEXICON.sW], h: contentMeasureElement[LEXICON.sH] };
                  _nativeScrollbarStyling || (viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp, viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp, _viewportElement.css(viewportElementResetCSS)), _viewportSize = getViewportSize();
                  var hostSize = getHostSize(), hostAbsoluteRectSize = { w: hostSize.w - _marginX - _borderX - (_isBorderBox ? 0 : _paddingX), h: hostSize.h - _marginY - _borderY - (_isBorderBox ? 0 : _paddingY) }, contentGlueSize = { w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostAbsoluteRectSize.w), h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostAbsoluteRectSize.h) };
                  if (contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache), _contentGlueSizeCache = contentGlueSize, sizeAutoCapable) {
                    (contentGlueSize.c || heightAuto || widthAuto) && (contentGlueElementCSS[_strWidth] = contentGlueSize.w, contentGlueElementCSS[_strHeight] = contentGlueSize.h, _isTextarea || (contentSize = { w: contentMeasureElement[LEXICON.cW], h: contentMeasureElement[LEXICON.cH] }));
                    var textareaCoverCSS = {}, setContentGlueElementCSSfunction = function(horizontal) {
                      var scrollbarVars = getScrollbarVars(horizontal), wh = scrollbarVars._w_h, strWH = scrollbarVars._width_height, autoSize = horizontal ? widthAuto : heightAuto, borderSize = horizontal ? _borderX : _borderY, paddingSize = horizontal ? _paddingX : _paddingY, marginSize = horizontal ? _marginX : _marginY, viewportSize = _viewportSize[wh] - borderSize - marginSize - (_isBorderBox ? 0 : paddingSize);
                      (!autoSize || !autoSize && border.c) && (contentGlueElementCSS[strWH] = hostAbsoluteRectSize[wh] - 1), autoSize && contentSize[wh] < viewportSize && (horizontal && _isTextarea ? !textareaAutoWrapping : true) && (_isTextarea && (textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1), contentGlueElementCSS[strWH] -= 1), contentSize[wh] > 0 && (contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]));
                    };
                    setContentGlueElementCSSfunction(true), setContentGlueElementCSSfunction(false), _isTextarea && _textareaCoverElement.css(textareaCoverCSS), _contentGlueElement.css(contentGlueElementCSS);
                  }
                  widthAuto && (contentElementCSS[_strWidth] = _strHundredPercent), widthAuto && !_isBorderBox && !_mutationObserversConnected && (contentElementCSS[_strFloat] = "none"), _contentElement.css(contentElementCSS), contentElementCSS = {};
                  var contentScrollSize = { w: contentMeasureElement[LEXICON.sW], h: contentMeasureElement[LEXICON.sH] };
                  contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache), _contentScrollSizeCache = contentScrollSize, _viewportSize = getViewportSize(), hostSize = getHostSize(), hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache), _hostSizeCache = hostSize;
                  var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0), previousOverflowAmount = _overflowAmountCache, overflowBehaviorIsVS = {}, overflowBehaviorIsVH = {}, overflowBehaviorIsS = {}, overflowAmount = {}, hasOverflow = {}, hideOverflow = {}, canScroll = {}, viewportRect = _paddingElementNative[LEXICON.bCR](), setOverflowVariables = function(horizontal) {
                    var scrollbarVars = getScrollbarVars(horizontal), scrollbarVarsInverted = getScrollbarVars(!horizontal), xyI = scrollbarVarsInverted._x_y, xy = scrollbarVars._x_y, wh = scrollbarVars._w_h, widthHeight = scrollbarVars._width_height, scrollMax = _strScroll + scrollbarVars._Left_Top + "Max", fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0, checkFractionalOverflowAmount = previousOverflowAmount && previousOverflowAmount[xy] > 0 && _viewportElementNative[scrollMax] === 0;
                    overflowBehaviorIsVS[xy] = overflowBehavior[xy] === "v-s", overflowBehaviorIsVH[xy] = overflowBehavior[xy] === "v-h", overflowBehaviorIsS[xy] = overflowBehavior[xy] === "s", overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100), overflowAmount[xy] *= hideOverflowForceTextarea || checkFractionalOverflowAmount && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1 ? 0 : 1, hasOverflow[xy] = overflowAmount[xy] > 0, hideOverflow[xy] = overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI] : hasOverflow[xy], hideOverflow[xy + "s"] = hideOverflow[xy] ? overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy] : false, canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + "s"];
                  };
                  if (setOverflowVariables(true), setOverflowVariables(false), overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache), _overflowAmountCache = overflowAmount, hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache), _hasOverflowCache = hasOverflow, hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache), _hideOverflowCache = hideOverflow, _nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {
                    var borderDesign = "px solid transparent", contentArrangeElementCSS = {}, arrangeContent = {}, arrangeChanged = force, setContentElementCSS;
                    (hasOverflow.x || hasOverflow.y) && (arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty, arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty, arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache), _arrangeContentSizeCache = arrangeContent), (hasOverflow.c || hideOverflow.c || contentScrollSize.c || cssDirectionChanged || widthAutoChanged || heightAutoChanged || widthAuto || heightAuto || ignoreOverlayScrollbarHidingChanged) && (contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty, setContentElementCSS = function(horizontal) {
                      var scrollbarVars = getScrollbarVars(horizontal), scrollbarVarsInverted = getScrollbarVars(!horizontal), xy = scrollbarVars._x_y, strDirection = horizontal ? _strBottom : isRTLLeft, invertedAutoSize = horizontal ? heightAuto : widthAuto;
                      _nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + "s"] ? (contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize ? ignoreOverlayScrollbarHiding ? _strEmpty : _overlayScrollbarDummySize[xy] : _strEmpty, contentElementCSS[_strBorderMinus + strDirection] = (horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding ? _overlayScrollbarDummySize[xy] + borderDesign : _strEmpty) : (arrangeContent[scrollbarVarsInverted._w_h] = contentElementCSS[_strMarginMinus + strDirection] = contentElementCSS[_strBorderMinus + strDirection] = _strEmpty, arrangeChanged = true);
                    }, _nativeScrollbarStyling ? addRemoveClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible, !ignoreOverlayScrollbarHiding) : (setContentElementCSS(true), setContentElementCSS(false))), ignoreOverlayScrollbarHiding && (arrangeContent.w = arrangeContent.h = _strEmpty, arrangeChanged = true), arrangeChanged && !_nativeScrollbarStyling && (contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty, contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty, _contentArrangeElement || (_contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement)), _viewportElement.prepend(_contentArrangeElement)), _contentArrangeElement.css(contentArrangeElementCSS)), _contentElement.css(contentElementCSS);
                  }
                  var viewportElementCSS = {}, paddingElementCSS = {}, setViewportCSS;
                  if ((hostSizeChanged || hasOverflow.c || hideOverflow.c || contentScrollSize.c || overflowBehaviorChanged || boxSizingChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged || clipAlwaysChanged || heightAutoChanged) && (viewportElementCSS[isRTLRight] = _strEmpty, setViewportCSS = function(horizontal) {
                    var scrollbarVars = getScrollbarVars(horizontal), scrollbarVarsInverted = getScrollbarVars(!horizontal), xy = scrollbarVars._x_y, XY = scrollbarVars._X_Y, strDirection = horizontal ? _strBottom : isRTLLeft, reset = function() {
                      viewportElementCSS[strDirection] = _strEmpty, _contentBorderSize[scrollbarVarsInverted._w_h] = 0;
                    };
                    hasOverflow[xy] && hideOverflow[xy + "s"] ? (viewportElementCSS[strOverflow + XY] = _strScroll, ignoreOverlayScrollbarHiding || _nativeScrollbarStyling ? reset() : (viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]), _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0)) : (viewportElementCSS[strOverflow + XY] = _strEmpty, reset());
                  }, setViewportCSS(true), setViewportCSS(false), !_nativeScrollbarStyling && (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y) && (hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x || hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y) ? (viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x, viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x, viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y, viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y) : viewportElementCSS[_strPaddingMinus + _strTop] = viewportElementCSS[_strMarginMinus + _strTop] = viewportElementCSS[_strPaddingMinus + isRTLRight] = viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty, viewportElementCSS[_strPaddingMinus + isRTLLeft] = viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty, hasOverflow.x && hideOverflow.x || hasOverflow.y && hideOverflow.y || hideOverflowForceTextarea ? _isTextarea && hideOverflowForceTextarea && (paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = strHidden) : (!clipAlways || overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y) && (_isTextarea && (paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = _strEmpty), viewportElementCSS[strOverflowX] = viewportElementCSS[strOverflowY] = strVisible), _paddingElement.css(paddingElementCSS), _viewportElement.css(viewportElementCSS), viewportElementCSS = {}, (hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y))) {
                    var elementStyle = _contentElementNative[LEXICON.s], dump;
                    elementStyle.webkitTransform = "scale(1)", elementStyle.display = "run-in", dump = _contentElementNative[LEXICON.oH], elementStyle.display = _strEmpty, elementStyle.webkitTransform = _strEmpty;
                  }
                  if (contentElementCSS = {}, cssDirectionChanged || widthAutoChanged || heightAutoChanged)
                    if (_isRTL && widthAuto) {
                      var floatTmp = _contentElement.css(_strFloat), posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);
                      _contentElement.css(_strFloat, floatTmp);
                      var posLeftWithFloat = MATH.round(_contentElement.position().left);
                      posLeftWithoutFloat !== posLeftWithFloat && (contentElementCSS[_strLeft] = posLeftWithoutFloat);
                    } else
                      contentElementCSS[_strLeft] = _strEmpty;
                  if (_contentElement.css(contentElementCSS), _isTextarea && contentSizeChanged) {
                    var textareaInfo = getTextareaInfo();
                    if (textareaInfo) {
                      var textareaRowsChanged = _textareaInfoCache === undefined2 ? true : textareaInfo._rows !== _textareaInfoCache._rows, cursorRow = textareaInfo._cursorRow, cursorCol = textareaInfo._cursorColumn, widestRow = textareaInfo._widestRow, lastRow = textareaInfo._rows, lastCol = textareaInfo._columns, cursorPos = textareaInfo._cursorPosition, cursorMax = textareaInfo._cursorMax, cursorIsLastPosition = cursorPos >= cursorMax && _textareaHasFocus, textareaScrollAmount = { x: !textareaAutoWrapping && cursorCol === lastCol && cursorRow === widestRow ? _overflowAmountCache.x : -1, y: (textareaAutoWrapping ? cursorIsLastPosition || textareaRowsChanged && (previousOverflowAmount ? currScroll.y === previousOverflowAmount.y : false) : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow) ? _overflowAmountCache.y : -1 };
                      currScroll.x = textareaScrollAmount.x > -1 ? _isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x : currScroll.x, currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;
                    }
                    _textareaInfoCache = textareaInfo;
                  }
                  _isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache && (currScroll.x += _contentBorderSize.w || 0), widthAuto && _hostElement[_strScrollLeft](0), heightAuto && _hostElement[_strScrollTop](0), _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y);
                  var scrollbarsVisibilityVisible = scrollbarsVisibility === "v", scrollbarsVisibilityHidden = scrollbarsVisibility === "h", scrollbarsVisibilityAuto = scrollbarsVisibility === "a", refreshScrollbarsVisibility = function(showX, showY) {
                    showY = showY === undefined2 ? showX : showY, refreshScrollbarAppearance(true, showX, canScroll.x), refreshScrollbarAppearance(false, showY, canScroll.y);
                  };
                  addRemoveClass(_hostElement, _classNameHostOverflow, hideOverflow.x || hideOverflow.y), addRemoveClass(_hostElement, _classNameHostOverflowX, hideOverflow.x), addRemoveClass(_hostElement, _classNameHostOverflowY, hideOverflow.y), cssDirectionChanged && !_isBody && addRemoveClass(_hostElement, _classNameHostRTL, _isRTL), _isBody && addClass(_hostElement, _classNameHostResizeDisabled), resizeChanged && (addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone), addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone), addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth), addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal), addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical)), (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) && (ignoreOverlayScrollbarHiding ? ignoreOverlayScrollbarHidingChanged && (removeClass(_hostElement, _classNameHostScrolling), ignoreOverlayScrollbarHiding && refreshScrollbarsVisibility(false)) : scrollbarsVisibilityAuto ? refreshScrollbarsVisibility(canScroll.x, canScroll.y) : scrollbarsVisibilityVisible ? refreshScrollbarsVisibility(true) : scrollbarsVisibilityHidden && refreshScrollbarsVisibility(false)), (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) && (setupHostMouseTouchEvents(!_scrollbarsAutoHideLeave && !_scrollbarsAutoHideMove), refreshScrollbarsAutoHide(_scrollbarsAutoHideNever, !_scrollbarsAutoHideNever)), (hostSizeChanged || overflowAmount.c || heightAutoChanged || widthAutoChanged || resizeChanged || boxSizingChanged || paddingAbsoluteChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged) && (refreshScrollbarHandleLength(true), refreshScrollbarHandleOffset(true), refreshScrollbarHandleLength(false), refreshScrollbarHandleOffset(false)), scrollbarsClickScrollingChanged && refreshScrollbarsInteractive(true, scrollbarsClickScrolling), scrollbarsDragScrollingChanged && refreshScrollbarsInteractive(false, scrollbarsDragScrolling), dispatchCallback("onDirectionChanged", { isRTL: _isRTL, dir: cssDirection }, cssDirectionChanged), dispatchCallback("onHostSizeChanged", { width: _hostSizeCache.w, height: _hostSizeCache.h }, hostSizeChanged), dispatchCallback("onContentSizeChanged", { width: _contentScrollSizeCache.w, height: _contentScrollSizeCache.h }, contentSizeChanged), dispatchCallback("onOverflowChanged", { x: hasOverflow.x, y: hasOverflow.y, xScrollable: hideOverflow.xs, yScrollable: hideOverflow.ys, clipped: hideOverflow.x || hideOverflow.y }, hasOverflow.c || hideOverflow.c), dispatchCallback("onOverflowAmountChanged", { x: overflowAmount.x, y: overflowAmount.y }, overflowAmount.c);
                }
                _isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c) && (_bodyMinSizeCache.f || bodyMinSizeChanged(), _nativeScrollbarIsOverlaid.y && _hasOverflowCache.x && _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y), _nativeScrollbarIsOverlaid.x && _hasOverflowCache.y && _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x), _bodyMinSizeCache.c = false), _initialized && changedOptions.updateOnLoad && updateElementsOnLoad(), dispatchCallback("onUpdated", { forced: force });
              }
            }
            function updateElementsOnLoad() {
              _isTextarea || eachUpdateOnLoad(function(i, updateOnLoadSelector) {
                _contentElement.find(updateOnLoadSelector).each(function(i2, el) {
                  COMPATIBILITY.inA(el, _updateOnLoadElms) < 0 && (_updateOnLoadElms.push(el), FRAMEWORK(el).off(_updateOnLoadEventName, updateOnLoadCallback).on(_updateOnLoadEventName, updateOnLoadCallback));
                });
              });
            }
            function setOptions(newOptions) {
              var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions);
              return _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default), _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared), validatedOpts._prepared;
            }
            function setupStructureDOM(destroy) {
              var strParent = "parent", classNameResizeObserverHost = "os-resize-observer-host", classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit, textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty, adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs, adoptAttrsMap = {}, applyAdoptedAttrs = function() {
                var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;
                each(adoptAttrsMap, function(key, value) {
                  type(value) == TYPES.s && (key == LEXICON.c ? applyAdoptedAttrsElm.addClass(value) : applyAdoptedAttrsElm.attr(key, value));
                });
              }, hostElementClassNames = [_classNameHostElement, _classNameHostElementForeign, _classNameHostTextareaElement, _classNameHostResizeDisabled, _classNameHostRTL, _classNameHostScrollbarHorizontalHidden, _classNameHostScrollbarVerticalHidden, _classNameHostTransition, _classNameHostScrolling, _classNameHostOverflow, _classNameHostOverflowX, _classNameHostOverflowY, _classNameThemeNone, _classNameTextareaElement, _classNameTextInherit, _classNameCache].join(_strSpace), hostElementCSS = {};
              _hostElement = _hostElement || (_isTextarea ? _domExists ? _targetElement[strParent]()[strParent]()[strParent]()[strParent]() : FRAMEWORK(generateDiv(_classNameHostTextareaElement)) : _targetElement), _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass), _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass), _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass), _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost), _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined2), _domExists && addClass(_hostElement, _classNameHostElementForeign), destroy && removeClass(_hostElement, hostElementClassNames), adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs, COMPATIBILITY.isA(adoptAttrs) && _isTextarea && each(adoptAttrs, function(i, v) {
                type(v) == TYPES.s && (adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v));
              }), destroy ? (_domExists && _initialized ? (_sizeObserverElement.children().remove(), each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function(i, elm) {
                elm && removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
              }), addClass(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement)) : (remove(_sizeObserverElement), _contentElement.contents().unwrap().unwrap().unwrap(), _isTextarea && (_targetElement.unwrap(), remove(_hostElement), remove(_textareaCoverElement), applyAdoptedAttrs())), _isTextarea && _targetElement.removeAttr(LEXICON.s), _isBody && removeClass(_htmlElement, _classNameHTMLElement)) : (_isTextarea && (_currentPreparedOptions.sizeAutoCapable || (hostElementCSS[_strWidth] = _targetElement.css(_strWidth), hostElementCSS[_strHeight] = _targetElement.css(_strHeight)), _domExists || _targetElement.addClass(_classNameTextInherit).wrap(_hostElement), _hostElement = _targetElement[strParent]().css(hostElementCSS)), _domExists || (addClass(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement), _hostElement.wrapInner(_contentElement).wrapInner(_viewportElement).wrapInner(_paddingElement).prepend(_sizeObserverElement), _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement), _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement), _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement), _isTextarea && (_contentElement.prepend(_textareaCoverElement), applyAdoptedAttrs())), _nativeScrollbarStyling && addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible), _nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && addClass(_viewportElement, _classNameViewportNativeScrollbarsOverlaid), _isBody && addClass(_htmlElement, _classNameHTMLElement), _sizeObserverElementNative = _sizeObserverElement[0], _hostElementNative = _hostElement[0], _paddingElementNative = _paddingElement[0], _viewportElementNative = _viewportElement[0], _contentElementNative = _contentElement[0], updateViewportAttrsFromTarget());
            }
            function setupStructureEvents() {
              var textareaKeyDownRestrictedKeyCodes = [112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123, 33, 34, 37, 38, 39, 40, 16, 17, 18, 19, 20, 144], textareaKeyDownKeyCodesList = [], textareaUpdateIntervalID, scrollStopTimeoutId, scrollStopDelay = 175, strFocus = "focus";
              function updateTextarea(doClearInterval) {
                textareaUpdate(), _base.update(_strAuto), doClearInterval && _autoUpdateRecommended && clearInterval(textareaUpdateIntervalID);
              }
              function textareaOnScroll(event) {
                return _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0), _targetElement[_strScrollTop](0), COMPATIBILITY.prvD(event), COMPATIBILITY.stpP(event), false;
              }
              function textareaOnDrop(event) {
                setTimeout(function() {
                  _destroyed || updateTextarea();
                }, 50);
              }
              function textareaOnFocus() {
                _textareaHasFocus = true, addClass(_hostElement, strFocus);
              }
              function textareaOnFocusout() {
                _textareaHasFocus = false, textareaKeyDownKeyCodesList = [], removeClass(_hostElement, strFocus), updateTextarea(true);
              }
              function textareaOnKeyDown(event) {
                var keyCode = event.keyCode;
                inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0 && (textareaKeyDownKeyCodesList[LEXICON.l] || (updateTextarea(), textareaUpdateIntervalID = setInterval(updateTextarea, 1e3 / 60)), inArray(keyCode, textareaKeyDownKeyCodesList) < 0 && textareaKeyDownKeyCodesList.push(keyCode));
              }
              function textareaOnKeyUp(event) {
                var keyCode = event.keyCode, index3 = inArray(keyCode, textareaKeyDownKeyCodesList);
                inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0 && (index3 > -1 && textareaKeyDownKeyCodesList.splice(index3, 1), textareaKeyDownKeyCodesList[LEXICON.l] || updateTextarea(true));
              }
              function contentOnTransitionEnd(event) {
                _autoUpdateCache !== true && (event = event.originalEvent || event, isSizeAffectingCSSProperty(event.propertyName) && _base.update(_strAuto));
              }
              function viewportOnScroll(event) {
                _sleeping || (scrollStopTimeoutId !== undefined2 ? clearTimeout(scrollStopTimeoutId) : ((_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) && refreshScrollbarsAutoHide(true), nativeOverlayScrollbarsAreActive() || addClass(_hostElement, _classNameHostScrolling), dispatchCallback("onScrollStart", event)), _scrollbarsHandlesDefineScrollPos || (refreshScrollbarHandleOffset(true), refreshScrollbarHandleOffset(false)), dispatchCallback("onScroll", event), scrollStopTimeoutId = setTimeout(function() {
                  _destroyed || (clearTimeout(scrollStopTimeoutId), scrollStopTimeoutId = undefined2, (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) && refreshScrollbarsAutoHide(false), nativeOverlayScrollbarsAreActive() || removeClass(_hostElement, _classNameHostScrolling), dispatchCallback("onScrollStop", event));
                }, scrollStopDelay));
              }
              _isTextarea ? (_msieVersion > 9 || !_autoUpdateRecommended ? addDestroyEventListener(_targetElement, "input", updateTextarea) : addDestroyEventListener(_targetElement, [_strKeyDownEvent, _strKeyUpEvent], [textareaOnKeyDown, textareaOnKeyUp]), addDestroyEventListener(_targetElement, [_strScroll, "drop", strFocus, strFocus + "out"], [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout])) : addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd), addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);
            }
            function setupScrollbarsDOM(destroy) {
              var selectOrGenerateScrollbarDOM = function(isHorizontal) {
                var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical, scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true), track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar), handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);
                return !_domExists && !destroy && (scrollbar.append(track), track.append(handle)), { _scrollbar: scrollbar, _track: track, _handle: handle };
              };
              function resetScrollbarDOM(isHorizontal) {
                var scrollbarVars = getScrollbarVars(isHorizontal), scrollbar = scrollbarVars._scrollbar, track = scrollbarVars._track, handle = scrollbarVars._handle;
                _domExists && _initialized ? each([scrollbar, track, handle], function(i, elm) {
                  removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                }) : remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);
              }
              var horizontalElements, verticalElements;
              destroy ? (resetScrollbarDOM(true), resetScrollbarDOM()) : (horizontalElements = selectOrGenerateScrollbarDOM(true), verticalElements = selectOrGenerateScrollbarDOM(), _scrollbarHorizontalElement = horizontalElements._scrollbar, _scrollbarHorizontalTrackElement = horizontalElements._track, _scrollbarHorizontalHandleElement = horizontalElements._handle, _scrollbarVerticalElement = verticalElements._scrollbar, _scrollbarVerticalTrackElement = verticalElements._track, _scrollbarVerticalHandleElement = verticalElements._handle, _domExists || (_paddingElement.after(_scrollbarVerticalElement), _paddingElement.after(_scrollbarHorizontalElement)));
            }
            function setupScrollbarEvents(isHorizontal) {
              var scrollbarVars = getScrollbarVars(isHorizontal), scrollbarVarsInfo = scrollbarVars._info, insideIFrame = _windowElementNative.top !== _windowElementNative, xy = scrollbarVars._x_y, XY = scrollbarVars._X_Y, scroll = _strScroll + scrollbarVars._Left_Top, strActive = "active", strSnapHandle = "snapHandle", strClickEvent = "click", scrollDurationFactor = 1, increaseDecreaseScrollAmountKeyCodes = [16, 17], trackTimeout, mouseDownScroll, mouseDownOffset, mouseDownInvertedScale;
              function getPointerPosition(event) {
                return _msieVersion && insideIFrame ? event["screen" + XY] : COMPATIBILITY.page(event)[xy];
              }
              function getPreparedScrollbarsOption(name) {
                return _currentPreparedOptions.scrollbars[name];
              }
              function increaseTrackScrollAmount() {
                scrollDurationFactor = 0.5;
              }
              function decreaseTrackScrollAmount() {
                scrollDurationFactor = 1;
              }
              function stopClickEventPropagation(event) {
                COMPATIBILITY.stpP(event);
              }
              function documentKeyDown(event) {
                inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1 && increaseTrackScrollAmount();
              }
              function documentKeyUp(event) {
                inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1 && decreaseTrackScrollAmount();
              }
              function onMouseTouchDownContinue(event) {
                var originalEvent = event.originalEvent || event, isTouchEvent = originalEvent.touches !== undefined2;
                return _sleeping || _destroyed || nativeOverlayScrollbarsAreActive() || !_scrollbarsDragScrollingCache || isTouchEvent && !getPreparedScrollbarsOption("touchSupport") ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
              }
              function documentDragMove(event) {
                if (onMouseTouchDownContinue(event)) {
                  var trackLength = scrollbarVarsInfo._trackLength, handleLength = scrollbarVarsInfo._handleLength, scrollRange = scrollbarVarsInfo._maxScroll, scrollRaw = (getPointerPosition(event) - mouseDownOffset) * mouseDownInvertedScale, scrollDeltaPercent = scrollRaw / (trackLength - handleLength), scrollDelta = scrollRange * scrollDeltaPercent;
                  scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0, _isRTL && isHorizontal && !_rtlScrollBehavior.i && (scrollDelta *= -1), _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta)), _scrollbarsHandlesDefineScrollPos && refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta), _supportPassiveEvents || COMPATIBILITY.prvD(event);
                } else
                  documentMouseTouchUp(event);
              }
              function documentMouseTouchUp(event) {
                if (event = event || event.originalEvent, setupResponsiveEventListener(_documentElement, [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent], [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart], true), COMPATIBILITY.rAF()(function() {
                  setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, true, { _capture: true });
                }), _scrollbarsHandlesDefineScrollPos && refreshScrollbarHandleOffset(isHorizontal, true), _scrollbarsHandlesDefineScrollPos = false, removeClass(_bodyElement, _classNameDragging), removeClass(scrollbarVars._handle, strActive), removeClass(scrollbarVars._track, strActive), removeClass(scrollbarVars._scrollbar, strActive), mouseDownScroll = undefined2, mouseDownOffset = undefined2, mouseDownInvertedScale = 1, decreaseTrackScrollAmount(), trackTimeout !== undefined2 && (_base.scrollStop(), clearTimeout(trackTimeout), trackTimeout = undefined2), event) {
                  var rect = _hostElementNative[LEXICON.bCR](), mouseInsideHost = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom;
                  mouseInsideHost || hostOnMouseLeave(), (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) && refreshScrollbarsAutoHide(false);
                }
              }
              function onHandleMouseTouchDown(event) {
                onMouseTouchDownContinue(event) && onHandleMouseTouchDownAction(event);
              }
              function onHandleMouseTouchDownAction(event) {
                mouseDownScroll = _viewportElement[scroll](), mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll, (_isRTL && isHorizontal && !_rtlScrollBehavior.n || !_isRTL) && (mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll), mouseDownInvertedScale = getHostElementInvertedScale()[xy], mouseDownOffset = getPointerPosition(event), _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle), addClass(_bodyElement, _classNameDragging), addClass(scrollbarVars._handle, strActive), addClass(scrollbarVars._scrollbar, strActive), setupResponsiveEventListener(_documentElement, [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent], [documentDragMove, documentMouseTouchUp, documentOnSelectStart]), COMPATIBILITY.rAF()(function() {
                  setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, false, { _capture: true });
                }), (_msieVersion || !_documentMixed) && COMPATIBILITY.prvD(event), COMPATIBILITY.stpP(event);
              }
              function onTrackMouseTouchDown(event) {
                if (onMouseTouchDownContinue(event)) {
                  var handleToViewportRatio = scrollbarVars._info._handleLength / Math.round(MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]) * scrollbarVars._info._trackLength), scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h] * handleToViewportRatio), scrollBaseDuration = 270 * handleToViewportRatio, scrollFirstIterationDelay = 400 * handleToViewportRatio, trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top], ctrlKey = event.ctrlKey, instantScroll = event.shiftKey, instantScrollTransition = instantScroll && ctrlKey, isFirstIteration = true, easing = "linear", decreaseScroll, finishedCondition, scrollActionFinsished = function(transition) {
                    _scrollbarsHandlesDefineScrollPos && refreshScrollbarHandleOffset(isHorizontal, transition);
                  }, scrollActionInstantFinished = function() {
                    scrollActionFinsished(), onHandleMouseTouchDownAction(event);
                  }, scrollAction = function() {
                    if (!_destroyed) {
                      var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale, handleOffset = scrollbarVarsInfo._handleOffset, trackLength = scrollbarVarsInfo._trackLength, handleLength = scrollbarVarsInfo._handleLength, scrollRange = scrollbarVarsInfo._maxScroll, currScroll = scrollbarVarsInfo._currentScroll, scrollDuration = scrollBaseDuration * scrollDurationFactor, timeoutDelay = isFirstIteration ? MATH.max(scrollFirstIterationDelay, scrollDuration) : scrollDuration, instantScrollPosition = scrollRange * ((mouseOffset - handleLength / 2) / (trackLength - handleLength)), rtlIsNormal = _isRTL && isHorizontal && (!_rtlScrollBehavior.i && !_rtlScrollBehavior.n || _normalizeRTLCache), decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset, scrollObj = {}, animationObj = { easing, step: function(now) {
                        _scrollbarsHandlesDefineScrollPos && (_viewportElement[scroll](now), refreshScrollbarHandleOffset(isHorizontal, now));
                      } };
                      instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0, instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition, instantScroll ? (_viewportElement[scroll](instantScrollPosition), instantScrollTransition ? (instantScrollPosition = _viewportElement[scroll](), _viewportElement[scroll](currScroll), instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition, instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition, scrollObj[xy] = instantScrollPosition, _base.scroll(scrollObj, extendDeep(animationObj, { duration: 130, complete: scrollActionInstantFinished }))) : scrollActionInstantFinished()) : (decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll, finishedCondition = rtlIsNormal ? decreaseScroll ? handleOffset + handleLength >= mouseOffset : handleOffset <= mouseOffset : decreaseScroll ? handleOffset <= mouseOffset : handleOffset + handleLength >= mouseOffset, finishedCondition ? (clearTimeout(trackTimeout), _base.scrollStop(), trackTimeout = undefined2, scrollActionFinsished(true)) : (trackTimeout = setTimeout(scrollAction, timeoutDelay), scrollObj[xy] = (decreaseScroll ? "-=" : "+=") + scrollDistance, _base.scroll(scrollObj, extendDeep(animationObj, { duration: scrollDuration }))), isFirstIteration = false);
                    }
                  };
                  ctrlKey && increaseTrackScrollAmount(), mouseDownInvertedScale = getHostElementInvertedScale()[xy], mouseDownOffset = COMPATIBILITY.page(event)[xy], _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle), addClass(_bodyElement, _classNameDragging), addClass(scrollbarVars._track, strActive), addClass(scrollbarVars._scrollbar, strActive), setupResponsiveEventListener(_documentElement, [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent], [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]), scrollAction(), COMPATIBILITY.prvD(event), COMPATIBILITY.stpP(event);
                }
              }
              function onTrackMouseTouchEnter(event) {
                _scrollbarsHandleHovered = true, (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) && refreshScrollbarsAutoHide(true);
              }
              function onTrackMouseTouchLeave(event) {
                _scrollbarsHandleHovered = false, (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) && refreshScrollbarsAutoHide(false);
              }
              function onScrollbarMouseTouchDown(event) {
                COMPATIBILITY.stpP(event);
              }
              addDestroyEventListener(scrollbarVars._handle, _strMouseTouchDownEvent, onHandleMouseTouchDown), addDestroyEventListener(scrollbarVars._track, [_strMouseTouchDownEvent, _strMouseEnter, _strMouseLeave], [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]), addDestroyEventListener(scrollbarVars._scrollbar, _strMouseTouchDownEvent, onScrollbarMouseTouchDown), _supportTransition && addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function(event) {
                event.target === scrollbarVars._scrollbar[0] && (refreshScrollbarHandleLength(isHorizontal), refreshScrollbarHandleOffset(isHorizontal));
              });
            }
            function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {
              var scrollbarHiddenClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden, scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;
              addRemoveClass(_hostElement, scrollbarHiddenClassName, !shallBeVisible), addRemoveClass(scrollbarElement, _classNameScrollbarUnusable, !canScroll);
            }
            function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {
              if (clearTimeout(_scrollbarsAutoHideTimeoutId), shallBeVisible)
                removeClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden), removeClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
              else {
                var anyActive, strActive = "active", hide2 = function() {
                  !_scrollbarsHandleHovered && !_destroyed && (anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive), !anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave) && addClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden), !anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave) && addClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden));
                };
                _scrollbarsAutoHideDelay > 0 && delayfree !== true ? _scrollbarsAutoHideTimeoutId = setTimeout(hide2, _scrollbarsAutoHideDelay) : hide2();
              }
            }
            function refreshScrollbarHandleLength(isHorizontal) {
              var handleCSS = {}, scrollbarVars = getScrollbarVars(isHorizontal), scrollbarVarsInfo = scrollbarVars._info, digit = 1e6, handleRatio = MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]);
              handleCSS[scrollbarVars._width_height] = MATH.floor(handleRatio * 100 * digit) / digit + "%", nativeOverlayScrollbarsAreActive() || scrollbarVars._handle.css(handleCSS), scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]["offset" + scrollbarVars._Width_Height], scrollbarVarsInfo._handleLengthRatio = handleRatio;
            }
            function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {
              var transition = type(scrollOrTransition) == TYPES.b, transitionDuration = 250, isRTLisHorizontal = _isRTL && isHorizontal, scrollbarVars = getScrollbarVars(isHorizontal), scrollbarVarsInfo = scrollbarVars._info, strTranslateBrace = "translate(", strTransform = VENDORS._cssProperty("transform"), strTransition = VENDORS._cssProperty("transition"), nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop](), currentScroll = scrollOrTransition === undefined2 || transition ? nativeScroll : scrollOrTransition, handleLength = scrollbarVarsInfo._handleLength, trackLength = scrollbarVars._track[0]["offset" + scrollbarVars._Width_Height], handleTrackDiff = trackLength - handleLength, handleCSS = {}, transformOffset, translateValue, maxScroll = (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative["client" + scrollbarVars._Width_Height]) * (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1), getScrollRatio = function(base) {
                return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));
              }, getHandleOffset = function(scrollRatio2) {
                var offset2 = handleTrackDiff * scrollRatio2;
                return offset2 = isNaN(offset2) ? 0 : offset2, offset2 = isRTLisHorizontal && !_rtlScrollBehavior.i ? trackLength - handleLength - offset2 : offset2, offset2 = MATH.max(0, offset2), offset2;
              }, scrollRatio = getScrollRatio(nativeScroll), unsnappedScrollRatio = getScrollRatio(currentScroll), handleOffset = getHandleOffset(unsnappedScrollRatio), snappedHandleOffset = getHandleOffset(scrollRatio);
              scrollbarVarsInfo._maxScroll = maxScroll, scrollbarVarsInfo._currentScroll = nativeScroll, scrollbarVarsInfo._currentScrollRatio = scrollRatio, _supportTransform ? (transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset, translateValue = isHorizontal ? strTranslateBrace + transformOffset + "px, 0)" : strTranslateBrace + "0, " + transformOffset + "px)", handleCSS[strTransform] = translateValue, _supportTransition && (handleCSS[strTransition] = transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1 ? getCSSTransitionString(scrollbarVars._handle) + ", " + (strTransform + _strSpace + transitionDuration + "ms") : _strEmpty)) : handleCSS[scrollbarVars._left_top] = handleOffset, nativeOverlayScrollbarsAreActive() || (scrollbarVars._handle.css(handleCSS), _supportTransform && _supportTransition && transition && scrollbarVars._handle.one(_strTransitionEndEvent, function() {
                _destroyed || scrollbarVars._handle.css(strTransition, _strEmpty);
              })), scrollbarVarsInfo._handleOffset = handleOffset, scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset, scrollbarVarsInfo._trackLength = trackLength;
            }
            function refreshScrollbarsInteractive(isTrack, value) {
              var action = value ? "removeClass" : "addClass", element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement, element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement, className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;
              element1[action](className), element2[action](className);
            }
            function getScrollbarVars(isHorizontal) {
              return { _width_height: isHorizontal ? _strWidth : _strHeight, _Width_Height: isHorizontal ? "Width" : "Height", _left_top: isHorizontal ? _strLeft : _strTop, _Left_Top: isHorizontal ? "Left" : "Top", _x_y: isHorizontal ? _strX : _strY, _X_Y: isHorizontal ? "X" : "Y", _w_h: isHorizontal ? "w" : "h", _l_t: isHorizontal ? "l" : "t", _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement, _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement, _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement, _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo };
            }
            function setupScrollbarCornerDOM(destroy) {
              _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true), destroy ? _domExists && _initialized ? removeClass(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy) : remove(_scrollbarCornerElement) : _domExists || _hostElement.append(_scrollbarCornerElement);
            }
            function setupScrollbarCornerEvents() {
              var insideIFrame = _windowElementNative.top !== _windowElementNative, mouseDownPosition = {}, mouseDownSize = {}, mouseDownInvertedScale = {}, reconnectMutationObserver;
              function documentDragMove(event) {
                if (onMouseTouchDownContinue(event)) {
                  var pageOffset = getCoordinates(event), hostElementCSS = {};
                  (_resizeHorizontal || _resizeBoth) && (hostElementCSS[_strWidth] = mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x), (_resizeVertical || _resizeBoth) && (hostElementCSS[_strHeight] = mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y), _hostElement.css(hostElementCSS), COMPATIBILITY.stpP(event);
                } else
                  documentMouseTouchUp(event);
              }
              function documentMouseTouchUp(event) {
                var eventIsTrusted = event !== undefined2;
                setupResponsiveEventListener(_documentElement, [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent], [documentOnSelectStart, documentDragMove, documentMouseTouchUp], true), removeClass(_bodyElement, _classNameDragging), _scrollbarCornerElement.releaseCapture && _scrollbarCornerElement.releaseCapture(), eventIsTrusted && (reconnectMutationObserver && connectMutationObservers(), _base.update(_strAuto)), reconnectMutationObserver = false;
              }
              function onMouseTouchDownContinue(event) {
                var originalEvent = event.originalEvent || event, isTouchEvent = originalEvent.touches !== undefined2;
                return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
              }
              function getCoordinates(event) {
                return _msieVersion && insideIFrame ? { x: event.screenX, y: event.screenY } : COMPATIBILITY.page(event);
              }
              addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function(event) {
                onMouseTouchDownContinue(event) && !_resizeNone && (_mutationObserversConnected && (reconnectMutationObserver = true, disconnectMutationObservers()), mouseDownPosition = getCoordinates(event), mouseDownSize.w = _hostElementNative[LEXICON.oW] - (_isBorderBox ? 0 : _paddingX), mouseDownSize.h = _hostElementNative[LEXICON.oH] - (_isBorderBox ? 0 : _paddingY), mouseDownInvertedScale = getHostElementInvertedScale(), setupResponsiveEventListener(_documentElement, [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent], [documentOnSelectStart, documentDragMove, documentMouseTouchUp]), addClass(_bodyElement, _classNameDragging), _scrollbarCornerElement.setCapture && _scrollbarCornerElement.setCapture(), COMPATIBILITY.prvD(event), COMPATIBILITY.stpP(event));
              });
            }
            function dispatchCallback(name, args, dependent) {
              if (dependent !== false)
                if (_initialized) {
                  var callback = _currentPreparedOptions.callbacks[name], extensionOnName = name, ext;
                  extensionOnName.substr(0, 2) === "on" && (extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3)), type(callback) == TYPES.f && callback.call(_base, args), each(_extensions, function() {
                    ext = this, type(ext.on) == TYPES.f && ext.on(extensionOnName, args);
                  });
                } else
                  _destroyed || _callbacksInitQeueue.push({ n: name, a: args });
            }
            function setTopRightBottomLeft(targetCSSObject, prefix2, values) {
              prefix2 = prefix2 || _strEmpty, values = values || [_strEmpty, _strEmpty, _strEmpty, _strEmpty], targetCSSObject[prefix2 + _strTop] = values[0], targetCSSObject[prefix2 + _strRight] = values[1], targetCSSObject[prefix2 + _strBottom] = values[2], targetCSSObject[prefix2 + _strLeft] = values[3];
            }
            function getTopRightBottomLeftHost(prefix2, suffix, zeroX, zeroY) {
              return suffix = suffix || _strEmpty, prefix2 = prefix2 || _strEmpty, { t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix2 + _strTop + suffix)), r: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix2 + _strRight + suffix)), b: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix2 + _strBottom + suffix)), l: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix2 + _strLeft + suffix)) };
            }
            function getCSSTransitionString(element) {
              var transitionStr = VENDORS._cssProperty("transition"), assembledValue = element.css(transitionStr);
              if (assembledValue)
                return assembledValue;
              for (var regExpString = "\\s*(([^,(]+(\\(.+?\\))?)+)[\\s,]*", regExpMain = new RegExp(regExpString), regExpValidate = new RegExp("^(" + regExpString + ")+$"), properties = "property duration timing-function delay".split(" "), result = [], strResult, valueArray, i = 0, j, splitCssStyleByComma = function(str) {
                if (strResult = [], !str.match(regExpValidate))
                  return str;
                for (; str.match(regExpMain); )
                  strResult.push(RegExp.$1), str = str.replace(regExpMain, _strEmpty);
                return strResult;
              }; i < properties[LEXICON.l]; i++)
                for (valueArray = splitCssStyleByComma(element.css(transitionStr + "-" + properties[i])), j = 0; j < valueArray[LEXICON.l]; j++)
                  result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];
              return result.join(", ");
            }
            function createHostClassNameRegExp(withCurrClassNameOption, withOldClassNameOption) {
              var i, split, appendix, appendClasses = function(classes, condition) {
                if (appendix = "", condition && typeof classes == TYPES.s)
                  for (split = classes.split(_strSpace), i = 0; i < split[LEXICON.l]; i++)
                    appendix += "|" + split[i] + "$";
                return appendix;
              };
              return new RegExp("(^" + _classNameHostElement + "([-_].+|)$)" + appendClasses(_classNameCache, withCurrClassNameOption) + appendClasses(_oldClassName, withOldClassNameOption), "g");
            }
            function getHostElementInvertedScale() {
              var rect = _paddingElementNative[LEXICON.bCR]();
              return { x: _supportTransform && 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1, y: _supportTransform && 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 };
            }
            function isHTMLElement2(o) {
              var strOwnerDocument = "ownerDocument", strHTMLElement = "HTMLElement", wnd = o && o[strOwnerDocument] && o[strOwnerDocument].parentWindow || window2;
              return typeof wnd[strHTMLElement] == TYPES.o ? o instanceof wnd[strHTMLElement] : o && typeof o == TYPES.o && o !== null && o.nodeType === 1 && typeof o.nodeName == TYPES.s;
            }
            function getArrayDifferences(a1, a2) {
              var a = [], diff = [], i, k;
              for (i = 0; i < a1.length; i++)
                a[a1[i]] = true;
              for (i = 0; i < a2.length; i++)
                a[a2[i]] ? delete a[a2[i]] : a[a2[i]] = true;
              for (k in a)
                diff.push(k);
              return diff;
            }
            function parseToZeroOrNumber(value, toFloat) {
              var num = toFloat ? parseFloat(value) : parseInt(value, 10);
              return isNaN(num) ? 0 : num;
            }
            function getTextareaInfo() {
              var textareaCursorPosition = _targetElementNative.selectionStart;
              if (textareaCursorPosition !== undefined2) {
                var textareaValue = _targetElement.val(), textareaLength = textareaValue[LEXICON.l], textareaRowSplit = textareaValue.split(`
`), textareaLastRow = textareaRowSplit[LEXICON.l], textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split(`
`), widestRow = 0, textareaLastCol = 0, cursorRow = textareaCurrentCursorRowSplit[LEXICON.l], cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l], rowCols, i;
                for (i = 0; i < textareaRowSplit[LEXICON.l]; i++)
                  rowCols = textareaRowSplit[i][LEXICON.l], rowCols > textareaLastCol && (widestRow = i + 1, textareaLastCol = rowCols);
                return { _cursorRow: cursorRow, _cursorColumn: cursorCol, _rows: textareaLastRow, _columns: textareaLastCol, _widestRow: widestRow, _cursorPosition: textareaCursorPosition, _cursorMax: textareaLength };
              }
            }
            function nativeOverlayScrollbarsAreActive() {
              return _ignoreOverlayScrollbarHidingCache && _nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y;
            }
            function getContentMeasureElement() {
              return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;
            }
            function generateDiv(classesOrAttrs, content) {
              return "<div " + (classesOrAttrs ? type(classesOrAttrs) == TYPES.s ? 'class="' + classesOrAttrs + '"' : function() {
                var key, attrs = _strEmpty;
                if (FRAMEWORK.isPlainObject(classesOrAttrs))
                  for (key in classesOrAttrs)
                    attrs += (key === "c" ? "class" : key) + '="' + classesOrAttrs[key] + '" ';
                return attrs;
              }() : _strEmpty) + ">" + (content || _strEmpty) + "</div>";
            }
            function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {
              var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b, selectParent = onlyChildren ? _hostElement : selectParentOrOnlyChildren || _hostElement;
              return _domExists && !selectParent[LEXICON.l] ? null : _domExists ? selectParent[onlyChildren ? "children" : "find"](_strDot + className.replace(/\s/g, _strDot)).eq(0) : FRAMEWORK(generateDiv(className));
            }
            function getObjectPropVal(obj, path) {
              for (var splits = path.split(_strDot), i = 0, val; i < splits.length; i++) {
                if (!obj[LEXICON.hOP](splits[i]))
                  return;
                val = obj[splits[i]], i < splits.length && type(val) == TYPES.o && (obj = val);
              }
              return val;
            }
            function setObjectPropVal(obj, path, val) {
              for (var splits = path.split(_strDot), splitsLength = splits.length, i = 0, extendObj = {}, extendObjRoot = extendObj; i < splitsLength; i++)
                extendObj = extendObj[splits[i]] = i + 1 < splitsLength ? {} : val;
              FRAMEWORK.extend(obj, extendObjRoot, true);
            }
            function eachUpdateOnLoad(action) {
              var updateOnLoad = _currentPreparedOptions.updateOnLoad;
              updateOnLoad = type(updateOnLoad) == TYPES.s ? updateOnLoad.split(_strSpace) : updateOnLoad, COMPATIBILITY.isA(updateOnLoad) && !_destroyed && each(updateOnLoad, action);
            }
            function checkCache(current, cache, force) {
              if (force)
                return force;
              if (type(current) == TYPES.o && type(cache) == TYPES.o) {
                for (var prop in current)
                  if (prop !== "c")
                    if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {
                      if (checkCache(current[prop], cache[prop]))
                        return true;
                    } else
                      return true;
              } else
                return current !== cache;
              return false;
            }
            function extendDeep() {
              return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));
            }
            function addClass(el, classes) {
              return _frameworkProto.addClass.call(el, classes);
            }
            function removeClass(el, classes) {
              return _frameworkProto.removeClass.call(el, classes);
            }
            function addRemoveClass(el, classes, doAdd) {
              return doAdd ? addClass(el, classes) : removeClass(el, classes);
            }
            function remove(el) {
              return _frameworkProto.remove.call(el);
            }
            function findFirst(el, selector) {
              return _frameworkProto.find.call(el, selector).eq(0);
            }
            _base.sleep = function() {
              _sleeping = true;
            }, _base.update = function(force) {
              if (!_destroyed) {
                var attrsChanged, contentSizeC, isString = type(force) == TYPES.s, doUpdateAuto, mutHost, mutContent;
                return isString ? force === _strAuto ? (attrsChanged = meaningfulAttrsChanged(), contentSizeC = updateAutoContentSizeChanged(), doUpdateAuto = attrsChanged || contentSizeC, doUpdateAuto && update({ _contentSizeChanged: contentSizeC, _changedOptions: _initialized ? undefined2 : _currentPreparedOptions })) : force === _strSync ? _mutationObserversConnected ? (mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords()), mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords())) : mutHost = _base.update(_strAuto) : force === "zoom" && update({ _hostSizeChanged: true, _contentSizeChanged: true }) : (force = _sleeping || force, _sleeping = false, (!_base.update(_strSync) || force) && update({ _force: force })), updateElementsOnLoad(), doUpdateAuto || mutHost || mutContent;
              }
            }, _base.options = function(newOptions, value) {
              var option = {}, changedOps;
              if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions))
                if (type(newOptions) == TYPES.s)
                  if (arguments.length > 1)
                    setObjectPropVal(option, newOptions, value), changedOps = setOptions(option);
                  else
                    return getObjectPropVal(_currentOptions, newOptions);
                else
                  return _currentOptions;
              else
                changedOps = setOptions(newOptions);
              FRAMEWORK.isEmptyObject(changedOps) || update({ _changedOptions: changedOps });
            }, _base.destroy = function() {
              if (!_destroyed) {
                autoUpdateLoop.remove(_base), disconnectMutationObservers(), setupResizeObserver(_sizeObserverElement), setupResizeObserver(_sizeAutoObserverElement);
                for (var extName in _extensions)
                  _base.removeExt(extName);
                for (; _destroyEvents[LEXICON.l] > 0; )
                  _destroyEvents.pop()();
                setupHostMouseTouchEvents(true), _contentGlueElement && remove(_contentGlueElement), _contentArrangeElement && remove(_contentArrangeElement), _sizeAutoObserverAdded && remove(_sizeAutoObserverElement), setupScrollbarsDOM(true), setupScrollbarCornerDOM(true), setupStructureDOM(true);
                for (var i = 0; i < _updateOnLoadElms[LEXICON.l]; i++)
                  FRAMEWORK(_updateOnLoadElms[i]).off(_updateOnLoadEventName, updateOnLoadCallback);
                _updateOnLoadElms = undefined2, _destroyed = true, _sleeping = true, INSTANCES(pluginTargetElement, 0), dispatchCallback("onDestroyed");
              }
            }, _base.scroll = function(coordinates, duration, easing, complete) {
              if (arguments.length === 0 || coordinates === undefined2) {
                var infoX = _scrollHorizontalInfo, infoY = _scrollVerticalInfo, normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i, normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n, scrollX = infoX._currentScroll, scrollXRatio = infoX._currentScrollRatio, maxScrollX = infoX._maxScroll;
                return scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio, scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX, scrollX *= normalizeNegate ? -1 : 1, maxScrollX *= normalizeNegate ? -1 : 1, { position: { x: scrollX, y: infoY._currentScroll }, ratio: { x: scrollXRatio, y: infoY._currentScrollRatio }, max: { x: maxScrollX, y: infoY._maxScroll }, handleOffset: { x: infoX._handleOffset, y: infoY._handleOffset }, handleLength: { x: infoX._handleLength, y: infoY._handleLength }, handleLengthRatio: { x: infoX._handleLengthRatio, y: infoY._handleLengthRatio }, trackLength: { x: infoX._trackLength, y: infoY._trackLength }, snappedHandleOffset: { x: infoX._snappedHandleOffset, y: infoY._snappedHandleOffset }, isRTL: _isRTL, isRTLNormalized: _normalizeRTLCache };
              }
              _base.update(_strSync);
              var normalizeRTL = _normalizeRTLCache, coordinatesXAxisProps = [_strX, _strLeft, "l"], coordinatesYAxisProps = [_strY, _strTop, "t"], coordinatesOperators = ["+=", "-=", "*=", "/="], durationIsObject = type(duration) == TYPES.o, completeCallback = durationIsObject ? duration.complete : complete, i, finalScroll = {}, specialEasing = {}, doScrollLeft, doScrollTop, animationOptions, strEnd = "end", strBegin = "begin", strCenter = "center", strNearest = "nearest", strAlways = "always", strNever = "never", strIfNeeded = "ifneeded", strLength = LEXICON.l, settingsAxis, settingsScroll, settingsBlock, settingsMargin, finalElement, elementObjSettingsAxisValues = [_strX, _strY, "xy", "yx"], elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest], elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded], coordinatesIsElementObj = coordinates[LEXICON.hOP]("el"), possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates, possibleElementIsJQuery = possibleElement instanceof FRAMEWORK || JQUERY ? possibleElement instanceof JQUERY : false, possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement2(possibleElement), updateScrollbarInfos = function() {
                doScrollLeft && refreshScrollbarHandleOffset(true), doScrollTop && refreshScrollbarHandleOffset(false);
              }, proxyCompleteCallback = type(completeCallback) != TYPES.f ? undefined2 : function() {
                updateScrollbarInfos(), completeCallback();
              };
              function checkSettingsStringValue(currValue, allowedValues) {
                for (i = 0; i < allowedValues[strLength]; i++)
                  if (currValue === allowedValues[i])
                    return true;
                return false;
              }
              function getRawScroll(isX, coordinates2) {
                var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;
                if (coordinates2 = type(coordinates2) == TYPES.s || type(coordinates2) == TYPES.n ? [coordinates2, coordinates2] : coordinates2, COMPATIBILITY.isA(coordinates2))
                  return isX ? coordinates2[0] : coordinates2[1];
                if (type(coordinates2) == TYPES.o) {
                  for (i = 0; i < coordinateProps[strLength]; i++)
                    if (coordinateProps[i] in coordinates2)
                      return coordinates2[coordinateProps[i]];
                }
              }
              function getFinalScroll(isX, rawScroll) {
                var isString = type(rawScroll) == TYPES.s, operator, amount, scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo, currScroll = scrollInfo._currentScroll, maxScroll = scrollInfo._maxScroll, mult = " * ", finalValue, isRTLisX = _isRTL && isX, normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL, strReplace = "replace", evalFunc = eval, possibleOperator;
                if (isString ? (rawScroll[strLength] > 2 && (possibleOperator = rawScroll.substr(0, 2), inArray(possibleOperator, coordinatesOperators) > -1 && (operator = possibleOperator)), rawScroll = operator ? rawScroll.substr(2) : rawScroll, rawScroll = rawScroll[strReplace](/min/g, 0)[strReplace](/</g, 0)[strReplace](/max/g, (normalizeShortcuts ? "-" : _strEmpty) + _strHundredPercent)[strReplace](/>/g, (normalizeShortcuts ? "-" : _strEmpty) + _strHundredPercent)[strReplace](/px/g, _strEmpty)[strReplace](/%/g, mult + maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1) / 100)[strReplace](/vw/g, mult + _viewportSize.w)[strReplace](/vh/g, mult + _viewportSize.h), amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll)) : amount = rawScroll, amount !== undefined2 && !isNaN(amount) && type(amount) == TYPES.n) {
                  var normalizeIsRTLisX = normalizeRTL && isRTLisX, operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1), invert = normalizeIsRTLisX && _rtlScrollBehavior.i, negate = normalizeIsRTLisX && _rtlScrollBehavior.n;
                  switch (operatorCurrScroll = invert ? maxScroll - operatorCurrScroll : operatorCurrScroll, operator) {
                    case "+=":
                      finalValue = operatorCurrScroll + amount;
                      break;
                    case "-=":
                      finalValue = operatorCurrScroll - amount;
                      break;
                    case "*=":
                      finalValue = operatorCurrScroll * amount;
                      break;
                    case "/=":
                      finalValue = operatorCurrScroll / amount;
                      break;
                    default:
                      finalValue = amount;
                      break;
                  }
                  finalValue = invert ? maxScroll - finalValue : finalValue, finalValue *= negate ? -1 : 1, finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));
                }
                return finalValue === currScroll ? undefined2 : finalValue;
              }
              function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {
                var resultDefault = [defaultValue, defaultValue], valueType = type(value), valueArrLength, valueArrItem;
                if (valueType == valueInternalType)
                  value = [value, value];
                else if (valueType == TYPES.a) {
                  if (valueArrLength = value[strLength], valueArrLength > 2 || valueArrLength < 1)
                    value = resultDefault;
                  else
                    for (valueArrLength === 1 && (value[1] = defaultValue), i = 0; i < valueArrLength; i++)
                      if (valueArrItem = value[i], type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {
                        value = resultDefault;
                        break;
                      }
                } else
                  valueType == TYPES.o ? value = [value[_strX] || defaultValue, value[_strY] || defaultValue] : value = resultDefault;
                return { x: value[0], y: value[1] };
              }
              function generateMargin(marginTopRightBottomLeftArray) {
                var result = [], currValue, currValueType, valueDirections = [_strTop, _strRight, _strBottom, _strLeft];
                for (i = 0; i < marginTopRightBottomLeftArray[strLength] && i !== valueDirections[strLength]; i++)
                  currValue = marginTopRightBottomLeftArray[i], currValueType = type(currValue), currValueType == TYPES.b ? result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i])) : 0) : result.push(currValueType == TYPES.n ? currValue : 0);
                return result;
              }
              if (possibleElementIsJQuery || possibleElementIsHTMLElement) {
                var margin = coordinatesIsElementObj ? coordinates.margin : 0, axis = coordinatesIsElementObj ? coordinates.axis : 0, scroll = coordinatesIsElementObj ? coordinates.scroll : 0, block = coordinatesIsElementObj ? coordinates.block : 0, marginDefault = [0, 0, 0, 0], marginType = type(margin), marginLength;
                if (finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement), finalElement[strLength] > 0) {
                  marginType == TYPES.n || marginType == TYPES.b ? margin = generateMargin([margin, margin, margin, margin]) : marginType == TYPES.a ? (marginLength = margin[strLength], marginLength === 2 ? margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]) : marginLength >= 4 ? margin = generateMargin(margin) : margin = marginDefault) : marginType == TYPES.o ? margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]) : margin = marginDefault, settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : "xy", settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues), settingsBlock = getPerAxisValue(block, TYPES.s, strBegin, elementObjSettingsBlockValues), settingsMargin = margin;
                  var viewportScroll = { l: _scrollHorizontalInfo._currentScroll, t: _scrollVerticalInfo._currentScroll }, viewportOffset = _paddingElement.offset(), elementOffset = finalElement.offset(), doNotScroll = { x: settingsScroll.x == strNever || settingsAxis == _strY, y: settingsScroll.y == strNever || settingsAxis == _strX };
                  elementOffset[_strTop] -= settingsMargin[0], elementOffset[_strLeft] -= settingsMargin[3];
                  var elementScrollCoordinates = { x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l), y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t) };
                  if (_isRTL && (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i && (elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l)), _rtlScrollBehavior.n && normalizeRTL && (elementScrollCoordinates.x *= -1), _rtlScrollBehavior.i && normalizeRTL && (elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l)))), settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {
                    var measuringElm = finalElement[0], rawElementSize = _supportTransform ? measuringElm[LEXICON.bCR]() : { width: measuringElm[LEXICON.oW], height: measuringElm[LEXICON.oH] }, elementSize = { w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1], h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2] }, finalizeBlock = function(isX) {
                      var vars = getScrollbarVars(isX), wh = vars._w_h, lt = vars._left_top, xy = vars._x_y, blockIsEnd = settingsBlock[xy] == (isX && _isRTL ? strBegin : strEnd), blockIsCenter = settingsBlock[xy] == strCenter, blockIsNearest = settingsBlock[xy] == strNearest, scrollNever = settingsScroll[xy] == strNever, scrollIfNeeded = settingsScroll[xy] == strIfNeeded, vpSize = _viewportSize[wh], vpOffset = viewportOffset[lt], elSize = elementSize[wh], elOffset = elementOffset[lt], divide = blockIsCenter ? 2 : 1, elementCenterOffset = elOffset + elSize / 2, viewportCenterOffset = vpOffset + vpSize / 2, isInView = elSize <= vpSize && elOffset >= vpOffset && elOffset + elSize <= vpOffset + vpSize;
                      scrollNever ? doNotScroll[xy] = true : doNotScroll[xy] || ((blockIsNearest || scrollIfNeeded) && (doNotScroll[xy] = scrollIfNeeded ? isInView : false, blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset), elementScrollCoordinates[xy] -= blockIsEnd || blockIsCenter ? (vpSize / divide - elSize / divide) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0);
                    };
                    finalizeBlock(true), finalizeBlock(false);
                  }
                  doNotScroll.y && delete elementScrollCoordinates.y, doNotScroll.x && delete elementScrollCoordinates.x, coordinates = elementScrollCoordinates;
                }
              }
              finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates)), finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates)), doScrollLeft = finalScroll[_strScrollLeft] !== undefined2, doScrollTop = finalScroll[_strScrollTop] !== undefined2, (doScrollLeft || doScrollTop) && (duration > 0 || durationIsObject) ? durationIsObject ? (duration.complete = proxyCompleteCallback, _viewportElement.animate(finalScroll, duration)) : (animationOptions = { duration, complete: proxyCompleteCallback }, COMPATIBILITY.isA(easing) || FRAMEWORK.isPlainObject(easing) ? (specialEasing[_strScrollLeft] = easing[0] || easing.x, specialEasing[_strScrollTop] = easing[1] || easing.y, animationOptions.specialEasing = specialEasing) : animationOptions.easing = easing, _viewportElement.animate(finalScroll, animationOptions)) : (doScrollLeft && _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]), doScrollTop && _viewportElement[_strScrollTop](finalScroll[_strScrollTop]), updateScrollbarInfos());
            }, _base.scrollStop = function(param1, param2, param3) {
              return _viewportElement.stop(param1, param2, param3), _base;
            }, _base.getElements = function(elementName) {
              var obj = { target: _targetElementNative, host: _hostElementNative, padding: _paddingElementNative, viewport: _viewportElementNative, content: _contentElementNative, scrollbarHorizontal: { scrollbar: _scrollbarHorizontalElement[0], track: _scrollbarHorizontalTrackElement[0], handle: _scrollbarHorizontalHandleElement[0] }, scrollbarVertical: { scrollbar: _scrollbarVerticalElement[0], track: _scrollbarVerticalTrackElement[0], handle: _scrollbarVerticalHandleElement[0] }, scrollbarCorner: _scrollbarCornerElement[0] };
              return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;
            }, _base.getState = function(stateProperty) {
              function prepare(obj2) {
                if (!FRAMEWORK.isPlainObject(obj2))
                  return obj2;
                var extended = extendDeep({}, obj2), changePropertyName = function(from, to) {
                  extended[LEXICON.hOP](from) && (extended[to] = extended[from], delete extended[from]);
                };
                return changePropertyName("w", _strWidth), changePropertyName("h", _strHeight), delete extended.c, extended;
              }
              var obj = { destroyed: !!prepare(_destroyed), sleeping: !!prepare(_sleeping), autoUpdate: prepare(!_mutationObserversConnected), widthAuto: prepare(_widthAutoCache), heightAuto: prepare(_heightAutoCache), padding: prepare(_cssPaddingCache), overflowAmount: prepare(_overflowAmountCache), hideOverflow: prepare(_hideOverflowCache), hasOverflow: prepare(_hasOverflowCache), contentScrollSize: prepare(_contentScrollSizeCache), viewportSize: prepare(_viewportSize), hostSize: prepare(_hostSizeCache), documentMixed: prepare(_documentMixed) };
              return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;
            }, _base.ext = function(extName) {
              var result, privateMethods = _extensionsPrivateMethods.split(" "), i = 0;
              if (type(extName) == TYPES.s) {
                if (_extensions[LEXICON.hOP](extName))
                  for (result = extendDeep({}, _extensions[extName]); i < privateMethods.length; i++)
                    delete result[privateMethods[i]];
              } else {
                result = {};
                for (i in _extensions)
                  result[i] = extendDeep({}, _base.ext(i));
              }
              return result;
            }, _base.addExt = function(extName, extensionOptions) {
              var registeredExtensionObj = _plugin.extension(extName), instance, instanceAdded, instanceContract, contractResult, contractFulfilled = true;
              if (registeredExtensionObj) {
                if (_extensions[LEXICON.hOP](extName))
                  return _base.ext(extName);
                if (instance = registeredExtensionObj.extensionFactory.call(_base, extendDeep({}, registeredExtensionObj.defaultOptions), FRAMEWORK, COMPATIBILITY), instance && (instanceContract = instance.contract, type(instanceContract) == TYPES.f && (contractResult = instanceContract(window2), contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled), contractFulfilled))
                  return _extensions[extName] = instance, instanceAdded = instance.added, type(instanceAdded) == TYPES.f && instanceAdded(extensionOptions), _base.ext(extName);
              } else
                console.warn('A extension with the name "' + extName + `" isn't registered.`);
            }, _base.removeExt = function(extName) {
              var instance = _extensions[extName], instanceRemoved;
              return instance ? (delete _extensions[extName], instanceRemoved = instance.removed, type(instanceRemoved) == TYPES.f && instanceRemoved(), true) : false;
            };
            function construct(targetElement, options2, extensions2) {
              _defaultOptions = globals.defaultOptions, _nativeScrollbarStyling = globals.nativeScrollbarStyling, _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize), _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid), _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize), _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior), setOptions(extendDeep({}, _defaultOptions, options2)), _cssCalc = globals.cssCalc, _msieVersion = globals.msie, _autoUpdateRecommended = globals.autoUpdateRecommended, _supportTransition = globals.supportTransition, _supportTransform = globals.supportTransform, _supportPassiveEvents = globals.supportPassiveEvents, _supportResizeObserver = globals.supportResizeObserver, _supportMutationObserver = globals.supportMutationObserver, _restrictedMeasuring = globals.restrictedMeasuring, _documentElement = FRAMEWORK(targetElement.ownerDocument), _documentElementNative = _documentElement[0], _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow), _windowElementNative = _windowElement[0], _htmlElement = findFirst(_documentElement, "html"), _bodyElement = findFirst(_htmlElement, "body"), _targetElement = FRAMEWORK(targetElement), _targetElementNative = _targetElement[0], _isTextarea = _targetElement.is("textarea"), _isBody = _targetElement.is("body"), _documentMixed = _documentElementNative !== document3, _domExists = _isTextarea ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement) : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];
              var initBodyScroll, bodyMouseTouchDownListener;
              return _nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize ? (_initialized = true, dispatchCallback("onInitializationWithdrawn"), _domExists && (setupStructureDOM(true), setupScrollbarsDOM(true), setupScrollbarCornerDOM(true)), _initialized = false, _destroyed = true, _sleeping = true, _base) : (_isBody && (initBodyScroll = {}, initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]()), initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]()), bodyMouseTouchDownListener = function() {
                _viewportElement.removeAttr(LEXICON.ti), setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, true, true);
              }), setupStructureDOM(), setupScrollbarsDOM(), setupScrollbarCornerDOM(), setupStructureEvents(), setupScrollbarEvents(true), setupScrollbarEvents(false), setupScrollbarCornerEvents(), createMutationObservers(), setupResizeObserver(_sizeObserverElement, hostOnResized), _isBody && (_viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t), document3.activeElement == targetElement && _viewportElementNative.focus && (_viewportElement.attr(LEXICON.ti, "-1"), _viewportElementNative.focus(), setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true))), _base.update(_strAuto), _initialized = true, dispatchCallback("onInitialized"), each(_callbacksInitQeueue, function(index3, value) {
                dispatchCallback(value.n, value.a);
              }), _callbacksInitQeueue = [], type(extensions2) == TYPES.s && (extensions2 = [extensions2]), COMPATIBILITY.isA(extensions2) ? each(extensions2, function(index3, value) {
                _base.addExt(value);
              }) : FRAMEWORK.isPlainObject(extensions2) && each(extensions2, function(key, value) {
                _base.addExt(key, value);
              }), setTimeout(function() {
                _supportTransition && !_destroyed && addClass(_hostElement, _classNameHostTransition);
              }, 333), _base);
            }
            return _plugin.valid(construct(pluginTargetElement, options, extensions)) && INSTANCES(pluginTargetElement, _base), _base;
          }
          return _plugin = window2[PLUGINNAME] = function(pluginTargetElements, options, extensions) {
            if (arguments[LEXICON.l] === 0)
              return this;
            var arr = [], optsIsPlainObj = FRAMEWORK.isPlainObject(options), inst, result;
            return pluginTargetElements ? (pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined2 ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements], initOverlayScrollbarsStatics(), pluginTargetElements[LEXICON.l] > 0 && (optsIsPlainObj ? FRAMEWORK.each(pluginTargetElements, function(i, v) {
              inst = v, inst !== undefined2 && arr.push(OverlayScrollbarsInstance(inst, options, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));
            }) : FRAMEWORK.each(pluginTargetElements, function(i, v) {
              inst = INSTANCES(v), (options === "!" && _plugin.valid(inst) || COMPATIBILITY.type(options) == TYPES.f && options(v, inst) || options === undefined2) && arr.push(inst);
            }), result = arr[LEXICON.l] === 1 ? arr[0] : arr), result) : optsIsPlainObj || !options ? result : arr;
          }, _plugin.globals = function() {
            initOverlayScrollbarsStatics();
            var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);
            return delete globals.msie, globals;
          }, _plugin.defaultOptions = function(newDefaultOptions) {
            initOverlayScrollbarsStatics();
            var currDefaultOptions = _pluginsGlobals.defaultOptions;
            if (newDefaultOptions === undefined2)
              return FRAMEWORK.extend(true, {}, currDefaultOptions);
            _pluginsGlobals.defaultOptions = FRAMEWORK.extend(true, {}, currDefaultOptions, _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default);
          }, _plugin.valid = function(osInstance) {
            return osInstance instanceof _plugin && !osInstance.getState().destroyed;
          }, _plugin.extension = function(extensionName, extension, defaultOptions) {
            var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s, argLen = arguments[LEXICON.l], i = 0;
            if (argLen < 1 || !extNameTypeString)
              return FRAMEWORK.extend(true, { length: _pluginsExtensions[LEXICON.l] }, _pluginsExtensions);
            if (extNameTypeString) {
              if (COMPATIBILITY.type(extension) == TYPES.f)
                _pluginsExtensions.push({ name: extensionName, extensionFactory: extension, defaultOptions });
              else
                for (; i < _pluginsExtensions[LEXICON.l]; i++)
                  if (_pluginsExtensions[i].name === extensionName)
                    if (argLen > 1)
                      _pluginsExtensions.splice(i, 1);
                    else
                      return FRAMEWORK.extend(true, {}, _pluginsExtensions[i]);
            }
          }, _plugin;
        }();
        return JQUERY && JQUERY.fn && (JQUERY.fn.overlayScrollbars = function(options, extensions) {
          var _elements = this;
          return JQUERY.isPlainObject(options) ? (JQUERY.each(_elements, function() {
            PLUGIN(this, options, extensions);
          }), _elements) : PLUGIN(_elements, options);
        }), PLUGIN;
      });
    } });
    import_overlayscrollbars = __toESM2(require_OverlayScrollbars());
    OverlayScrollbarsComponent = ({ options = {}, extensions, className, children, ...rest }) => {
      let osTargetRef = (0, import_react2.useRef)(), osInstance = (0, import_react2.useRef)();
      return (0, import_react2.useEffect)(() => (osInstance.current = (0, import_overlayscrollbars.default)(osTargetRef.current, options, extensions), mergeHostClassNames(osInstance.current, className), () => {
        import_overlayscrollbars.default.valid(osInstance.current) && (osInstance.current.destroy(), osInstance.current = null);
      }), []), (0, import_react2.useEffect)(() => {
        import_overlayscrollbars.default.valid(osInstance.current) && osInstance.current.options(options);
      }, [options]), (0, import_react2.useEffect)(() => {
        import_overlayscrollbars.default.valid(osInstance.current) && mergeHostClassNames(osInstance.current, className);
      }, [className]), import_react2.default.createElement("div", { className: "os-host", ...rest, ref: osTargetRef }, import_react2.default.createElement("div", { className: "os-resize-observer-host" }), import_react2.default.createElement("div", { className: "os-padding" }, import_react2.default.createElement("div", { className: "os-viewport" }, import_react2.default.createElement("div", { className: "os-content" }, children))), import_react2.default.createElement("div", { className: "os-scrollbar os-scrollbar-horizontal " }, import_react2.default.createElement("div", { className: "os-scrollbar-track" }, import_react2.default.createElement("div", { className: "os-scrollbar-handle" }))), import_react2.default.createElement("div", { className: "os-scrollbar os-scrollbar-vertical" }, import_react2.default.createElement("div", { className: "os-scrollbar-track" }, import_react2.default.createElement("div", { className: "os-scrollbar-handle" }))), import_react2.default.createElement("div", { className: "os-scrollbar-corner" }));
    };
    OverlayScrollbars_default = OverlayScrollbarsComponent;
  }
});

// ../../node_modules/@storybook/components/dist/chunk-XGEY5Y7J.mjs
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
  }
  return target;
}
function _arrayLikeToArray(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!!o) {
    if (typeof o == "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
}
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _typeof(obj) {
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  return key = _toPropertyKey(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true }) : obj[key] = value, obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function powerSetPermutations(arr) {
  var arrLength = arr.length;
  if (arrLength === 0 || arrLength === 1)
    return arr;
  if (arrLength === 2)
    return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
  if (arrLength === 3)
    return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  if (arrLength >= 4)
    return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
}
function getClassNameCombinations(classNames) {
  if (classNames.length === 0 || classNames.length === 1)
    return classNames;
  var key = classNames.join(".");
  return classNameCombinations[key] || (classNameCombinations[key] = powerSetPermutations(classNames)), classNameCombinations[key];
}
function createStyleObject(classNames) {
  var elementStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, stylesheet = arguments.length > 2 ? arguments[2] : void 0, nonTokenClassNames = classNames.filter(function(className) {
    return className !== "token";
  }), classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
  return classNamesCombinations.reduce(function(styleObject, className) {
    return _objectSpread(_objectSpread({}, styleObject), stylesheet[className]);
  }, elementStyle);
}
function createClassNameString(classNames) {
  return classNames.join(" ");
}
function createChildren(stylesheet, useInlineStyles) {
  var childrenCount = 0;
  return function(children) {
    return childrenCount += 1, children.map(function(child, i) {
      return createElement({ node: child, stylesheet, useInlineStyles, key: "code-segment-".concat(childrenCount, "-").concat(i) });
    });
  };
}
function createElement(_ref) {
  var node = _ref.node, stylesheet = _ref.stylesheet, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key = _ref.key, properties = node.properties, type = node.type, TagName = node.tagName, value = node.value;
  if (type === "text")
    return value;
  if (TagName) {
    var childrenCreator = createChildren(stylesheet, useInlineStyles), props;
    if (!useInlineStyles)
      props = _objectSpread(_objectSpread({}, properties), {}, { className: createClassNameString(properties.className) });
    else {
      var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes, selector) {
        return selector.split(".").forEach(function(className2) {
          classes.includes(className2) || classes.push(className2);
        }), classes;
      }, []), startingClassName = properties.className && properties.className.includes("token") ? ["token"] : [], className = properties.className && startingClassName.concat(properties.className.filter(function(className2) {
        return !allStylesheetSelectors.includes(className2);
      }));
      props = _objectSpread(_objectSpread({}, properties), {}, { className: createClassNameString(className) || void 0, style: createStyleObject(properties.className, Object.assign({}, properties.style, style), stylesheet) });
    }
    var children = childrenCreator(node.children);
    return import_react5.default.createElement(TagName, _extends({ key }, props), children);
  }
}
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function getNewLines(str) {
  return str.match(newLineRegex);
}
function getAllLineNumbers(_ref) {
  var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style = _ref.style;
  return lines.map(function(_, i) {
    var number = i + startingLineNumber;
    return import_react4.default.createElement("span", { key: "line-".concat(i), className: "react-syntax-highlighter-line-number", style: typeof style == "function" ? style(number) : style }, "".concat(number, `
`));
  });
}
function AllLineNumbers(_ref2) {
  var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? { float: "left", paddingRight: "10px" } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
  return import_react4.default.createElement("code", { style: Object.assign({}, codeStyle, containerStyle) }, getAllLineNumbers({ lines: codeString.replace(/\n$/, "").split(`
`), style: numberStyle, startingLineNumber }));
}
function getEmWidthOfNumber(num) {
  return "".concat(num.toString().length, ".25em");
}
function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
  return { type: "element", tagName: "span", properties: { key: "line-number--".concat(lineNumber), className: ["comment", "linenumber", "react-syntax-highlighter-line-number"], style: inlineLineNumberStyle }, children: [{ type: "text", value: lineNumber }] };
}
function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
  var defaultLineNumberStyle = { display: "inline-block", minWidth: getEmWidthOfNumber(largestLineNumber), paddingRight: "1em", textAlign: "right", userSelect: "none" }, customLineNumberStyle = typeof lineNumberStyle == "function" ? lineNumberStyle(lineNumber) : lineNumberStyle, assembledStyle = _objectSpread2(_objectSpread2({}, defaultLineNumberStyle), customLineNumberStyle);
  return assembledStyle;
}
function createLineElement(_ref3) {
  var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines, properties = typeof lineProps == "function" ? lineProps(lineNumber) : lineProps;
  if (properties.className = className, lineNumber && showInlineLineNumbers) {
    var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
    children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
  }
  return wrapLongLines & showLineNumbers && (properties.style = _objectSpread2(_objectSpread2({}, properties.style), {}, { display: "flex" })), { type: "element", tagName: "span", properties, children };
}
function flattenCodeTree(tree) {
  for (var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], newTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], i = 0; i < tree.length; i++) {
    var node = tree[i];
    if (node.type === "text")
      newTree.push(createLineElement({ children: [node], className: _toConsumableArray(new Set(className)) }));
    else if (node.children) {
      var classNames = className.concat(node.properties.className);
      flattenCodeTree(node.children, classNames).forEach(function(i2) {
        return newTree.push(i2);
      });
    }
  }
  return newTree;
}
function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
  var _ref4, tree = flattenCodeTree(codeTree.value), newTree = [], lastLineBreakIndex = -1, index3 = 0;
  function createWrappedLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return createLineElement({ children: children2, lineNumber: lineNumber2, lineNumberStyle, largestLineNumber, showInlineLineNumbers, lineProps, className, showLineNumbers, wrapLongLines });
  }
  function createUnwrappedLine(children2, lineNumber2) {
    if (showLineNumbers && lineNumber2 && showInlineLineNumbers) {
      var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber2, largestLineNumber);
      children2.unshift(getInlineLineNumber(lineNumber2, inlineLineNumberStyle));
    }
    return children2;
  }
  function createLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return wrapLines || className.length > 0 ? createWrappedLine(children2, lineNumber2, className) : createUnwrappedLine(children2, lineNumber2);
  }
  for (var _loop = function() {
    var node = tree[index3], value = node.children[0].value, newLines = getNewLines(value);
    if (newLines) {
      var splitValue = value.split(`
`);
      splitValue.forEach(function(text, i) {
        var lineNumber2 = showLineNumbers && newTree.length + startingLineNumber, newChild = { type: "text", value: "".concat(text, `
`) };
        if (i === 0) {
          var _children = tree.slice(lastLineBreakIndex + 1, index3).concat(createLineElement({ children: [newChild], className: node.properties.className })), _line = createLine(_children, lineNumber2);
          newTree.push(_line);
        } else if (i === splitValue.length - 1) {
          var stringChild = tree[index3 + 1] && tree[index3 + 1].children && tree[index3 + 1].children[0], lastLineInPreviousSpan = { type: "text", value: "".concat(text) };
          if (stringChild) {
            var newElem = createLineElement({ children: [lastLineInPreviousSpan], className: node.properties.className });
            tree.splice(index3 + 1, 0, newElem);
          } else {
            var _children2 = [lastLineInPreviousSpan], _line2 = createLine(_children2, lineNumber2, node.properties.className);
            newTree.push(_line2);
          }
        } else {
          var _children3 = [newChild], _line3 = createLine(_children3, lineNumber2, node.properties.className);
          newTree.push(_line3);
        }
      }), lastLineBreakIndex = index3;
    }
    index3++;
  }; index3 < tree.length; )
    _loop();
  if (lastLineBreakIndex !== tree.length - 1) {
    var children = tree.slice(lastLineBreakIndex + 1, tree.length);
    if (children && children.length) {
      var lineNumber = showLineNumbers && newTree.length + startingLineNumber, line = createLine(children, lineNumber);
      newTree.push(line);
    }
  }
  return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
}
function defaultRenderer(_ref5) {
  var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
  return rows.map(function(node, i) {
    return createElement({ node, stylesheet, useInlineStyles, key: "code-segement".concat(i) });
  });
}
function isHighlightJs(astGenerator) {
  return astGenerator && typeof astGenerator.highlightAuto < "u";
}
function getCodeTree(_ref6) {
  var astGenerator = _ref6.astGenerator, language = _ref6.language, code = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
  if (isHighlightJs(astGenerator)) {
    var hasLanguage = checkForListedLanguage_default(astGenerator, language);
    return language === "text" ? { value: defaultCodeValue, language: "text" } : hasLanguage ? astGenerator.highlight(language, code) : astGenerator.highlightAuto(code);
  }
  try {
    return language && language !== "text" ? { value: astGenerator.highlight(code, language) } : { value: defaultCodeValue };
  } catch {
    return { value: defaultCodeValue };
  }
}
function highlight_default(defaultAstGenerator, defaultStyle) {
  return function(_ref7) {
    var language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style = _ref7$style === void 0 ? defaultStyle : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? { className: language ? "language-".concat(language) : void 0, style: _objectSpread2(_objectSpread2({}, style['code[class*="language-"]']), style['code[class*="language-'.concat(language, '"]')]) } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest = _objectWithoutProperties(_ref7, _excluded);
    astGenerator = astGenerator || defaultAstGenerator;
    var allLineNumbers = showLineNumbers ? import_react4.default.createElement(AllLineNumbers, { containerStyle: lineNumberContainerStyle, codeStyle: codeTagProps.style || {}, numberStyle: lineNumberStyle, startingLineNumber, codeString: code }) : null, defaultPreStyle = style.hljs || style['pre[class*="language-"]'] || { backgroundColor: "#fff" }, generatorClassName = isHighlightJs(astGenerator) ? "hljs" : "prismjs", preProps = useInlineStyles ? Object.assign({}, rest, { style: Object.assign({}, defaultPreStyle, customStyle) }) : Object.assign({}, rest, { className: rest.className ? "".concat(generatorClassName, " ").concat(rest.className) : generatorClassName, style: Object.assign({}, customStyle) });
    if (wrapLongLines ? codeTagProps.style = _objectSpread2(_objectSpread2({}, codeTagProps.style), {}, { whiteSpace: "pre-wrap" }) : codeTagProps.style = _objectSpread2(_objectSpread2({}, codeTagProps.style), {}, { whiteSpace: "pre" }), !astGenerator)
      return import_react4.default.createElement(PreTag, preProps, allLineNumbers, import_react4.default.createElement(CodeTag, codeTagProps, code));
    (wrapLines === void 0 && renderer || wrapLongLines) && (wrapLines = true), renderer = renderer || defaultRenderer;
    var defaultCodeValue = [{ type: "text", value: code }], codeTree = getCodeTree({ astGenerator, language, code, defaultCodeValue });
    codeTree.language === null && (codeTree.value = defaultCodeValue);
    var largestLineNumber = codeTree.value.length + startingLineNumber, rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
    return import_react4.default.createElement(PreTag, preProps, import_react4.default.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({ rows, stylesheet: style, useInlineStyles })));
  };
}
function createCopyToClipboardFunction() {
  return (navigator2 == null ? void 0 : navigator2.clipboard) ? (text) => navigator2.clipboard.writeText(text) : async (text) => {
    let tmp = document2.createElement("TEXTAREA"), focus = document2.activeElement;
    tmp.value = text, document2.body.appendChild(tmp), tmp.select(), document2.execCommand("copy"), document2.body.removeChild(tmp), focus.focus();
  };
}
var import_react3, import_theming3, import_memoizerific, import_react4, import_react5, import_react6, import_theming4, import_react7, import_theming5, import_global2, import_jsx, jsx_default, import_bash, bash_default, import_css, css_default, import_js_extras, js_extras_default, import_json, json_default, import_graphql, graphql_default, import_markup, markup_default, import_markdown, markdown_default, import_yaml, yaml_default, import_tsx, tsx_default, import_typescript, typescript_default, classNameCombinations, checkForListedLanguage_default, _excluded, newLineRegex, import_core, SyntaxHighlighter, prism_light_default, Container, ActionButton, ActionBar, GlobalScrollAreaStyles2, OverlayScrollbars, Scroller, ScrollArea, navigator2, document2, globalWindow, themedSyntax, copyToClipboard, Wrapper, UnstyledScroller, Scroller2, Pre, Code, processLineNumber, defaultRenderer2, wrapRenderer, SyntaxHighlighter2, syntaxhighlighter_default;
var init_chunk_XGEY5Y7J = __esm({
  "../../node_modules/@storybook/components/dist/chunk-XGEY5Y7J.mjs"() {
    init_chunk_4REFJGR7();
    init_chunk_S72H4O6B();
    init_chunk_CR4N7OJN();
    init_chunk_Q5VTUGLN();
    init_chunk_XWWAUDHM();
    init_chunk_6GBBAFYE();
    init_chunk_R5KWTIWY();
    init_chunk_7K7XSER6();
    init_chunk_YTVVV3IZ();
    init_chunk_HNIG72LA();
    init_chunk_3UNGU6BL();
    init_chunk_EU3NKDVB();
    init_chunk_I3OL67LK();
    init_chunk_NNAAFZ4U();
    import_react3 = __toESM(require("react"), 1);
    init_dist();
    import_theming3 = require("@storybook/theming");
    import_memoizerific = __toESM(require_memoizerific(), 1);
    import_react4 = __toESM(require("react"), 1);
    import_react5 = __toESM(require("react"), 1);
    import_react6 = __toESM(require("react"), 1);
    import_theming4 = require("@storybook/theming");
    import_react7 = __toESM(require("react"), 1);
    import_theming5 = require("@storybook/theming");
    import_global2 = __toESM2(require_window());
    import_jsx = __toESM2(require_jsx());
    jsx_default = import_jsx.default;
    import_bash = __toESM2(require_bash());
    bash_default = import_bash.default;
    import_css = __toESM2(require_css());
    css_default = import_css.default;
    import_js_extras = __toESM2(require_js_extras());
    js_extras_default = import_js_extras.default;
    import_json = __toESM2(require_json());
    json_default = import_json.default;
    import_graphql = __toESM2(require_graphql());
    graphql_default = import_graphql.default;
    import_markup = __toESM2(require_markup());
    markup_default = import_markup.default;
    import_markdown = __toESM2(require_markdown());
    markdown_default = import_markdown.default;
    import_yaml = __toESM2(require_yaml());
    yaml_default = import_yaml.default;
    import_tsx = __toESM2(require_tsx());
    tsx_default = import_tsx.default;
    import_typescript = __toESM2(require_typescript());
    typescript_default = import_typescript.default;
    classNameCombinations = {};
    checkForListedLanguage_default = function(astGenerator, language) {
      var langs = astGenerator.listLanguages();
      return langs.indexOf(language) !== -1;
    };
    _excluded = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
    newLineRegex = /\n/g;
    import_core = __toESM2(require_core());
    SyntaxHighlighter = highlight_default(import_core.default, {});
    SyntaxHighlighter.registerLanguage = function(_, language) {
      return import_core.default.register(language);
    };
    SyntaxHighlighter.alias = function(name, aliases) {
      return import_core.default.alias(name, aliases);
    };
    prism_light_default = SyntaxHighlighter;
    Container = import_theming4.styled.div(({ theme }) => ({ position: "absolute", bottom: 0, right: 0, maxWidth: "100%", display: "flex", background: theme.background.content, zIndex: 1 }));
    ActionButton = import_theming4.styled.button(({ theme }) => ({ margin: 0, border: "0 none", padding: "4px 10px", cursor: "pointer", display: "flex", alignItems: "center", color: theme.color.defaultText, background: theme.background.content, fontSize: 12, lineHeight: "16px", fontFamily: theme.typography.fonts.base, fontWeight: theme.typography.weight.bold, borderTop: `1px solid ${theme.appBorderColor}`, borderLeft: `1px solid ${theme.appBorderColor}`, marginLeft: -1, borderRadius: "4px 0 0 0", "&:not(:last-child)": { borderRight: `1px solid ${theme.appBorderColor}` }, "& + *": { borderLeft: `1px solid ${theme.appBorderColor}`, borderRadius: 0 }, "&:focus": { boxShadow: `${theme.color.secondary} 0 -3px 0 0 inset`, outline: "0 none" } }), ({ disabled }) => disabled && { cursor: "not-allowed", opacity: 0.5 });
    ActionButton.displayName = "ActionButton";
    ActionBar = ({ actionItems, ...props }) => import_react6.default.createElement(Container, { ...props }, actionItems.map(({ title, className, onClick, disabled }, index3) => import_react6.default.createElement(ActionButton, { key: index3, className, onClick, disabled }, title)));
    GlobalScrollAreaStyles2 = (0, import_react7.lazy)(() => Promise.resolve().then(() => (init_GlobalScrollAreaStyles_XIHNDKUY(), GlobalScrollAreaStyles_XIHNDKUY_exports)));
    OverlayScrollbars = (0, import_react7.lazy)(() => Promise.resolve().then(() => (init_OverlayScrollbars_VWTZRU7C(), OverlayScrollbars_VWTZRU7C_exports)));
    Scroller = ({ horizontal, vertical, ...props }) => import_react7.default.createElement(import_react7.Suspense, { fallback: import_react7.default.createElement("div", { ...props }) }, import_react7.default.createElement(GlobalScrollAreaStyles2, null), import_react7.default.createElement(OverlayScrollbars, { options: { scrollbars: { autoHide: "leave" } }, ...props }));
    ScrollArea = (0, import_theming5.styled)(Scroller)(({ vertical }) => vertical ? { overflowY: "auto", height: "100%" } : { overflowY: "hidden" }, ({ horizontal }) => horizontal ? { overflowX: "auto", width: "100%" } : { overflowX: "hidden" });
    ScrollArea.defaultProps = { horizontal: false, vertical: false };
    ({ navigator: navigator2, document: document2, window: globalWindow } = import_global2.default);
    prism_light_default.registerLanguage("jsextra", js_extras_default);
    prism_light_default.registerLanguage("jsx", jsx_default);
    prism_light_default.registerLanguage("json", json_default);
    prism_light_default.registerLanguage("yml", yaml_default);
    prism_light_default.registerLanguage("md", markdown_default);
    prism_light_default.registerLanguage("bash", bash_default);
    prism_light_default.registerLanguage("css", css_default);
    prism_light_default.registerLanguage("html", markup_default);
    prism_light_default.registerLanguage("tsx", tsx_default);
    prism_light_default.registerLanguage("typescript", typescript_default);
    prism_light_default.registerLanguage("graphql", graphql_default);
    themedSyntax = (0, import_memoizerific.default)(2)((theme) => Object.entries(theme.code || {}).reduce((acc, [key, val]) => ({ ...acc, [`* .${key}`]: val }), {}));
    copyToClipboard = createCopyToClipboardFunction();
    Wrapper = import_theming3.styled.div(({ theme }) => ({ position: "relative", overflow: "hidden", color: theme.color.defaultText }), ({ theme, bordered }) => bordered ? { border: `1px solid ${theme.appBorderColor}`, borderRadius: theme.borderRadius, background: theme.background.content } : {}, ({ showLineNumbers }) => showLineNumbers ? { ".react-syntax-highlighter-line-number::before": { content: "attr(data-line-number)" } } : {});
    UnstyledScroller = ({ children, className }) => import_react3.default.createElement(ScrollArea, { horizontal: true, vertical: true, className }, children);
    Scroller2 = (0, import_theming3.styled)(UnstyledScroller)({ position: "relative" }, ({ theme }) => themedSyntax(theme));
    Pre = import_theming3.styled.pre(({ theme, padded }) => ({ display: "flex", justifyContent: "flex-start", margin: 0, padding: padded ? theme.layoutMargin : 0 }));
    Code = import_theming3.styled.div(({ theme }) => ({ flex: 1, paddingLeft: 2, paddingRight: theme.layoutMargin, opacity: 1 }));
    processLineNumber = (row) => {
      let children = [...row.children], lineNumberNode = children[0], lineNumber = lineNumberNode.children[0].value, processedLineNumberNode = { ...lineNumberNode, children: [], properties: { ...lineNumberNode.properties, "data-line-number": lineNumber, style: { ...lineNumberNode.properties.style, userSelect: "auto" } } };
      return children[0] = processedLineNumberNode, { ...row, children };
    };
    defaultRenderer2 = ({ rows, stylesheet, useInlineStyles }) => rows.map((node, i) => createElement({ node: processLineNumber(node), stylesheet, useInlineStyles, key: `code-segement${i}` }));
    wrapRenderer = (renderer, showLineNumbers) => showLineNumbers ? renderer ? ({ rows, ...rest }) => renderer({ rows: rows.map((row) => processLineNumber(row)), ...rest }) : defaultRenderer2 : renderer;
    SyntaxHighlighter2 = ({ children, language = "jsx", copyable = false, bordered = false, padded = false, format: format3 = true, formatter: formatter2 = null, className = null, showLineNumbers = false, ...rest }) => {
      if (typeof children != "string" || !children.trim())
        return null;
      let highlightableCode = formatter2 ? formatter2(format3, children) : children.trim(), [copied, setCopied] = (0, import_react3.useState)(false), onClick = (0, import_react3.useCallback)((e) => {
        e.preventDefault(), copyToClipboard(highlightableCode).then(() => {
          setCopied(true), globalWindow.setTimeout(() => setCopied(false), 1500);
        }).catch(logger.error);
      }, [highlightableCode]), renderer = wrapRenderer(rest.renderer, showLineNumbers);
      return import_react3.default.createElement(Wrapper, { bordered, padded, showLineNumbers, className }, import_react3.default.createElement(Scroller2, null, import_react3.default.createElement(prism_light_default, { padded: padded || bordered, language, showLineNumbers, showInlineLineNumbers: showLineNumbers, useInlineStyles: false, PreTag: Pre, CodeTag: Code, lineNumberContainerStyle: {}, ...rest, renderer }, highlightableCode)), copyable ? import_react3.default.createElement(ActionBar, { actionItems: [{ title: copied ? "Copied" : "Copy", onClick }] }) : null);
    };
    syntaxhighlighter_default = SyntaxHighlighter2;
  }
});

// ../../node_modules/@storybook/components/dist/chunk-4V2BRVWI.mjs
function _setPrototypeOf(o, p) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o2, p2) {
    return o2.__proto__ = p2, o2;
  }, _setPrototypeOf(o, p);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype), subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass);
}
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null)
    return window;
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument && ownerDocument.defaultView || window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot > "u")
    return false;
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {}, attributes = state.attributes[name] || {}, element = state.elements[name];
    !isHTMLElement(element) || !getNodeName(element) || (Object.assign(element.style, style), Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      value === false ? element.removeAttribute(name2) : element.setAttribute(name2, value === true ? "" : value);
    }));
  });
}
function effect(_ref2) {
  var state = _ref2.state, initialStyles = { popper: { position: state.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(state.elements.popper.style, initialStyles.popper), state.styles = initialStyles, state.elements.arrow && Object.assign(state.elements.arrow.style, initialStyles.arrow), function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name], attributes = state.attributes[name] || {}, styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]), style = styleProperties.reduce(function(style2, property) {
        return style2[property] = "", style2;
      }, {});
      !isHTMLElement(element) || !getNodeName(element) || (Object.assign(element.style, style), Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      }));
    });
  };
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function getUAString() {
  var uaData = navigator.userAgentData;
  return uaData != null && uaData.brands ? uaData.brands.map(function(item) {
    return item.brand + "/" + item.version;
  }).join(" ") : navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  includeScale === void 0 && (includeScale = false), isFixedStrategy === void 0 && (isFixedStrategy = false);
  var clientRect = element.getBoundingClientRect(), scaleX = 1, scaleY = 1;
  includeScale && isHTMLElement(element) && (scaleX = element.offsetWidth > 0 && round(clientRect.width) / element.offsetWidth || 1, scaleY = element.offsetHeight > 0 && round(clientRect.height) / element.offsetHeight || 1);
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport, addVisualOffsets = !isLayoutViewport() && isFixedStrategy, x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX, y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY, width = clientRect.width / scaleX, height = clientRect.height / scaleY;
  return { width, height, top: y, right: x + width, bottom: y + height, left: x, x, y };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element), width = element.offsetWidth, height = element.offsetHeight;
  return Math.abs(clientRect.width - width) <= 1 && (width = clientRect.width), Math.abs(clientRect.height - height) <= 1 && (height = clientRect.height), { x: element.offsetLeft, y: element.offsetTop, width, height };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child))
    return true;
  if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next))
        return true;
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode(element) {
  return getNodeName(element) === "html" ? element : element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getTrueOffsetParent(element) {
  return !isHTMLElement(element) || getComputedStyle(element).position === "fixed" ? null : element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString()), isIE2 = /Trident/i.test(getUAString());
  if (isIE2 && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed")
      return null;
  }
  var currentNode = getParentNode(element);
  for (isShadowRoot(currentNode) && (currentNode = currentNode.host); isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0; ) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none")
      return currentNode;
    currentNode = currentNode.parentNode;
  }
  return null;
}
function getOffsetParent(element) {
  for (var window2 = getWindow(element), offsetParent = getTrueOffsetParent(element); offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static"; )
    offsetParent = getTrueOffsetParent(offsetParent);
  return offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static") ? window2 : offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    return hashMap[key] = value, hashMap;
  }, {});
}
function arrow(_ref) {
  var _state$modifiersData$, state = _ref.state, name = _ref.name, options = _ref.options, arrowElement = state.elements.arrow, popperOffsets2 = state.modifiersData.popperOffsets, basePlacement = getBasePlacement(state.placement), axis = getMainAxisFromPlacement(basePlacement), isVertical = [left, right].indexOf(basePlacement) >= 0, len = isVertical ? "height" : "width";
  if (!(!arrowElement || !popperOffsets2)) {
    var paddingObject = toPaddingObject(options.padding, state), arrowRect = getLayoutRect(arrowElement), minProp = axis === "y" ? top : left, maxProp = axis === "y" ? bottom : right, endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len], startDiff = popperOffsets2[axis] - state.rects.reference[axis], arrowOffsetParent = getOffsetParent(arrowElement), clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0, centerToReference = endDiff / 2 - startDiff / 2, min2 = paddingObject[minProp], max2 = clientSize - arrowRect[len] - paddingObject[maxProp], center = clientSize / 2 - arrowRect[len] / 2 + centerToReference, offset2 = within(min2, center, max2), axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options, _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement != null && !(typeof arrowElement == "string" && (arrowElement = state.elements.popper.querySelector(arrowElement), !arrowElement))) {
    if (isHTMLElement(arrowElement) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" ")), !contains(state.elements.popper, arrowElement)) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    state.elements.arrow = arrowElement;
  }
}
function getVariation(placement) {
  return placement.split("-")[1];
}
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y, win = window, dpr = win.devicePixelRatio || 1;
  return { x: round(x * dpr) / dpr || 0, y: round(y * dpr) / dpr || 0 };
}
function mapToStyles(_ref2) {
  var _Object$assign2, popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed, _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y, _ref3 = typeof roundOffsets == "function" ? roundOffsets({ x, y }) : { x, y };
  x = _ref3.x, y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x"), hasY = offsets.hasOwnProperty("y"), sideX = left, sideY = top, win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2), heightProp = "clientHeight", widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2) && (offsetParent = getDocumentElement(popper2), getComputedStyle(offsetParent).position !== "static" && position === "absolute" && (heightProp = "scrollHeight", widthProp = "scrollWidth")), offsetParent = offsetParent, placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height, y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width, x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({ position }, adaptive && unsetSides), _ref4 = roundOffsets === true ? roundOffsetsByDPR({ x, y }) : { x, y };
  if (x = _ref4.x, y = _ref4.y, gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options, _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || "";
    adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var commonStyles = { placement: getBasePlacement(state.placement), variation: getVariation(state.placement), popper: state.elements.popper, popperRect: state.rects.popper, gpuAcceleration, isFixed: state.options.strategy === "fixed" };
  state.modifiersData.popperOffsets != null && (state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, { offsets: state.modifiersData.popperOffsets, position: state.options.strategy, adaptive, roundOffsets })))), state.modifiersData.arrow != null && (state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, { offsets: state.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets })))), state.attributes.popper = Object.assign({}, state.attributes.popper, { "data-popper-placement": state.placement });
}
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options, _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize, window2 = getWindow(state.elements.popper), scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  return scroll && scrollParents.forEach(function(scrollParent) {
    scrollParent.addEventListener("scroll", instance.update, passive);
  }), resize && window2.addEventListener("resize", instance.update, passive), function() {
    scroll && scrollParents.forEach(function(scrollParent) {
      scrollParent.removeEventListener("scroll", instance.update, passive);
    }), resize && window2.removeEventListener("resize", instance.update, passive);
  };
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node), scrollLeft = win.pageXOffset, scrollTop = win.pageYOffset;
  return { scrollLeft, scrollTop };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element), html = getDocumentElement(element), visualViewport = win.visualViewport, width = html.clientWidth, height = html.clientHeight, x = 0, y = 0;
  if (visualViewport) {
    width = visualViewport.width, height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    (layoutViewport || !layoutViewport && strategy === "fixed") && (x = visualViewport.offsetLeft, y = visualViewport.offsetTop);
  }
  return { width, height, x: x + getWindowScrollBarX(element), y };
}
function getDocumentRect(element) {
  var _element$ownerDocumen, html = getDocumentElement(element), winScroll = getWindowScroll(element), body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body, width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0), height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0), x = -winScroll.scrollLeft + getWindowScrollBarX(element), y = -winScroll.scrollTop;
  return getComputedStyle(body || html).direction === "rtl" && (x += max(html.clientWidth, body ? body.clientWidth : 0) - width), { width, height, x, y };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  return ["html", "body", "#document"].indexOf(getNodeName(node)) >= 0 ? node.ownerDocument.body : isHTMLElement(node) && isScrollParent(node) ? node : getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  list === void 0 && (list = []);
  var scrollParent = getScrollParent(element), isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body), win = getWindow(scrollParent), target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent, updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, { left: rect.x, top: rect.y, right: rect.x + rect.width, bottom: rect.y + rect.height });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  return rect.top = rect.top + element.clientTop, rect.left = rect.left + element.clientLeft, rect.bottom = rect.top + element.clientHeight, rect.right = rect.left + element.clientWidth, rect.width = element.clientWidth, rect.height = element.clientHeight, rect.x = rect.left, rect.y = rect.top, rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element)), canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0, clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  return isElement(clipperElement) ? clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  }) : [];
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary), clippingParents2 = [].concat(mainClippingParents, [rootBoundary]), firstClippingParent = clippingParents2[0], clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    return accRect.top = max(rect.top, accRect.top), accRect.right = min(rect.right, accRect.right), accRect.bottom = min(rect.bottom, accRect.bottom), accRect.left = max(rect.left, accRect.left), accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  return clippingRect.width = clippingRect.right - clippingRect.left, clippingRect.height = clippingRect.bottom - clippingRect.top, clippingRect.x = clippingRect.left, clippingRect.y = clippingRect.top, clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement, basePlacement = placement ? getBasePlacement(placement) : null, variation = placement ? getVariation(placement) : null, commonX = reference2.x + reference2.width / 2 - element.width / 2, commonY = reference2.y + reference2.height / 2 - element.height / 2, offsets;
  switch (basePlacement) {
    case top:
      offsets = { x: commonX, y: reference2.y - element.height };
      break;
    case bottom:
      offsets = { x: commonX, y: reference2.y + reference2.height };
      break;
    case right:
      offsets = { x: reference2.x + reference2.width, y: commonY };
      break;
    case left:
      offsets = { x: reference2.x - element.width, y: commonY };
      break;
    default:
      offsets = { x: reference2.x, y: reference2.y };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  options === void 0 && (options = {});
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding, paddingObject = mergePaddingObject(typeof padding != "number" ? padding : expandToHashMap(padding, basePlacements)), altContext = elementContext === popper ? reference : popper, popperRect = state.rects.popper, element = state.elements[altBoundary ? altContext : elementContext], clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy), referenceClientRect = getBoundingClientRect(state.elements.reference), popperOffsets2 = computeOffsets({ reference: referenceClientRect, element: popperRect, strategy: "absolute", placement }), popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2)), elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect, overflowOffsets = { top: clippingClientRect.top - elementClientRect.top + paddingObject.top, bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom, left: clippingClientRect.left - elementClientRect.left + paddingObject.left, right: elementClientRect.right - clippingClientRect.right + paddingObject.right }, offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1, axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  options === void 0 && (options = {});
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP, variation = getVariation(placement), placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements, allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  allowedPlacements.length === 0 && (allowedPlacements = placements2, console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    return acc[placement2] = detectOverflow(state, { placement: placement2, boundary, rootBoundary, padding })[getBasePlacement(placement2)], acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto)
    return [];
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (!state.modifiersData[name]._skip) {
    for (var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements, preferredPlacement = state.options.placement, basePlacement = getBasePlacement(preferredPlacement), isBasePlacement = basePlacement === preferredPlacement, fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement)), placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, { placement: placement2, boundary, rootBoundary, padding, flipVariations, allowedAutoPlacements }) : placement2);
    }, []), referenceRect = state.rects.reference, popperRect = state.rects.popper, checksMap = /* @__PURE__ */ new Map(), makeFallbackChecks = true, firstFittingPlacement = placements2[0], i = 0; i < placements2.length; i++) {
      var placement = placements2[i], _basePlacement = getBasePlacement(placement), isStartVariation = getVariation(placement) === start, isVertical = [top, bottom].indexOf(_basePlacement) >= 0, len = isVertical ? "width" : "height", overflow = detectOverflow(state, { placement, boundary, rootBoundary, altBoundary, padding }), mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      referenceRect[len] > popperRect[len] && (mainVariationSide = getOppositePlacement(mainVariationSide));
      var altVariationSide = getOppositePlacement(mainVariationSide), checks = [];
      if (checkMainAxis && checks.push(overflow[_basePlacement] <= 0), checkAltAxis && checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0), checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement, makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks)
      for (var numberOfChecks = flipVariations ? 3 : 1, _loop = function(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2)
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
        });
        if (fittingPlacement)
          return firstFittingPlacement = fittingPlacement, "break";
      }, _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    state.placement !== firstFittingPlacement && (state.modifiersData[name]._skip = true, state.placement = firstFittingPlacement, state.reset = true);
  }
}
function getSideOffsets(overflow, rect, preventedOffsets) {
  return preventedOffsets === void 0 && (preventedOffsets = { x: 0, y: 0 }), { top: overflow.top - rect.height - preventedOffsets.y, right: overflow.right - rect.width + preventedOffsets.x, bottom: overflow.bottom - rect.height + preventedOffsets.y, left: overflow.left - rect.width - preventedOffsets.x };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name, referenceRect = state.rects.reference, popperRect = state.rects.popper, preventedOffsets = state.modifiersData.preventOverflow, referenceOverflow = detectOverflow(state, { elementContext: "reference" }), popperAltOverflow = detectOverflow(state, { altBoundary: true }), referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect), popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets), isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets), hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = { referenceClippingOffsets, popperEscapeOffsets, isReferenceHidden, hasPopperEscaped }, state.attributes.popper = Object.assign({}, state.attributes.popper, { "data-popper-reference-hidden": isReferenceHidden, "data-popper-escaped": hasPopperEscaped });
}
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement), invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1, _ref = typeof offset2 == "function" ? offset2(Object.assign({}, rects, { placement })) : offset2, skidding = _ref[0], distance = _ref[1];
  return skidding = skidding || 0, distance = (distance || 0) * invertDistance, [left, right].indexOf(basePlacement) >= 0 ? { x: distance, y: skidding } : { x: skidding, y: distance };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name, _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset, data = placements.reduce(function(acc, placement) {
    return acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2), acc;
  }, {}), _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  state.modifiersData.popperOffsets != null && (state.modifiersData.popperOffsets.x += x, state.modifiersData.popperOffsets.y += y), state.modifiersData[name] = data;
}
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({ reference: state.rects.reference, element: state.rects.popper, strategy: "absolute", placement: state.placement });
}
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name, _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset, overflow = detectOverflow(state, { boundary, rootBoundary, padding, altBoundary }), basePlacement = getBasePlacement(state.placement), variation = getVariation(state.placement), isBasePlacement = !variation, mainAxis = getMainAxisFromPlacement(basePlacement), altAxis = getAltAxis(mainAxis), popperOffsets2 = state.modifiersData.popperOffsets, referenceRect = state.rects.reference, popperRect = state.rects.popper, tetherOffsetValue = typeof tetherOffset == "function" ? tetherOffset(Object.assign({}, state.rects, { placement: state.placement })) : tetherOffset, normalizedTetherOffsetValue = typeof tetherOffsetValue == "number" ? { mainAxis: tetherOffsetValue, altAxis: tetherOffsetValue } : Object.assign({ mainAxis: 0, altAxis: 0 }, tetherOffsetValue), offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null, data = { x: 0, y: 0 };
  if (!!popperOffsets2) {
    if (checkMainAxis) {
      var _offsetModifierState$, mainSide = mainAxis === "y" ? top : left, altSide = mainAxis === "y" ? bottom : right, len = mainAxis === "y" ? "height" : "width", offset2 = popperOffsets2[mainAxis], min2 = offset2 + overflow[mainSide], max2 = offset2 - overflow[altSide], additive = tether ? -popperRect[len] / 2 : 0, minLen = variation === start ? referenceRect[len] : popperRect[len], maxLen = variation === start ? -popperRect[len] : -referenceRect[len], arrowElement = state.elements.arrow, arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : { width: 0, height: 0 }, arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject(), arrowPaddingMin = arrowPaddingObject[mainSide], arrowPaddingMax = arrowPaddingObject[altSide], arrowLen = within(0, referenceRect[len], arrowRect[len]), minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis, maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis, arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow), clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0, offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0, tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset, tetherMax = offset2 + maxOffset - offsetModifierValue, preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset, data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2, _mainSide = mainAxis === "x" ? top : left, _altSide = mainAxis === "x" ? bottom : right, _offset = popperOffsets2[altAxis], _len = altAxis === "y" ? "height" : "width", _min = _offset + overflow[_mainSide], _max = _offset - overflow[_altSide], isOriginSide = [top, left].indexOf(basePlacement) !== -1, _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0, _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis, _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max, _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset, data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
}
function getHTMLElementScroll(element) {
  return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop };
}
function getNodeScroll(node) {
  return node === getWindow(node) || !isHTMLElement(node) ? getWindowScroll(node) : getHTMLElementScroll(node);
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect(), scaleX = round(rect.width) / element.offsetWidth || 1, scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  isFixed === void 0 && (isFixed = false);
  var isOffsetParentAnElement = isHTMLElement(offsetParent), offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent), documentElement = getDocumentElement(offsetParent), rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed), scroll = { scrollLeft: 0, scrollTop: 0 }, offsets = { x: 0, y: 0 };
  return (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && ((getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) && (scroll = getNodeScroll(offsetParent)), isHTMLElement(offsetParent) ? (offsets = getBoundingClientRect(offsetParent, true), offsets.x += offsetParent.clientLeft, offsets.y += offsetParent.clientTop) : documentElement && (offsets.x = getWindowScrollBarX(documentElement))), { x: rect.left + scroll.scrollLeft - offsets.x, y: rect.top + scroll.scrollTop - offsets.y, width: rect.width, height: rect.height };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map(), visited = /* @__PURE__ */ new Set(), result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        depModifier && sort(depModifier);
      }
    }), result.push(modifier);
  }
  return modifiers.forEach(function(modifier) {
    visited.has(modifier.name) || sort(modifier);
  }), result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    return pending || (pending = new Promise(function(resolve) {
      Promise.resolve().then(function() {
        pending = void 0, resolve(fn2());
      });
    })), pending;
  };
}
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
    args[_key - 1] = arguments[_key];
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index3, self2) {
      return self2.indexOf(value) === index3;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          typeof modifier.name != "string" && console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          break;
        case "enabled":
          typeof modifier.enabled != "boolean" && console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          break;
        case "phase":
          modifierPhases.indexOf(modifier.phase) < 0 && console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          break;
        case "fn":
          typeof modifier.fn != "function" && console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          break;
        case "effect":
          modifier.effect != null && typeof modifier.effect != "function" && console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          break;
        case "requires":
          modifier.requires != null && !Array.isArray(modifier.requires) && console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(modifier.requiresIfExists) || console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null && console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
      });
    });
  });
}
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier))
      return identifiers.add(identifier), true;
  });
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    return merged2[current.name] = existing ? Object.assign({}, existing, current, { options: Object.assign({}, existing.options, current.options), data: Object.assign({}, existing.data, current.data) }) : current, merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
    args[_key] = arguments[_key];
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect == "function");
  });
}
function popperGenerator(generatorOptions) {
  generatorOptions === void 0 && (generatorOptions = {});
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function(reference2, popper2, options) {
    options === void 0 && (options = defaultOptions);
    var state = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions), modifiersData: {}, elements: { reference: reference2, popper: popper2 }, attributes: {}, styles: {} }, effectCleanupFns = [], isDestroyed = false, instance = { state, setOptions: function(setOptionsAction) {
      var options2 = typeof setOptionsAction == "function" ? setOptionsAction(state.options) : setOptionsAction;
      cleanupModifierEffects(), state.options = Object.assign({}, defaultOptions, state.options, options2), state.scrollParents = { reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [], popper: listScrollParents(popper2) };
      var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
      if (state.orderedModifiers = orderedModifiers.filter(function(m) {
        return m.enabled;
      }), true) {
        var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
          var name = _ref.name;
          return name;
        });
        if (validateModifiers(modifiers), getBasePlacement(state.options.placement) === auto) {
          var flipModifier = state.orderedModifiers.find(function(_ref2) {
            var name = _ref2.name;
            return name === "flip";
          });
          flipModifier || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
        }
        var _getComputedStyle = getComputedStyle(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
        [marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
          return parseFloat(margin);
        }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
      }
      return runModifierEffects(), instance.update();
    }, forceUpdate: function() {
      if (!isDestroyed) {
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          console.error(INVALID_ELEMENT_ERROR);
          return;
        }
        state.rects = { reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"), popper: getLayoutRect(popper3) }, state.reset = false, state.placement = state.options.placement, state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var __debug_loops__ = 0, index3 = 0; index3 < state.orderedModifiers.length; index3++) {
          if (__debug_loops__ += 1, __debug_loops__ > 100) {
            console.error(INFINITE_LOOP_ERROR);
            break;
          }
          if (state.reset === true) {
            state.reset = false, index3 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index3], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          typeof fn2 == "function" && (state = fn2({ state, options: _options, name, instance }) || state);
        }
      }
    }, update: debounce(function() {
      return new Promise(function(resolve) {
        instance.forceUpdate(), resolve(state);
      });
    }), destroy: function() {
      cleanupModifierEffects(), isDestroyed = true;
    } };
    if (!areValidElements(reference2, popper2))
      return console.error(INVALID_ELEMENT_ERROR), instance;
    instance.setOptions(options).then(function(state2) {
      !isDestroyed && options.onFirstUpdate && options.onFirstUpdate(state2);
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 == "function") {
          var cleanupFn = effect4({ state, name, instance, options: options2 }), noopFn = function() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      }), effectCleanupFns = [];
    }
    return instance;
  };
}
var top, bottom, right, left, auto, basePlacements, start, end, clippingParents, viewport, popper, reference, variationPlacements, placements, beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite, modifierPhases, applyStyles_default, max, min, round, toPaddingObject, arrow_default, unsetSides, computeStyles_default, passive, eventListeners_default, hash, hash2, flip_default, hide_default, offset_default, popperOffsets_default, preventOverflow_default, INVALID_MODIFIER_ERROR, MISSING_DEPENDENCY_ERROR, VALID_PROPERTIES, INVALID_ELEMENT_ERROR, INFINITE_LOOP_ERROR, DEFAULT_OPTIONS, defaultModifiers, createPopper;
var init_chunk_4V2BRVWI = __esm({
  "../../node_modules/@storybook/components/dist/chunk-4V2BRVWI.mjs"() {
    top = "top";
    bottom = "bottom";
    right = "right";
    left = "left";
    auto = "auto";
    basePlacements = [top, bottom, right, left];
    start = "start";
    end = "end";
    clippingParents = "clippingParents";
    viewport = "viewport";
    popper = "popper";
    reference = "reference";
    variationPlacements = basePlacements.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []);
    beforeRead = "beforeRead";
    read = "read";
    afterRead = "afterRead";
    beforeMain = "beforeMain";
    main = "main";
    afterMain = "afterMain";
    beforeWrite = "beforeWrite";
    write = "write";
    afterWrite = "afterWrite";
    modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
    applyStyles_default = { name: "applyStyles", enabled: true, phase: "write", fn: applyStyles, effect, requires: ["computeStyles"] };
    max = Math.max;
    min = Math.min;
    round = Math.round;
    toPaddingObject = function(padding, state) {
      return padding = typeof padding == "function" ? padding(Object.assign({}, state.rects, { placement: state.placement })) : padding, mergePaddingObject(typeof padding != "number" ? padding : expandToHashMap(padding, basePlacements));
    };
    arrow_default = { name: "arrow", enabled: true, phase: "main", fn: arrow, effect: effect2, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
    unsetSides = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
    computeStyles_default = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: computeStyles, data: {} };
    passive = { passive: true };
    eventListeners_default = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
    }, effect: effect3, data: {} };
    hash = { left: "right", right: "left", bottom: "top", top: "bottom" };
    hash2 = { start: "end", end: "start" };
    flip_default = { name: "flip", enabled: true, phase: "main", fn: flip, requiresIfExists: ["offset"], data: { _skip: false } };
    hide_default = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: hide };
    offset_default = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: offset };
    popperOffsets_default = { name: "popperOffsets", enabled: true, phase: "read", fn: popperOffsets, data: {} };
    preventOverflow_default = { name: "preventOverflow", enabled: true, phase: "main", fn: preventOverflow, requiresIfExists: ["offset"] };
    INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
    MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
    VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
    INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
    INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
    DEFAULT_OPTIONS = { placement: "bottom", modifiers: [], strategy: "absolute" };
    defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
    createPopper = popperGenerator({ defaultModifiers });
  }
});

// ../../node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "../../node_modules/lodash/_arrayReduce.js"(exports, module2) {
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index3 = -1, length2 = array == null ? 0 : array.length;
      if (initAccum && length2) {
        accumulator = array[++index3];
      }
      while (++index3 < length2) {
        accumulator = iteratee(accumulator, array[index3], index3, array);
      }
      return accumulator;
    }
    module2.exports = arrayReduce;
  }
});

// ../../node_modules/lodash/_basePropertyOf.js
var require_basePropertyOf = __commonJS({
  "../../node_modules/lodash/_basePropertyOf.js"(exports, module2) {
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    module2.exports = basePropertyOf;
  }
});

// ../../node_modules/lodash/_deburrLetter.js
var require_deburrLetter = __commonJS({
  "../../node_modules/lodash/_deburrLetter.js"(exports, module2) {
    var basePropertyOf = require_basePropertyOf();
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var deburrLetter = basePropertyOf(deburredLetters);
    module2.exports = deburrLetter;
  }
});

// ../../node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/lodash/_freeGlobal.js"(exports, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// ../../node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/lodash/_root.js"(exports, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// ../../node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/lodash/_Symbol.js"(exports, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// ../../node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "../../node_modules/lodash/_arrayMap.js"(exports, module2) {
    function arrayMap(array, iteratee) {
      var index3 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
      while (++index3 < length2) {
        result[index3] = iteratee(array[index3], index3, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// ../../node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../../node_modules/lodash/isArray.js"(exports, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// ../../node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/lodash/_getRawTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// ../../node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/lodash/_objectToString.js"(exports, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// ../../node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/lodash/_baseGetTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/lodash/isObjectLike.js"(exports, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// ../../node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "../../node_modules/lodash/isSymbol.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// ../../node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "../../node_modules/lodash/_baseToString.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// ../../node_modules/lodash/toString.js
var require_toString = __commonJS({
  "../../node_modules/lodash/toString.js"(exports, module2) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString;
  }
});

// ../../node_modules/lodash/deburr.js
var require_deburr = __commonJS({
  "../../node_modules/lodash/deburr.js"(exports, module2) {
    var deburrLetter = require_deburrLetter();
    var toString = require_toString();
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsCombo = "[" + rsComboRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module2.exports = deburr;
  }
});

// ../../node_modules/lodash/_asciiWords.js
var require_asciiWords = __commonJS({
  "../../node_modules/lodash/_asciiWords.js"(exports, module2) {
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    module2.exports = asciiWords;
  }
});

// ../../node_modules/lodash/_hasUnicodeWord.js
var require_hasUnicodeWord = __commonJS({
  "../../node_modules/lodash/_hasUnicodeWord.js"(exports, module2) {
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    module2.exports = hasUnicodeWord;
  }
});

// ../../node_modules/lodash/_unicodeWords.js
var require_unicodeWords = __commonJS({
  "../../node_modules/lodash/_unicodeWords.js"(exports, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
    var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    module2.exports = unicodeWords;
  }
});

// ../../node_modules/lodash/words.js
var require_words = __commonJS({
  "../../node_modules/lodash/words.js"(exports, module2) {
    var asciiWords = require_asciiWords();
    var hasUnicodeWord = require_hasUnicodeWord();
    var toString = require_toString();
    var unicodeWords = require_unicodeWords();
    function words(string, pattern, guard2) {
      string = toString(string);
      pattern = guard2 ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module2.exports = words;
  }
});

// ../../node_modules/lodash/_createCompounder.js
var require_createCompounder = __commonJS({
  "../../node_modules/lodash/_createCompounder.js"(exports, module2) {
    var arrayReduce = require_arrayReduce();
    var deburr = require_deburr();
    var words = require_words();
    var rsApos = "['\u2019]";
    var reApos = RegExp(rsApos, "g");
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    module2.exports = createCompounder;
  }
});

// ../../node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "../../node_modules/lodash/_baseSlice.js"(exports, module2) {
    function baseSlice(array, start2, end2) {
      var index3 = -1, length2 = array.length;
      if (start2 < 0) {
        start2 = -start2 > length2 ? 0 : length2 + start2;
      }
      end2 = end2 > length2 ? length2 : end2;
      if (end2 < 0) {
        end2 += length2;
      }
      length2 = start2 > end2 ? 0 : end2 - start2 >>> 0;
      start2 >>>= 0;
      var result = Array(length2);
      while (++index3 < length2) {
        result[index3] = array[index3 + start2];
      }
      return result;
    }
    module2.exports = baseSlice;
  }
});

// ../../node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "../../node_modules/lodash/_castSlice.js"(exports, module2) {
    var baseSlice = require_baseSlice();
    function castSlice(array, start2, end2) {
      var length2 = array.length;
      end2 = end2 === void 0 ? length2 : end2;
      return !start2 && end2 >= length2 ? array : baseSlice(array, start2, end2);
    }
    module2.exports = castSlice;
  }
});

// ../../node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "../../node_modules/lodash/_hasUnicode.js"(exports, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module2.exports = hasUnicode;
  }
});

// ../../node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "../../node_modules/lodash/_asciiToArray.js"(exports, module2) {
    function asciiToArray(string) {
      return string.split("");
    }
    module2.exports = asciiToArray;
  }
});

// ../../node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "../../node_modules/lodash/_unicodeToArray.js"(exports, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    module2.exports = unicodeToArray;
  }
});

// ../../node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "../../node_modules/lodash/_stringToArray.js"(exports, module2) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    module2.exports = stringToArray;
  }
});

// ../../node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "../../node_modules/lodash/_createCaseFirst.js"(exports, module2) {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString = require_toString();
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module2.exports = createCaseFirst;
  }
});

// ../../node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "../../node_modules/lodash/upperFirst.js"(exports, module2) {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module2.exports = upperFirst;
  }
});

// ../../node_modules/lodash/startCase.js
var require_startCase = __commonJS({
  "../../node_modules/lodash/startCase.js"(exports, module2) {
    var createCompounder = require_createCompounder();
    var upperFirst = require_upperFirst();
    var startCase2 = createCompounder(function(result, word, index3) {
      return result + (index3 ? " " : "") + upperFirst(word);
    });
    module2.exports = startCase2;
  }
});

// ../../node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "../../node_modules/lodash/_listCacheClear.js"(exports, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// ../../node_modules/lodash/eq.js
var require_eq = __commonJS({
  "../../node_modules/lodash/eq.js"(exports, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// ../../node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "../../node_modules/lodash/_assocIndexOf.js"(exports, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length2 = array.length;
      while (length2--) {
        if (eq(array[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// ../../node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "../../node_modules/lodash/_listCacheDelete.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      if (index3 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index3 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index3, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// ../../node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "../../node_modules/lodash/_listCacheGet.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      return index3 < 0 ? void 0 : data[index3][1];
    }
    module2.exports = listCacheGet;
  }
});

// ../../node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "../../node_modules/lodash/_listCacheHas.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// ../../node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "../../node_modules/lodash/_listCacheSet.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      if (index3 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index3][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// ../../node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "../../node_modules/lodash/_ListCache.js"(exports, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index3 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length2) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// ../../node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "../../node_modules/lodash/_stackClear.js"(exports, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// ../../node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "../../node_modules/lodash/_stackDelete.js"(exports, module2) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// ../../node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "../../node_modules/lodash/_stackGet.js"(exports, module2) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet;
  }
});

// ../../node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "../../node_modules/lodash/_stackHas.js"(exports, module2) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas;
  }
});

// ../../node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/lodash/isObject.js"(exports, module2) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject;
  }
});

// ../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/lodash/isFunction.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// ../../node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../../node_modules/lodash/_coreJsData.js"(exports, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// ../../node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../../node_modules/lodash/_isMasked.js"(exports, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// ../../node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../../node_modules/lodash/_toSource.js"(exports, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// ../../node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../../node_modules/lodash/_baseIsNative.js"(exports, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// ../../node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../../node_modules/lodash/_getValue.js"(exports, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// ../../node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../../node_modules/lodash/_getNative.js"(exports, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// ../../node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../../node_modules/lodash/_Map.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// ../../node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "../../node_modules/lodash/_nativeCreate.js"(exports, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// ../../node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "../../node_modules/lodash/_hashClear.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// ../../node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "../../node_modules/lodash/_hashDelete.js"(exports, module2) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// ../../node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "../../node_modules/lodash/_hashGet.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// ../../node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "../../node_modules/lodash/_hashHas.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// ../../node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "../../node_modules/lodash/_hashSet.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// ../../node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "../../node_modules/lodash/_Hash.js"(exports, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index3 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length2) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// ../../node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "../../node_modules/lodash/_mapCacheClear.js"(exports, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// ../../node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "../../node_modules/lodash/_isKeyable.js"(exports, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// ../../node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "../../node_modules/lodash/_getMapData.js"(exports, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// ../../node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "../../node_modules/lodash/_mapCacheDelete.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// ../../node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "../../node_modules/lodash/_mapCacheGet.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// ../../node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "../../node_modules/lodash/_mapCacheHas.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// ../../node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "../../node_modules/lodash/_mapCacheSet.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// ../../node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "../../node_modules/lodash/_MapCache.js"(exports, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index3 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length2) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// ../../node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "../../node_modules/lodash/_stackSet.js"(exports, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// ../../node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "../../node_modules/lodash/_Stack.js"(exports, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// ../../node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "../../node_modules/lodash/_setCacheAdd.js"(exports, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// ../../node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "../../node_modules/lodash/_setCacheHas.js"(exports, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// ../../node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "../../node_modules/lodash/_SetCache.js"(exports, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index3 = -1, length2 = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index3 < length2) {
        this.add(values[index3]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// ../../node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "../../node_modules/lodash/_arraySome.js"(exports, module2) {
    function arraySome(array, predicate) {
      var index3 = -1, length2 = array == null ? 0 : array.length;
      while (++index3 < length2) {
        if (predicate(array[index3], index3, array)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// ../../node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "../../node_modules/lodash/_cacheHas.js"(exports, module2) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas;
  }
});

// ../../node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "../../node_modules/lodash/_equalArrays.js"(exports, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index3 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index3 < arrLength) {
        var arrValue = array[index3], othValue = other[index3];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index3, other, array, stack) : customizer(arrValue, othValue, index3, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// ../../node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "../../node_modules/lodash/_Uint8Array.js"(exports, module2) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// ../../node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "../../node_modules/lodash/_mapToArray.js"(exports, module2) {
    function mapToArray(map) {
      var index3 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index3] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// ../../node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "../../node_modules/lodash/_setToArray.js"(exports, module2) {
    function setToArray(set) {
      var index3 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index3] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// ../../node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "../../node_modules/lodash/_equalByTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// ../../node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "../../node_modules/lodash/_arrayPush.js"(exports, module2) {
    function arrayPush(array, values) {
      var index3 = -1, length2 = values.length, offset2 = array.length;
      while (++index3 < length2) {
        array[offset2 + index3] = values[index3];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// ../../node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "../../node_modules/lodash/_baseGetAllKeys.js"(exports, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  }
});

// ../../node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "../../node_modules/lodash/_arrayFilter.js"(exports, module2) {
    function arrayFilter(array, predicate) {
      var index3 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index3 < length2) {
        var value = array[index3];
        if (predicate(value, index3, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// ../../node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "../../node_modules/lodash/stubArray.js"(exports, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// ../../node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "../../node_modules/lodash/_getSymbols.js"(exports, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// ../../node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../../node_modules/lodash/_baseTimes.js"(exports, module2) {
    function baseTimes(n, iteratee) {
      var index3 = -1, result = Array(n);
      while (++index3 < n) {
        result[index3] = iteratee(index3);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// ../../node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../../node_modules/lodash/_baseIsArguments.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// ../../node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/lodash/isArguments.js"(exports, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// ../../node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../../node_modules/lodash/stubFalse.js"(exports, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// ../../node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../../node_modules/lodash/isBuffer.js"(exports, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// ../../node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../../node_modules/lodash/_isIndex.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length2) {
      var type = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    module2.exports = isIndex;
  }
});

// ../../node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../../node_modules/lodash/isLength.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// ../../node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../../node_modules/lodash/_baseIsTypedArray.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// ../../node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../../node_modules/lodash/_baseUnary.js"(exports, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// ../../node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../../node_modules/lodash/_nodeUtil.js"(exports, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// ../../node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../../node_modules/lodash/isTypedArray.js"(exports, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// ../../node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../../node_modules/lodash/_arrayLikeKeys.js"(exports, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// ../../node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../../node_modules/lodash/_isPrototype.js"(exports, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// ../../node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../../node_modules/lodash/_overArg.js"(exports, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// ../../node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "../../node_modules/lodash/_nativeKeys.js"(exports, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// ../../node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "../../node_modules/lodash/_baseKeys.js"(exports, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// ../../node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../node_modules/lodash/isArrayLike.js"(exports, module2) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  }
});

// ../../node_modules/lodash/keys.js
var require_keys = __commonJS({
  "../../node_modules/lodash/keys.js"(exports, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// ../../node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "../../node_modules/lodash/_getAllKeys.js"(exports, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// ../../node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "../../node_modules/lodash/_equalObjects.js"(exports, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index3 = objLength;
      while (index3--) {
        var key = objProps[index3];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index3 < objLength) {
        key = objProps[index3];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// ../../node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "../../node_modules/lodash/_DataView.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView = getNative(root, "DataView");
    module2.exports = DataView;
  }
});

// ../../node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "../../node_modules/lodash/_Promise.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// ../../node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "../../node_modules/lodash/_Set.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// ../../node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "../../node_modules/lodash/_WeakMap.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module2.exports = WeakMap2;
  }
});

// ../../node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "../../node_modules/lodash/_getTag.js"(exports, module2) {
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// ../../node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "../../node_modules/lodash/_baseIsEqualDeep.js"(exports, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// ../../node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "../../node_modules/lodash/_baseIsEqual.js"(exports, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// ../../node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  "../../node_modules/lodash/isEqual.js"(exports, module2) {
    var baseIsEqual = require_baseIsEqual();
    function isEqual2(value, other) {
      return baseIsEqual(value, other);
    }
    module2.exports = isEqual2;
  }
});

// ../../node_modules/@storybook/components/dist/syntaxhighlighter-3EX6JOZ7.mjs
var syntaxhighlighter_3EX6JOZ7_exports = {};
__export(syntaxhighlighter_3EX6JOZ7_exports, {
  SyntaxHighlighter: () => SyntaxHighlighter2,
  createCopyToClipboardFunction: () => createCopyToClipboardFunction,
  default: () => syntaxhighlighter_default
});
var init_syntaxhighlighter_3EX6JOZ7 = __esm({
  "../../node_modules/@storybook/components/dist/syntaxhighlighter-3EX6JOZ7.mjs"() {
    init_chunk_XGEY5Y7J();
  }
});

// ../../node_modules/@storybook/components/dist/formatter-PK6264PW.mjs
var formatter_PK6264PW_exports = {};
__export(formatter_PK6264PW_exports, {
  formatter: () => formatter
});
function dedent(templ) {
  for (var values = [], _i = 1; _i < arguments.length; _i++)
    values[_i - 1] = arguments[_i];
  var strings = Array.from(typeof templ == "string" ? [templ] : templ);
  strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var indentLengths = strings.reduce(function(arr, str) {
    var matches = str.match(/\n([\t ]+|(?!\s).)/g);
    return matches ? arr.concat(matches.map(function(match2) {
      var _a, _b;
      return (_b = (_a = match2.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    })) : arr;
  }, []);
  if (indentLengths.length) {
    var pattern_1 = new RegExp(`
[	 ]{` + Math.min.apply(Math, indentLengths) + "}", "g");
    strings = strings.map(function(str) {
      return str.replace(pattern_1, `
`);
    });
  }
  strings[0] = strings[0].replace(/^\r?\n/, "");
  var string = strings[0];
  return values.forEach(function(value, i) {
    var endentations = string.match(/(?:^|\n)( *)$/), endentation = endentations ? endentations[1] : "", indentedValue = value;
    typeof value == "string" && value.includes(`
`) && (indentedValue = String(value).split(`
`).map(function(str, i2) {
      return i2 === 0 ? str : "" + endentation + str;
    }).join(`
`)), string += indentedValue + strings[i + 1];
  }), string;
}
var import_memoizerific2, require_parser_html, require_standalone, import_parser_html, import_standalone, formatter;
var init_formatter_PK6264PW = __esm({
  "../../node_modules/@storybook/components/dist/formatter-PK6264PW.mjs"() {
    init_chunk_NNAAFZ4U();
    import_memoizerific2 = __toESM(require_memoizerific(), 1);
    require_parser_html = __commonJS2({ "../../node_modules/prettier/parser-html.js"(exports, module2) {
      (function(e) {
        if (typeof exports == "object" && typeof module2 == "object")
          module2.exports = e();
        else if (typeof define == "function" && define.amd)
          define(e);
        else {
          var i = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
          i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.html = e();
        }
      })(function() {
        "use strict";
        var y = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports), G = y((uc, Hr) => {
          var be = function(e) {
            return e && e.Math == Math && e;
          };
          Hr.exports = be(typeof globalThis == "object" && globalThis) || be(typeof window == "object" && window) || be(typeof self == "object" && self) || be(typeof global == "object" && global) || function() {
            return this;
          }() || Function("return this")();
        }), se = y((tc, zr) => {
          zr.exports = function(e) {
            try {
              return !!e();
            } catch {
              return true;
            }
          };
        }), oe = y((nc, Wr) => {
          var As = se();
          Wr.exports = !As(function() {
            return Object.defineProperty({}, 1, { get: function() {
              return 7;
            } })[1] != 7;
          });
        }), we = y((sc, Yr) => {
          var vs = se();
          Yr.exports = !vs(function() {
            var e = function() {
            }.bind();
            return typeof e != "function" || e.hasOwnProperty("prototype");
          });
        }), De = y((ic, Qr) => {
          var _s = we(), Ne = Function.prototype.call;
          Qr.exports = _s ? Ne.bind(Ne) : function() {
            return Ne.apply(Ne, arguments);
          };
        }), eu = y((Zr) => {
          "use strict";
          var Kr = {}.propertyIsEnumerable, Jr = Object.getOwnPropertyDescriptor, Ss = Jr && !Kr.call({ 1: 2 }, 1);
          Zr.f = Ss ? function(r) {
            var u = Jr(this, r);
            return !!u && u.enumerable;
          } : Kr;
        }), Oe = y((oc, ru) => {
          ru.exports = function(e, r) {
            return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r };
          };
        }), Q = y((Dc, nu) => {
          var uu = we(), tu = Function.prototype, ys = tu.bind, Ze = tu.call, Ts = uu && ys.bind(Ze, Ze);
          nu.exports = uu ? function(e) {
            return e && Ts(e);
          } : function(e) {
            return e && function() {
              return Ze.apply(e, arguments);
            };
          };
        }), qe = y((lc, iu) => {
          var su = Q(), Bs = su({}.toString), bs = su("".slice);
          iu.exports = function(e) {
            return bs(Bs(e), 8, -1);
          };
        }), ou = y((cc, au) => {
          var ws = G(), Ns = Q(), Os = se(), qs = qe(), er = ws.Object, Is = Ns("".split);
          au.exports = Os(function() {
            return !er("z").propertyIsEnumerable(0);
          }) ? function(e) {
            return qs(e) == "String" ? Is(e, "") : er(e);
          } : er;
        }), rr = y((hc, Du) => {
          var Rs = G(), xs = Rs.TypeError;
          Du.exports = function(e) {
            if (e == null)
              throw xs("Can't call method on " + e);
            return e;
          };
        }), Ie = y((pc, lu) => {
          var Ps = ou(), ks = rr();
          lu.exports = function(e) {
            return Ps(ks(e));
          };
        }), K = y((fc, cu) => {
          cu.exports = function(e) {
            return typeof e == "function";
          };
        }), le = y((dc, hu) => {
          var Ls = K();
          hu.exports = function(e) {
            return typeof e == "object" ? e !== null : Ls(e);
          };
        }), me = y((Ec, pu) => {
          var ur = G(), $s = K(), Ms = function(e) {
            return $s(e) ? e : void 0;
          };
          pu.exports = function(e, r) {
            return arguments.length < 2 ? Ms(ur[e]) : ur[e] && ur[e][r];
          };
        }), tr = y((Cc, fu) => {
          var js = Q();
          fu.exports = js({}.isPrototypeOf);
        }), Eu = y((mc, du) => {
          var Us = me();
          du.exports = Us("navigator", "userAgent") || "";
        }), _u = y((gc, vu) => {
          var Au = G(), nr = Eu(), Cu = Au.process, mu = Au.Deno, gu = Cu && Cu.versions || mu && mu.version, Fu = gu && gu.v8, ue, Re;
          Fu && (ue = Fu.split("."), Re = ue[0] > 0 && ue[0] < 4 ? 1 : +(ue[0] + ue[1])), !Re && nr && (ue = nr.match(/Edge\/(\d+)/), (!ue || ue[1] >= 74) && (ue = nr.match(/Chrome\/(\d+)/), ue && (Re = +ue[1]))), vu.exports = Re;
        }), sr = y((Fc, yu) => {
          var Su = _u(), Gs = se();
          yu.exports = !!Object.getOwnPropertySymbols && !Gs(function() {
            var e = Symbol();
            return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Su && Su < 41;
          });
        }), ir = y((Ac, Tu) => {
          var Vs = sr();
          Tu.exports = Vs && !Symbol.sham && typeof Symbol.iterator == "symbol";
        }), ar = y((vc, Bu) => {
          var Xs = G(), Hs = me(), zs = K(), Ws = tr(), Ys = ir(), Qs = Xs.Object;
          Bu.exports = Ys ? function(e) {
            return typeof e == "symbol";
          } : function(e) {
            var r = Hs("Symbol");
            return zs(r) && Ws(r.prototype, Qs(e));
          };
        }), xe = y((_c, bu) => {
          var Ks = G(), Js = Ks.String;
          bu.exports = function(e) {
            try {
              return Js(e);
            } catch {
              return "Object";
            }
          };
        }), ge = y((Sc, wu) => {
          var Zs = G(), ei = K(), ri = xe(), ui = Zs.TypeError;
          wu.exports = function(e) {
            if (ei(e))
              return e;
            throw ui(ri(e) + " is not a function");
          };
        }), Pe = y((yc, Nu) => {
          var ti = ge();
          Nu.exports = function(e, r) {
            var u = e[r];
            return u == null ? void 0 : ti(u);
          };
        }), qu = y((Tc, Ou) => {
          var ni = G(), or = De(), Dr = K(), lr = le(), si = ni.TypeError;
          Ou.exports = function(e, r) {
            var u, s;
            if (r === "string" && Dr(u = e.toString) && !lr(s = or(u, e)) || Dr(u = e.valueOf) && !lr(s = or(u, e)) || r !== "string" && Dr(u = e.toString) && !lr(s = or(u, e)))
              return s;
            throw si("Can't convert object to primitive value");
          };
        }), Ru = y((Bc, Iu) => {
          Iu.exports = false;
        }), ke = y((bc, Pu) => {
          var xu = G(), ii = Object.defineProperty;
          Pu.exports = function(e, r) {
            try {
              ii(xu, e, { value: r, configurable: true, writable: true });
            } catch {
              xu[e] = r;
            }
            return r;
          };
        }), Le = y((wc, Lu) => {
          var ai = G(), oi = ke(), ku = "__core-js_shared__", Di = ai[ku] || oi(ku, {});
          Lu.exports = Di;
        }), cr = y((Nc, Mu) => {
          var li = Ru(), $u = Le();
          (Mu.exports = function(e, r) {
            return $u[e] || ($u[e] = r !== void 0 ? r : {});
          })("versions", []).push({ version: "3.22.2", mode: li ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
        }), hr = y((Oc, ju) => {
          var ci = G(), hi = rr(), pi = ci.Object;
          ju.exports = function(e) {
            return pi(hi(e));
          };
        }), ie = y((qc, Uu) => {
          var fi = Q(), di = hr(), Ei = fi({}.hasOwnProperty);
          Uu.exports = Object.hasOwn || function(r, u) {
            return Ei(di(r), u);
          };
        }), pr = y((Ic, Gu) => {
          var Ci = Q(), mi = 0, gi = Math.random(), Fi = Ci(1 .toString);
          Gu.exports = function(e) {
            return "Symbol(" + (e === void 0 ? "" : e) + ")_" + Fi(++mi + gi, 36);
          };
        }), he = y((Rc, Wu) => {
          var Ai = G(), vi = cr(), Vu = ie(), _i = pr(), Xu = sr(), zu = ir(), fe = vi("wks"), ce = Ai.Symbol, Hu = ce && ce.for, Si = zu ? ce : ce && ce.withoutSetter || _i;
          Wu.exports = function(e) {
            if (!Vu(fe, e) || !(Xu || typeof fe[e] == "string")) {
              var r = "Symbol." + e;
              Xu && Vu(ce, e) ? fe[e] = ce[e] : zu && Hu ? fe[e] = Hu(r) : fe[e] = Si(r);
            }
            return fe[e];
          };
        }), Ju = y((xc, Ku) => {
          var yi = G(), Ti = De(), Yu = le(), Qu = ar(), Bi = Pe(), bi = qu(), wi = he(), Ni = yi.TypeError, Oi = wi("toPrimitive");
          Ku.exports = function(e, r) {
            if (!Yu(e) || Qu(e))
              return e;
            var u = Bi(e, Oi), s;
            if (u) {
              if (r === void 0 && (r = "default"), s = Ti(u, e, r), !Yu(s) || Qu(s))
                return s;
              throw Ni("Can't convert object to primitive value");
            }
            return r === void 0 && (r = "number"), bi(e, r);
          };
        }), $e = y((Pc, Zu) => {
          var qi = Ju(), Ii = ar();
          Zu.exports = function(e) {
            var r = qi(e, "string");
            return Ii(r) ? r : r + "";
          };
        }), ut = y((kc, rt) => {
          var Ri = G(), et = le(), fr = Ri.document, xi = et(fr) && et(fr.createElement);
          rt.exports = function(e) {
            return xi ? fr.createElement(e) : {};
          };
        }), dr = y((Lc, tt) => {
          var Pi = oe(), ki = se(), Li = ut();
          tt.exports = !Pi && !ki(function() {
            return Object.defineProperty(Li("div"), "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        }), Er = y((st) => {
          var $i = oe(), Mi = De(), ji = eu(), Ui = Oe(), Gi = Ie(), Vi = $e(), Xi = ie(), Hi = dr(), nt = Object.getOwnPropertyDescriptor;
          st.f = $i ? nt : function(r, u) {
            if (r = Gi(r), u = Vi(u), Hi)
              try {
                return nt(r, u);
              } catch {
              }
            if (Xi(r, u))
              return Ui(!Mi(ji.f, r, u), r[u]);
          };
        }), at = y((Mc, it) => {
          var zi = oe(), Wi = se();
          it.exports = zi && Wi(function() {
            return Object.defineProperty(function() {
            }, "prototype", { value: 42, writable: false }).prototype != 42;
          });
        }), de = y((jc, Dt) => {
          var ot = G(), Yi = le(), Qi = ot.String, Ki = ot.TypeError;
          Dt.exports = function(e) {
            if (Yi(e))
              return e;
            throw Ki(Qi(e) + " is not an object");
          };
        }), je = y((ct) => {
          var Ji = G(), Zi = oe(), ea = dr(), ra = at(), Me = de(), lt = $e(), ua = Ji.TypeError, Cr = Object.defineProperty, ta = Object.getOwnPropertyDescriptor, mr = "enumerable", gr = "configurable", Fr = "writable";
          ct.f = Zi ? ra ? function(r, u, s) {
            if (Me(r), u = lt(u), Me(s), typeof r == "function" && u === "prototype" && "value" in s && Fr in s && !s[Fr]) {
              var D = ta(r, u);
              D && D[Fr] && (r[u] = s.value, s = { configurable: gr in s ? s[gr] : D[gr], enumerable: mr in s ? s[mr] : D[mr], writable: false });
            }
            return Cr(r, u, s);
          } : Cr : function(r, u, s) {
            if (Me(r), u = lt(u), Me(s), ea)
              try {
                return Cr(r, u, s);
              } catch {
              }
            if ("get" in s || "set" in s)
              throw ua("Accessors not supported");
            return "value" in s && (r[u] = s.value), r;
          };
        }), Ue = y((Gc, ht) => {
          var na = oe(), sa = je(), ia = Oe();
          ht.exports = na ? function(e, r, u) {
            return sa.f(e, r, ia(1, u));
          } : function(e, r, u) {
            return e[r] = u, e;
          };
        }), Ge = y((Vc, pt) => {
          var aa = Q(), oa = K(), Ar = Le(), Da = aa(Function.toString);
          oa(Ar.inspectSource) || (Ar.inspectSource = function(e) {
            return Da(e);
          }), pt.exports = Ar.inspectSource;
        }), Et = y((Xc, dt) => {
          var la = G(), ca = K(), ha = Ge(), ft = la.WeakMap;
          dt.exports = ca(ft) && /native code/.test(ha(ft));
        }), gt = y((Hc, mt) => {
          var pa = cr(), fa = pr(), Ct = pa("keys");
          mt.exports = function(e) {
            return Ct[e] || (Ct[e] = fa(e));
          };
        }), vr = y((zc, Ft) => {
          Ft.exports = {};
        }), Tt = y((Wc, yt) => {
          var da = Et(), St = G(), _r = Q(), Ea = le(), Ca = Ue(), Sr = ie(), yr = Le(), ma = gt(), ga = vr(), At = "Object already initialized", Br = St.TypeError, Fa = St.WeakMap, Ve, Fe, Xe, Aa = function(e) {
            return Xe(e) ? Fe(e) : Ve(e, {});
          }, va = function(e) {
            return function(r) {
              var u;
              if (!Ea(r) || (u = Fe(r)).type !== e)
                throw Br("Incompatible receiver, " + e + " required");
              return u;
            };
          };
          da || yr.state ? (ae = yr.state || (yr.state = new Fa()), vt = _r(ae.get), Tr = _r(ae.has), _t = _r(ae.set), Ve = function(e, r) {
            if (Tr(ae, e))
              throw new Br(At);
            return r.facade = e, _t(ae, e, r), r;
          }, Fe = function(e) {
            return vt(ae, e) || {};
          }, Xe = function(e) {
            return Tr(ae, e);
          }) : (pe = ma("state"), ga[pe] = true, Ve = function(e, r) {
            if (Sr(e, pe))
              throw new Br(At);
            return r.facade = e, Ca(e, pe, r), r;
          }, Fe = function(e) {
            return Sr(e, pe) ? e[pe] : {};
          }, Xe = function(e) {
            return Sr(e, pe);
          });
          var ae, vt, Tr, _t, pe;
          yt.exports = { set: Ve, get: Fe, has: Xe, enforce: Aa, getterFor: va };
        }), wt = y((Yc, bt) => {
          var br = oe(), _a = ie(), Bt = Function.prototype, Sa = br && Object.getOwnPropertyDescriptor, wr = _a(Bt, "name"), ya = wr && function() {
          }.name === "something", Ta = wr && (!br || br && Sa(Bt, "name").configurable);
          bt.exports = { EXISTS: wr, PROPER: ya, CONFIGURABLE: Ta };
        }), Rt = y((Qc, It) => {
          var Ba = G(), Nt = K(), ba = ie(), Ot = Ue(), wa = ke(), Na = Ge(), qt = Tt(), Oa = wt().CONFIGURABLE, qa = qt.get, Ia = qt.enforce, Ra = String(String).split("String");
          (It.exports = function(e, r, u, s) {
            var D = s ? !!s.unsafe : false, n = s ? !!s.enumerable : false, i = s ? !!s.noTargetGet : false, p = s && s.name !== void 0 ? s.name : r, l;
            if (Nt(u) && (String(p).slice(0, 7) === "Symbol(" && (p = "[" + String(p).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!ba(u, "name") || Oa && u.name !== p) && Ot(u, "name", p), l = Ia(u), l.source || (l.source = Ra.join(typeof p == "string" ? p : ""))), e === Ba) {
              n ? e[r] = u : wa(r, u);
              return;
            } else
              D ? !i && e[r] && (n = true) : delete e[r];
            n ? e[r] = u : Ot(e, r, u);
          })(Function.prototype, "toString", function() {
            return Nt(this) && qa(this).source || Na(this);
          });
        }), Nr = y((Kc, xt) => {
          var xa = Math.ceil, Pa = Math.floor;
          xt.exports = function(e) {
            var r = +e;
            return r !== r || r === 0 ? 0 : (r > 0 ? Pa : xa)(r);
          };
        }), kt = y((Jc, Pt) => {
          var ka = Nr(), La = Math.max, $a = Math.min;
          Pt.exports = function(e, r) {
            var u = ka(e);
            return u < 0 ? La(u + r, 0) : $a(u, r);
          };
        }), $t = y((Zc, Lt) => {
          var Ma = Nr(), ja = Math.min;
          Lt.exports = function(e) {
            return e > 0 ? ja(Ma(e), 9007199254740991) : 0;
          };
        }), Ae = y((e2, Mt) => {
          var Ua = $t();
          Mt.exports = function(e) {
            return Ua(e.length);
          };
        }), Gt = y((r2, Ut) => {
          var Ga = Ie(), Va = kt(), Xa = Ae(), jt = function(e) {
            return function(r, u, s) {
              var D = Ga(r), n = Xa(D), i = Va(s, n), p;
              if (e && u != u) {
                for (; n > i; )
                  if (p = D[i++], p != p)
                    return true;
              } else
                for (; n > i; i++)
                  if ((e || i in D) && D[i] === u)
                    return e || i || 0;
              return !e && -1;
            };
          };
          Ut.exports = { includes: jt(true), indexOf: jt(false) };
        }), Ht = y((u2, Xt) => {
          var Ha = Q(), Or = ie(), za = Ie(), Wa = Gt().indexOf, Ya = vr(), Vt = Ha([].push);
          Xt.exports = function(e, r) {
            var u = za(e), s = 0, D = [], n;
            for (n in u)
              !Or(Ya, n) && Or(u, n) && Vt(D, n);
            for (; r.length > s; )
              Or(u, n = r[s++]) && (~Wa(D, n) || Vt(D, n));
            return D;
          };
        }), Wt = y((t2, zt) => {
          zt.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
        }), Qt = y((Yt) => {
          var Qa = Ht(), Ka = Wt(), Ja = Ka.concat("length", "prototype");
          Yt.f = Object.getOwnPropertyNames || function(r) {
            return Qa(r, Ja);
          };
        }), Jt = y((Kt) => {
          Kt.f = Object.getOwnPropertySymbols;
        }), en = y((i2, Zt) => {
          var Za = me(), eo = Q(), ro = Qt(), uo = Jt(), to = de(), no = eo([].concat);
          Zt.exports = Za("Reflect", "ownKeys") || function(r) {
            var u = ro.f(to(r)), s = uo.f;
            return s ? no(u, s(r)) : u;
          };
        }), tn = y((a2, un) => {
          var rn = ie(), so = en(), io = Er(), ao = je();
          un.exports = function(e, r, u) {
            for (var s = so(r), D = ao.f, n = io.f, i = 0; i < s.length; i++) {
              var p = s[i];
              !rn(e, p) && !(u && rn(u, p)) && D(e, p, n(r, p));
            }
          };
        }), sn = y((o2, nn) => {
          var oo = se(), Do = K(), lo = /#|\.prototype\./, ve = function(e, r) {
            var u = ho[co(e)];
            return u == fo ? true : u == po ? false : Do(r) ? oo(r) : !!r;
          }, co = ve.normalize = function(e) {
            return String(e).replace(lo, ".").toLowerCase();
          }, ho = ve.data = {}, po = ve.NATIVE = "N", fo = ve.POLYFILL = "P";
          nn.exports = ve;
        }), He = y((D2, an) => {
          var qr = G(), Eo = Er().f, Co = Ue(), mo = Rt(), go = ke(), Fo = tn(), Ao = sn();
          an.exports = function(e, r) {
            var u = e.target, s = e.global, D = e.stat, n, i, p, l, g, a;
            if (s ? i = qr : D ? i = qr[u] || go(u, {}) : i = (qr[u] || {}).prototype, i)
              for (p in r) {
                if (g = r[p], e.noTargetGet ? (a = Eo(i, p), l = a && a.value) : l = i[p], n = Ao(s ? p : u + (D ? "." : "#") + p, e.forced), !n && l !== void 0) {
                  if (typeof g == typeof l)
                    continue;
                  Fo(g, l);
                }
                (e.sham || l && l.sham) && Co(g, "sham", true), mo(i, p, g, e);
              }
          };
        }), on = y(() => {
          var vo = He(), _o = G();
          vo({ global: true }, { globalThis: _o });
        }), Dn = y(() => {
          on();
        }), Ir = y((f2, ln) => {
          var So = qe();
          ln.exports = Array.isArray || function(r) {
            return So(r) == "Array";
          };
        }), Rr = y((d2, hn) => {
          var cn = Q(), yo = ge(), To = we(), Bo = cn(cn.bind);
          hn.exports = function(e, r) {
            return yo(e), r === void 0 ? e : To ? Bo(e, r) : function() {
              return e.apply(r, arguments);
            };
          };
        }), dn = y((E2, fn) => {
          "use strict";
          var bo = G(), wo = Ir(), No = Ae(), Oo = Rr(), qo = bo.TypeError, pn = function(e, r, u, s, D, n, i, p) {
            for (var l = D, g = 0, a = i ? Oo(i, p) : false, c, h; g < s; ) {
              if (g in u) {
                if (c = a ? a(u[g], g, r) : u[g], n > 0 && wo(c))
                  h = No(c), l = pn(e, r, c, h, l, n - 1) - 1;
                else {
                  if (l >= 9007199254740991)
                    throw qo("Exceed the acceptable array length");
                  e[l] = c;
                }
                l++;
              }
              g++;
            }
            return l;
          };
          fn.exports = pn;
        }), mn = y((C2, Cn) => {
          var Io = he(), Ro = Io("toStringTag"), En = {};
          En[Ro] = "z", Cn.exports = String(En) === "[object z]";
        }), xr = y((m2, gn) => {
          var xo = G(), Po = mn(), ko = K(), ze = qe(), Lo = he(), $o = Lo("toStringTag"), Mo = xo.Object, jo = ze(function() {
            return arguments;
          }()) == "Arguments", Uo = function(e, r) {
            try {
              return e[r];
            } catch {
            }
          };
          gn.exports = Po ? ze : function(e) {
            var r, u, s;
            return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (u = Uo(r = Mo(e), $o)) == "string" ? u : jo ? ze(r) : (s = ze(r)) == "Object" && ko(r.callee) ? "Arguments" : s;
          };
        }), yn = y((g2, Sn) => {
          var Go = Q(), Vo = se(), Fn = K(), Xo = xr(), Ho = me(), zo = Ge(), An = function() {
          }, Wo = [], vn = Ho("Reflect", "construct"), Pr = /^\s*(?:class|function)\b/, Yo = Go(Pr.exec), Qo = !Pr.exec(An), _e = function(r) {
            if (!Fn(r))
              return false;
            try {
              return vn(An, Wo, r), true;
            } catch {
              return false;
            }
          }, _n = function(r) {
            if (!Fn(r))
              return false;
            switch (Xo(r)) {
              case "AsyncFunction":
              case "GeneratorFunction":
              case "AsyncGeneratorFunction":
                return false;
            }
            try {
              return Qo || !!Yo(Pr, zo(r));
            } catch {
              return true;
            }
          };
          _n.sham = true, Sn.exports = !vn || Vo(function() {
            var e;
            return _e(_e.call) || !_e(Object) || !_e(function() {
              e = true;
            }) || e;
          }) ? _n : _e;
        }), wn = y((F2, bn) => {
          var Ko = G(), Tn = Ir(), Jo = yn(), Zo = le(), eD = he(), rD = eD("species"), Bn = Ko.Array;
          bn.exports = function(e) {
            var r;
            return Tn(e) && (r = e.constructor, Jo(r) && (r === Bn || Tn(r.prototype)) ? r = void 0 : Zo(r) && (r = r[rD], r === null && (r = void 0))), r === void 0 ? Bn : r;
          };
        }), On = y((A22, Nn) => {
          var uD = wn();
          Nn.exports = function(e, r) {
            return new (uD(e))(r === 0 ? 0 : r);
          };
        }), qn = y(() => {
          "use strict";
          var tD = He(), nD = dn(), sD = ge(), iD = hr(), aD = Ae(), oD = On();
          tD({ target: "Array", proto: true }, { flatMap: function(r) {
            var u = iD(this), s = aD(u), D;
            return sD(r), D = oD(u, 0), D.length = nD(D, u, u, s, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), D;
          } });
        }), kr = y((S2, In) => {
          In.exports = {};
        }), xn = y((y2, Rn) => {
          var DD = he(), lD = kr(), cD = DD("iterator"), hD = Array.prototype;
          Rn.exports = function(e) {
            return e !== void 0 && (lD.Array === e || hD[cD] === e);
          };
        }), Lr = y((T2, kn) => {
          var pD = xr(), Pn = Pe(), fD = kr(), dD = he(), ED = dD("iterator");
          kn.exports = function(e) {
            if (e != null)
              return Pn(e, ED) || Pn(e, "@@iterator") || fD[pD(e)];
          };
        }), $n = y((B2, Ln) => {
          var CD = G(), mD = De(), gD = ge(), FD = de(), AD = xe(), vD = Lr(), _D = CD.TypeError;
          Ln.exports = function(e, r) {
            var u = arguments.length < 2 ? vD(e) : r;
            if (gD(u))
              return FD(mD(u, e));
            throw _D(AD(e) + " is not iterable");
          };
        }), Un = y((b2, jn) => {
          var SD = De(), Mn = de(), yD = Pe();
          jn.exports = function(e, r, u) {
            var s, D;
            Mn(e);
            try {
              if (s = yD(e, "return"), !s) {
                if (r === "throw")
                  throw u;
                return u;
              }
              s = SD(s, e);
            } catch (n) {
              D = true, s = n;
            }
            if (r === "throw")
              throw u;
            if (D)
              throw s;
            return Mn(s), u;
          };
        }), zn = y((w2, Hn) => {
          var TD = G(), BD = Rr(), bD = De(), wD = de(), ND = xe(), OD = xn(), qD = Ae(), Gn = tr(), ID = $n(), RD = Lr(), Vn = Un(), xD = TD.TypeError, We = function(e, r) {
            this.stopped = e, this.result = r;
          }, Xn = We.prototype;
          Hn.exports = function(e, r, u) {
            var s = u && u.that, D = !!(u && u.AS_ENTRIES), n = !!(u && u.IS_ITERATOR), i = !!(u && u.INTERRUPTED), p = BD(r, s), l, g, a, c, h, C, d, m = function(B) {
              return l && Vn(l, "normal", B), new We(true, B);
            }, T = function(B) {
              return D ? (wD(B), i ? p(B[0], B[1], m) : p(B[0], B[1])) : i ? p(B, m) : p(B);
            };
            if (n)
              l = e;
            else {
              if (g = RD(e), !g)
                throw xD(ND(e) + " is not iterable");
              if (OD(g)) {
                for (a = 0, c = qD(e); c > a; a++)
                  if (h = T(e[a]), h && Gn(Xn, h))
                    return h;
                return new We(false);
              }
              l = ID(e, g);
            }
            for (C = l.next; !(d = bD(C, l)).done; ) {
              try {
                h = T(d.value);
              } catch (B) {
                Vn(l, "throw", B);
              }
              if (typeof h == "object" && h && Gn(Xn, h))
                return h;
            }
            return new We(false);
          };
        }), Yn = y((N2, Wn) => {
          "use strict";
          var PD = $e(), kD = je(), LD = Oe();
          Wn.exports = function(e, r, u) {
            var s = PD(r);
            s in e ? kD.f(e, s, LD(0, u)) : e[s] = u;
          };
        }), Qn = y(() => {
          var $D = He(), MD = zn(), jD = Yn();
          $D({ target: "Object", stat: true }, { fromEntries: function(r) {
            var u = {};
            return MD(r, function(s, D) {
              jD(u, s, D);
            }, { AS_ENTRIES: true }), u;
          } });
        }), ec = y((I2, Fs) => {
          var UD = ["cliName", "cliCategory", "cliDescription"];
          function GD(e, r) {
            if (e == null)
              return {};
            var u = VD(e, r), s, D;
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(e);
              for (D = 0; D < n.length; D++)
                s = n[D], !(r.indexOf(s) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s) || (u[s] = e[s]));
            }
            return u;
          }
          function VD(e, r) {
            if (e == null)
              return {};
            var u = {}, s = Object.keys(e), D, n;
            for (n = 0; n < s.length; n++)
              D = s[n], !(r.indexOf(D) >= 0) && (u[D] = e[D]);
            return u;
          }
          Dn(), qn(), Qn();
          var XD = Object.create, Ke = Object.defineProperty, HD = Object.getOwnPropertyDescriptor, Mr = Object.getOwnPropertyNames, zD = Object.getPrototypeOf, WD = Object.prototype.hasOwnProperty, Ee = (e, r) => function() {
            return e && (r = (0, e[Mr(e)[0]])(e = 0)), r;
          }, I = (e, r) => function() {
            return r || (0, e[Mr(e)[0]])((r = { exports: {} }).exports, r), r.exports;
          }, us = (e, r) => {
            for (var u in r)
              Ke(e, u, { get: r[u], enumerable: true });
          }, ts = (e, r, u, s) => {
            if (r && typeof r == "object" || typeof r == "function")
              for (let D of Mr(r))
                !WD.call(e, D) && D !== u && Ke(e, D, { get: () => r[D], enumerable: !(s = HD(r, D)) || s.enumerable });
            return e;
          }, YD = (e, r, u) => (u = e != null ? XD(zD(e)) : {}, ts(r || !e || !e.__esModule ? Ke(u, "default", { value: e, enumerable: true }) : u, e)), ns = (e) => ts(Ke({}, "__esModule", { value: true }), e), Kn, Jn, Se, q = Ee({ "<define:process>"() {
            Kn = {}, Jn = [], Se = { env: Kn, argv: Jn };
          } }), ss = I({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
            function r(p) {
              return p >= e.$TAB && p <= e.$SPACE || p == e.$NBSP;
            }
            e.isWhitespace = r;
            function u(p) {
              return e.$0 <= p && p <= e.$9;
            }
            e.isDigit = u;
            function s(p) {
              return p >= e.$a && p <= e.$z || p >= e.$A && p <= e.$Z;
            }
            e.isAsciiLetter = s;
            function D(p) {
              return p >= e.$a && p <= e.$f || p >= e.$A && p <= e.$F || u(p);
            }
            e.isAsciiHexDigit = D;
            function n(p) {
              return p === e.$LF || p === e.$CR;
            }
            e.isNewLine = n;
            function i(p) {
              return e.$0 <= p && p <= e.$7;
            }
            e.isOctalDigit = i;
          } }), QD = I({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            var r = class {
              constructor(s, D, n) {
                this.filePath = s, this.name = D, this.members = n;
              }
              assertNoMembers() {
                if (this.members.length)
                  throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
              }
            };
            e.StaticSymbol = r;
            var u = class {
              constructor() {
                this.cache = /* @__PURE__ */ new Map();
              }
              get(s, D, n) {
                n = n || [];
                let i = n.length ? `.${n.join(".")}` : "", p = `"${s}".${D}${i}`, l = this.cache.get(p);
                return l || (l = new r(s, D, n), this.cache.set(p, l)), l;
              }
            };
            e.StaticSymbolCache = u;
          } }), KD = I({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            var r = /-+([a-z0-9])/g;
            function u(o) {
              return o.replace(r, function() {
                for (var E = arguments.length, f = new Array(E), F = 0; F < E; F++)
                  f[F] = arguments[F];
                return f[1].toUpperCase();
              });
            }
            e.dashCaseToCamelCase = u;
            function s(o, E) {
              return n(o, ":", E);
            }
            e.splitAtColon = s;
            function D(o, E) {
              return n(o, ".", E);
            }
            e.splitAtPeriod = D;
            function n(o, E, f) {
              let F = o.indexOf(E);
              return F == -1 ? f : [o.slice(0, F).trim(), o.slice(F + 1).trim()];
            }
            function i(o, E, f) {
              return Array.isArray(o) ? E.visitArray(o, f) : A3(o) ? E.visitStringMap(o, f) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? E.visitPrimitive(o, f) : E.visitOther(o, f);
            }
            e.visitValue = i;
            function p(o) {
              return o != null;
            }
            e.isDefined = p;
            function l(o) {
              return o === void 0 ? null : o;
            }
            e.noUndefined = l;
            var g = class {
              visitArray(o, E) {
                return o.map((f) => i(f, this, E));
              }
              visitStringMap(o, E) {
                let f = {};
                return Object.keys(o).forEach((F) => {
                  f[F] = i(o[F], this, E);
                }), f;
              }
              visitPrimitive(o, E) {
                return o;
              }
              visitOther(o, E) {
                return o;
              }
            };
            e.ValueTransformer = g, e.SyncAsync = { assertSync: (o) => {
              if (_(o))
                throw new Error("Illegal state: value cannot be a promise");
              return o;
            }, then: (o, E) => _(o) ? o.then(E) : E(o), all: (o) => o.some(_) ? Promise.all(o) : o };
            function a(o) {
              throw new Error(`Internal Error: ${o}`);
            }
            e.error = a;
            function c(o, E) {
              let f = Error(o);
              return f[h] = true, E && (f[C] = E), f;
            }
            e.syntaxError = c;
            var h = "ngSyntaxError", C = "ngParseErrors";
            function d(o) {
              return o[h];
            }
            e.isSyntaxError = d;
            function m(o) {
              return o[C] || [];
            }
            e.getParseErrors = m;
            function T(o) {
              return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
            }
            e.escapeRegExp = T;
            var B = Object.getPrototypeOf({});
            function A3(o) {
              return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === B;
            }
            function N(o) {
              let E = "";
              for (let f = 0; f < o.length; f++) {
                let F = o.charCodeAt(f);
                if (F >= 55296 && F <= 56319 && o.length > f + 1) {
                  let P2 = o.charCodeAt(f + 1);
                  P2 >= 56320 && P2 <= 57343 && (f++, F = (F - 55296 << 10) + P2 - 56320 + 65536);
                }
                F <= 127 ? E += String.fromCharCode(F) : F <= 2047 ? E += String.fromCharCode(F >> 6 & 31 | 192, F & 63 | 128) : F <= 65535 ? E += String.fromCharCode(F >> 12 | 224, F >> 6 & 63 | 128, F & 63 | 128) : F <= 2097151 && (E += String.fromCharCode(F >> 18 & 7 | 240, F >> 12 & 63 | 128, F >> 6 & 63 | 128, F & 63 | 128));
              }
              return E;
            }
            e.utf8Encode = N;
            function R(o) {
              if (typeof o == "string")
                return o;
              if (o instanceof Array)
                return "[" + o.map(R).join(", ") + "]";
              if (o == null)
                return "" + o;
              if (o.overriddenName)
                return `${o.overriddenName}`;
              if (o.name)
                return `${o.name}`;
              if (!o.toString)
                return "object";
              let E = o.toString();
              if (E == null)
                return "" + E;
              let f = E.indexOf(`
`);
              return f === -1 ? E : E.substring(0, f);
            }
            e.stringify = R;
            function j(o) {
              return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
            }
            e.resolveForwardRef = j;
            function _(o) {
              return !!o && typeof o.then == "function";
            }
            e.isPromise = _;
            var O = class {
              constructor(o) {
                this.full = o;
                let E = o.split(".");
                this.major = E[0], this.minor = E[1], this.patch = E.slice(2).join(".");
              }
            };
            e.Version = O;
            var x = typeof window < "u" && window, k = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, $ = typeof globalThis < "u" && globalThis, t = $ || x || k;
            e.global = t;
          } }), JD = I({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            var r = QD(), u = KD(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
            function D(f) {
              return f.replace(/\W/g, "_");
            }
            e.sanitizeIdentifier = D;
            var n = 0;
            function i(f) {
              if (!f || !f.reference)
                return null;
              let F = f.reference;
              if (F instanceof r.StaticSymbol)
                return F.name;
              if (F.__anonymousType)
                return F.__anonymousType;
              let P2 = u.stringify(F);
              return P2.indexOf("(") >= 0 ? (P2 = `anonymous_${n++}`, F.__anonymousType = P2) : P2 = D(P2), P2;
            }
            e.identifierName = i;
            function p(f) {
              let F = f.reference;
              return F instanceof r.StaticSymbol ? F.filePath : `./${u.stringify(F)}`;
            }
            e.identifierModuleUrl = p;
            function l(f, F) {
              return `View_${i({ reference: f })}_${F}`;
            }
            e.viewClassName = l;
            function g(f) {
              return `RenderType_${i({ reference: f })}`;
            }
            e.rendererTypeName = g;
            function a(f) {
              return `HostView_${i({ reference: f })}`;
            }
            e.hostViewClassName = a;
            function c(f) {
              return `${i({ reference: f })}NgFactory`;
            }
            e.componentFactoryName = c;
            var h;
            (function(f) {
              f[f.Pipe = 0] = "Pipe", f[f.Directive = 1] = "Directive", f[f.NgModule = 2] = "NgModule", f[f.Injectable = 3] = "Injectable";
            })(h = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
            function C(f) {
              return f.value != null ? D(f.value) : i(f.identifier);
            }
            e.tokenName = C;
            function d(f) {
              return f.identifier != null ? f.identifier.reference : f.value;
            }
            e.tokenReference = d;
            var m = class {
              constructor() {
                let { moduleUrl: f, styles: F, styleUrls: P2 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                this.moduleUrl = f || null, this.styles = _(F), this.styleUrls = _(P2);
              }
            };
            e.CompileStylesheetMetadata = m;
            var T = class {
              constructor(f) {
                let { encapsulation: F, template: P2, templateUrl: M, htmlAst: W, styles: X, styleUrls: H, externalStylesheets: z, animations: J, ngContentSelectors: Z, interpolation: ee, isInline: v, preserveWhitespaces: S } = f;
                if (this.encapsulation = F, this.template = P2, this.templateUrl = M, this.htmlAst = W, this.styles = _(X), this.styleUrls = _(H), this.externalStylesheets = _(z), this.animations = J ? x(J) : [], this.ngContentSelectors = Z || [], ee && ee.length != 2)
                  throw new Error("'interpolation' should have a start and an end symbol.");
                this.interpolation = ee, this.isInline = v, this.preserveWhitespaces = S;
              }
              toSummary() {
                return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
              }
            };
            e.CompileTemplateMetadata = T;
            var B = class {
              static create(f) {
                let { isHost: F, type: P2, isComponent: M, selector: W, exportAs: X, changeDetection: H, inputs: z, outputs: J, host: Z, providers: ee, viewProviders: v, queries: S, guards: b, viewQueries: w, entryComponents: L, template: U, componentViewType: V, rendererType: Y, componentFactory: te } = f, Te = {}, Be = {}, Gr = {};
                Z != null && Object.keys(Z).forEach((re) => {
                  let ne = Z[re], Ce = re.match(s);
                  Ce === null ? Gr[re] = ne : Ce[1] != null ? Be[Ce[1]] = ne : Ce[2] != null && (Te[Ce[2]] = ne);
                });
                let Vr = {};
                z == null ? void 0 : z.forEach((re) => {
                  let ne = u.splitAtColon(re, [re, re]);
                  Vr[ne[0]] = ne[1];
                });
                let Xr = {};
                return J == null ? void 0 : J.forEach((re) => {
                  let ne = u.splitAtColon(re, [re, re]);
                  Xr[ne[0]] = ne[1];
                }), new B({ isHost: F, type: P2, isComponent: !!M, selector: W, exportAs: X, changeDetection: H, inputs: Vr, outputs: Xr, hostListeners: Te, hostProperties: Be, hostAttributes: Gr, providers: ee, viewProviders: v, queries: S, guards: b, viewQueries: w, entryComponents: L, template: U, componentViewType: V, rendererType: Y, componentFactory: te });
              }
              constructor(f) {
                let { isHost: F, type: P2, isComponent: M, selector: W, exportAs: X, changeDetection: H, inputs: z, outputs: J, hostListeners: Z, hostProperties: ee, hostAttributes: v, providers: S, viewProviders: b, queries: w, guards: L, viewQueries: U, entryComponents: V, template: Y, componentViewType: te, rendererType: Te, componentFactory: Be } = f;
                this.isHost = !!F, this.type = P2, this.isComponent = M, this.selector = W, this.exportAs = X, this.changeDetection = H, this.inputs = z, this.outputs = J, this.hostListeners = Z, this.hostProperties = ee, this.hostAttributes = v, this.providers = _(S), this.viewProviders = _(b), this.queries = _(w), this.guards = L, this.viewQueries = _(U), this.entryComponents = _(V), this.template = Y, this.componentViewType = te, this.rendererType = Te, this.componentFactory = Be;
              }
              toSummary() {
                return { summaryKind: h.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
              }
            };
            e.CompileDirectiveMetadata = B;
            var A3 = class {
              constructor(f) {
                let { type: F, name: P2, pure: M } = f;
                this.type = F, this.name = P2, this.pure = !!M;
              }
              toSummary() {
                return { summaryKind: h.Pipe, type: this.type, name: this.name, pure: this.pure };
              }
            };
            e.CompilePipeMetadata = A3;
            var N = class {
            };
            e.CompileShallowModuleMetadata = N;
            var R = class {
              constructor(f) {
                let { type: F, providers: P2, declaredDirectives: M, exportedDirectives: W, declaredPipes: X, exportedPipes: H, entryComponents: z, bootstrapComponents: J, importedModules: Z, exportedModules: ee, schemas: v, transitiveModule: S, id: b } = f;
                this.type = F || null, this.declaredDirectives = _(M), this.exportedDirectives = _(W), this.declaredPipes = _(X), this.exportedPipes = _(H), this.providers = _(P2), this.entryComponents = _(z), this.bootstrapComponents = _(J), this.importedModules = _(Z), this.exportedModules = _(ee), this.schemas = _(v), this.id = b || null, this.transitiveModule = S || null;
              }
              toSummary() {
                let f = this.transitiveModule;
                return { summaryKind: h.NgModule, type: this.type, entryComponents: f.entryComponents, providers: f.providers, modules: f.modules, exportedDirectives: f.exportedDirectives, exportedPipes: f.exportedPipes };
              }
            };
            e.CompileNgModuleMetadata = R;
            var j = class {
              constructor() {
                this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
              }
              addProvider(f, F) {
                this.providers.push({ provider: f, module: F });
              }
              addDirective(f) {
                this.directivesSet.has(f.reference) || (this.directivesSet.add(f.reference), this.directives.push(f));
              }
              addExportedDirective(f) {
                this.exportedDirectivesSet.has(f.reference) || (this.exportedDirectivesSet.add(f.reference), this.exportedDirectives.push(f));
              }
              addPipe(f) {
                this.pipesSet.has(f.reference) || (this.pipesSet.add(f.reference), this.pipes.push(f));
              }
              addExportedPipe(f) {
                this.exportedPipesSet.has(f.reference) || (this.exportedPipesSet.add(f.reference), this.exportedPipes.push(f));
              }
              addModule(f) {
                this.modulesSet.has(f.reference) || (this.modulesSet.add(f.reference), this.modules.push(f));
              }
              addEntryComponent(f) {
                this.entryComponentsSet.has(f.componentType) || (this.entryComponentsSet.add(f.componentType), this.entryComponents.push(f));
              }
            };
            e.TransitiveCompileNgModuleMetadata = j;
            function _(f) {
              return f || [];
            }
            var O = class {
              constructor(f, F) {
                let { useClass: P2, useValue: M, useExisting: W, useFactory: X, deps: H, multi: z } = F;
                this.token = f, this.useClass = P2 || null, this.useValue = M, this.useExisting = W, this.useFactory = X || null, this.dependencies = H || null, this.multi = !!z;
              }
            };
            e.ProviderMeta = O;
            function x(f) {
              return f.reduce((F, P2) => {
                let M = Array.isArray(P2) ? x(P2) : P2;
                return F.concat(M);
              }, []);
            }
            e.flatten = x;
            function k(f) {
              return f.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
            }
            function $(f, F, P2) {
              let M;
              return P2.isInline ? F.type.reference instanceof r.StaticSymbol ? M = `${F.type.reference.filePath}.${F.type.reference.name}.html` : M = `${i(f)}/${i(F.type)}.html` : M = P2.templateUrl, F.type.reference instanceof r.StaticSymbol ? M : k(M);
            }
            e.templateSourceUrl = $;
            function t(f, F) {
              let P2 = f.moduleUrl.split(/\/\\/g), M = P2[P2.length - 1];
              return k(`css/${F}${M}.ngstyle.js`);
            }
            e.sharedStylesheetJitUrl = t;
            function o(f) {
              return k(`${i(f.type)}/module.ngfactory.js`);
            }
            e.ngModuleJitUrl = o;
            function E(f, F) {
              return k(`${i(f)}/${i(F.type)}.ngfactory.js`);
            }
            e.templateJitUrl = E;
          } }), ye = I({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            var r = ss(), u = JD(), s = class {
              constructor(a, c, h, C) {
                this.file = a, this.offset = c, this.line = h, this.col = C;
              }
              toString() {
                return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
              }
              moveBy(a) {
                let c = this.file.content, h = c.length, C = this.offset, d = this.line, m = this.col;
                for (; C > 0 && a < 0; )
                  if (C--, a++, c.charCodeAt(C) == r.$LF) {
                    d--;
                    let B = c.substr(0, C - 1).lastIndexOf(String.fromCharCode(r.$LF));
                    m = B > 0 ? C - B : C;
                  } else
                    m--;
                for (; C < h && a > 0; ) {
                  let T = c.charCodeAt(C);
                  C++, a--, T == r.$LF ? (d++, m = 0) : m++;
                }
                return new s(this.file, C, d, m);
              }
              getContext(a, c) {
                let h = this.file.content, C = this.offset;
                if (C != null) {
                  C > h.length - 1 && (C = h.length - 1);
                  let d = C, m = 0, T = 0;
                  for (; m < a && C > 0 && (C--, m++, !(h[C] == `
` && ++T == c)); )
                    ;
                  for (m = 0, T = 0; m < a && d < h.length - 1 && (d++, m++, !(h[d] == `
` && ++T == c)); )
                    ;
                  return { before: h.substring(C, this.offset), after: h.substring(this.offset, d + 1) };
                }
                return null;
              }
            };
            e.ParseLocation = s;
            var D = class {
              constructor(a, c) {
                this.content = a, this.url = c;
              }
            };
            e.ParseSourceFile = D;
            var n = class {
              constructor(a, c) {
                let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                this.start = a, this.end = c, this.details = h;
              }
              toString() {
                return this.start.file.content.substring(this.start.offset, this.end.offset);
              }
            };
            e.ParseSourceSpan = n, e.EMPTY_PARSE_LOCATION = new s(new D("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
            var i;
            (function(a) {
              a[a.WARNING = 0] = "WARNING", a[a.ERROR = 1] = "ERROR";
            })(i = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
            var p = class {
              constructor(a, c) {
                let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : i.ERROR;
                this.span = a, this.msg = c, this.level = h;
              }
              contextualMessage() {
                let a = this.span.start.getContext(100, 3);
                return a ? `${this.msg} ("${a.before}[${i[this.level]} ->]${a.after}")` : this.msg;
              }
              toString() {
                let a = this.span.details ? `, ${this.span.details}` : "";
                return `${this.contextualMessage()}: ${this.span.start}${a}`;
              }
            };
            e.ParseError = p;
            function l(a, c) {
              let h = u.identifierModuleUrl(c), C = h != null ? `in ${a} ${u.identifierName(c)} in ${h}` : `in ${a} ${u.identifierName(c)}`, d = new D("", C);
              return new n(new s(d, -1, -1, -1), new s(d, -1, -1, -1));
            }
            e.typeSourceSpan = l;
            function g(a, c, h) {
              let C = `in ${a} ${c} in ${h}`, d = new D("", C);
              return new n(new s(d, -1, -1, -1), new s(d, -1, -1, -1));
            }
            e.r3JitTypeSourceSpan = g;
          } }), ZD = I({ "src/utils/front-matter/parse.js"(e, r) {
            "use strict";
            q();
            var u = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
            function s(D) {
              let n = D.match(u);
              if (!n)
                return { content: D };
              let { startDelimiter: i, language: p, value: l = "", endDelimiter: g } = n.groups, a = p.trim() || "yaml";
              if (i === "+++" && (a = "toml"), a !== "yaml" && i !== g)
                return { content: D };
              let [c] = n;
              return { frontMatter: { type: "front-matter", lang: a, value: l, startDelimiter: i, endDelimiter: g, raw: c.replace(/\n$/, "") }, content: c.replace(/[^\n]/g, " ") + D.slice(c.length) };
            }
            r.exports = s;
          } }), is = I({ "src/utils/get-last.js"(e, r) {
            "use strict";
            q();
            var u = (s) => s[s.length - 1];
            r.exports = u;
          } }), el = I({ "src/common/parser-create-error.js"(e, r) {
            "use strict";
            q();
            function u(s, D) {
              let n = new SyntaxError(s + " (" + D.start.line + ":" + D.start.column + ")");
              return n.loc = D, n;
            }
            r.exports = u;
          } }), as = {};
          us(as, { default: () => rl });
          function rl(e) {
            if (typeof e != "string")
              throw new TypeError("Expected a string");
            return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
          }
          var ul = Ee({ "node_modules/escape-string-regexp/index.js"() {
            q();
          } }), os = I({ "node_modules/semver/internal/debug.js"(e, r) {
            q();
            var u = typeof Se == "object" && Se.env && Se.env.NODE_DEBUG && /\bsemver\b/i.test(Se.env.NODE_DEBUG) ? function() {
              for (var s = arguments.length, D = new Array(s), n = 0; n < s; n++)
                D[n] = arguments[n];
              return console.error("SEMVER", ...D);
            } : () => {
            };
            r.exports = u;
          } }), Ds = I({ "node_modules/semver/internal/constants.js"(e, r) {
            q();
            var u = "2.0.0", s = 256, D = Number.MAX_SAFE_INTEGER || 9007199254740991, n = 16;
            r.exports = { SEMVER_SPEC_VERSION: u, MAX_LENGTH: s, MAX_SAFE_INTEGER: D, MAX_SAFE_COMPONENT_LENGTH: n };
          } }), tl = I({ "node_modules/semver/internal/re.js"(e, r) {
            q();
            var { MAX_SAFE_COMPONENT_LENGTH: u } = Ds(), s = os();
            e = r.exports = {};
            var D = e.re = [], n = e.src = [], i = e.t = {}, p = 0, l = (g, a, c) => {
              let h = p++;
              s(g, h, a), i[g] = h, n[h] = a, D[h] = new RegExp(a, c ? "g" : void 0);
            };
            l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${n[i.NUMERICIDENTIFIER]})\\.(${n[i.NUMERICIDENTIFIER]})\\.(${n[i.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${n[i.NUMERICIDENTIFIERLOOSE]})\\.(${n[i.NUMERICIDENTIFIERLOOSE]})\\.(${n[i.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${n[i.NUMERICIDENTIFIER]}|${n[i.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${n[i.NUMERICIDENTIFIERLOOSE]}|${n[i.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${n[i.PRERELEASEIDENTIFIER]}(?:\\.${n[i.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${n[i.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[i.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${n[i.BUILDIDENTIFIER]}(?:\\.${n[i.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${n[i.MAINVERSION]}${n[i.PRERELEASE]}?${n[i.BUILD]}?`), l("FULL", `^${n[i.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${n[i.MAINVERSIONLOOSE]}${n[i.PRERELEASELOOSE]}?${n[i.BUILD]}?`), l("LOOSE", `^${n[i.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${n[i.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${n[i.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${n[i.XRANGEIDENTIFIER]})(?:\\.(${n[i.XRANGEIDENTIFIER]})(?:\\.(${n[i.XRANGEIDENTIFIER]})(?:${n[i.PRERELEASE]})?${n[i.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${n[i.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[i.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[i.XRANGEIDENTIFIERLOOSE]})(?:${n[i.PRERELEASELOOSE]})?${n[i.BUILD]}?)?)?`), l("XRANGE", `^${n[i.GTLT]}\\s*${n[i.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${n[i.GTLT]}\\s*${n[i.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${u}})(?:\\.(\\d{1,${u}}))?(?:\\.(\\d{1,${u}}))?(?:$|[^\\d])`), l("COERCERTL", n[i.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${n[i.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", l("TILDE", `^${n[i.LONETILDE]}${n[i.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${n[i.LONETILDE]}${n[i.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${n[i.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", l("CARET", `^${n[i.LONECARET]}${n[i.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${n[i.LONECARET]}${n[i.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${n[i.GTLT]}\\s*(${n[i.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${n[i.GTLT]}\\s*(${n[i.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${n[i.GTLT]}\\s*(${n[i.LOOSEPLAIN]}|${n[i.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${n[i.XRANGEPLAIN]})\\s+-\\s+(${n[i.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${n[i.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[i.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
          } }), nl = I({ "node_modules/semver/internal/parse-options.js"(e, r) {
            q();
            var u = ["includePrerelease", "loose", "rtl"], s = (D) => D ? typeof D != "object" ? { loose: true } : u.filter((n) => D[n]).reduce((n, i) => (n[i] = true, n), {}) : {};
            r.exports = s;
          } }), sl = I({ "node_modules/semver/internal/identifiers.js"(e, r) {
            q();
            var u = /^[0-9]+$/, s = (n, i) => {
              let p = u.test(n), l = u.test(i);
              return p && l && (n = +n, i = +i), n === i ? 0 : p && !l ? -1 : l && !p ? 1 : n < i ? -1 : 1;
            }, D = (n, i) => s(i, n);
            r.exports = { compareIdentifiers: s, rcompareIdentifiers: D };
          } }), il = I({ "node_modules/semver/classes/semver.js"(e, r) {
            q();
            var u = os(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: D } = Ds(), { re: n, t: i } = tl(), p = nl(), { compareIdentifiers: l } = sl(), g = class {
              constructor(a, c) {
                if (c = p(c), a instanceof g) {
                  if (a.loose === !!c.loose && a.includePrerelease === !!c.includePrerelease)
                    return a;
                  a = a.version;
                } else if (typeof a != "string")
                  throw new TypeError(`Invalid Version: ${a}`);
                if (a.length > s)
                  throw new TypeError(`version is longer than ${s} characters`);
                u("SemVer", a, c), this.options = c, this.loose = !!c.loose, this.includePrerelease = !!c.includePrerelease;
                let h = a.trim().match(c.loose ? n[i.LOOSE] : n[i.FULL]);
                if (!h)
                  throw new TypeError(`Invalid Version: ${a}`);
                if (this.raw = a, this.major = +h[1], this.minor = +h[2], this.patch = +h[3], this.major > D || this.major < 0)
                  throw new TypeError("Invalid major version");
                if (this.minor > D || this.minor < 0)
                  throw new TypeError("Invalid minor version");
                if (this.patch > D || this.patch < 0)
                  throw new TypeError("Invalid patch version");
                h[4] ? this.prerelease = h[4].split(".").map((C) => {
                  if (/^[0-9]+$/.test(C)) {
                    let d = +C;
                    if (d >= 0 && d < D)
                      return d;
                  }
                  return C;
                }) : this.prerelease = [], this.build = h[5] ? h[5].split(".") : [], this.format();
              }
              format() {
                return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
              }
              toString() {
                return this.version;
              }
              compare(a) {
                if (u("SemVer.compare", this.version, this.options, a), !(a instanceof g)) {
                  if (typeof a == "string" && a === this.version)
                    return 0;
                  a = new g(a, this.options);
                }
                return a.version === this.version ? 0 : this.compareMain(a) || this.comparePre(a);
              }
              compareMain(a) {
                return a instanceof g || (a = new g(a, this.options)), l(this.major, a.major) || l(this.minor, a.minor) || l(this.patch, a.patch);
              }
              comparePre(a) {
                if (a instanceof g || (a = new g(a, this.options)), this.prerelease.length && !a.prerelease.length)
                  return -1;
                if (!this.prerelease.length && a.prerelease.length)
                  return 1;
                if (!this.prerelease.length && !a.prerelease.length)
                  return 0;
                let c = 0;
                do {
                  let h = this.prerelease[c], C = a.prerelease[c];
                  if (u("prerelease compare", c, h, C), h === void 0 && C === void 0)
                    return 0;
                  if (C === void 0)
                    return 1;
                  if (h === void 0)
                    return -1;
                  if (h !== C)
                    return l(h, C);
                } while (++c);
              }
              compareBuild(a) {
                a instanceof g || (a = new g(a, this.options));
                let c = 0;
                do {
                  let h = this.build[c], C = a.build[c];
                  if (u("prerelease compare", c, h, C), h === void 0 && C === void 0)
                    return 0;
                  if (C === void 0)
                    return 1;
                  if (h === void 0)
                    return -1;
                  if (h !== C)
                    return l(h, C);
                } while (++c);
              }
              inc(a, c) {
                switch (a) {
                  case "premajor":
                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", c);
                    break;
                  case "preminor":
                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", c);
                    break;
                  case "prepatch":
                    this.prerelease.length = 0, this.inc("patch", c), this.inc("pre", c);
                    break;
                  case "prerelease":
                    this.prerelease.length === 0 && this.inc("patch", c), this.inc("pre", c);
                    break;
                  case "major":
                    (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                    break;
                  case "minor":
                    (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                    break;
                  case "patch":
                    this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                    break;
                  case "pre":
                    if (this.prerelease.length === 0)
                      this.prerelease = [0];
                    else {
                      let h = this.prerelease.length;
                      for (; --h >= 0; )
                        typeof this.prerelease[h] == "number" && (this.prerelease[h]++, h = -2);
                      h === -1 && this.prerelease.push(0);
                    }
                    c && (l(this.prerelease[0], c) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [c, 0]) : this.prerelease = [c, 0]);
                    break;
                  default:
                    throw new Error(`invalid increment argument: ${a}`);
                }
                return this.format(), this.raw = this.version, this;
              }
            };
            r.exports = g;
          } }), jr = I({ "node_modules/semver/functions/compare.js"(e, r) {
            q();
            var u = il(), s = (D, n, i) => new u(D, i).compare(new u(n, i));
            r.exports = s;
          } }), al = I({ "node_modules/semver/functions/lt.js"(e, r) {
            q();
            var u = jr(), s = (D, n, i) => u(D, n, i) < 0;
            r.exports = s;
          } }), ol = I({ "node_modules/semver/functions/gte.js"(e, r) {
            q();
            var u = jr(), s = (D, n, i) => u(D, n, i) >= 0;
            r.exports = s;
          } }), Dl = I({ "src/utils/arrayify.js"(e, r) {
            "use strict";
            q(), r.exports = (u, s) => Object.entries(u).map((D) => {
              let [n, i] = D;
              return Object.assign({ [s]: n }, i);
            });
          } }), ll = I({ "package.json"(e, r) {
            r.exports = { version: "2.8.0" };
          } }), cl = I({ "node_modules/outdent/lib/index.js"(e, r) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
            function u() {
              for (var A3 = [], N = 0; N < arguments.length; N++)
                A3[N] = arguments[N];
            }
            function s() {
              return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : D();
            }
            function D() {
              return { add: u, delete: u, get: u, set: u, has: function(A3) {
                return false;
              } };
            }
            var n = Object.prototype.hasOwnProperty, i = function(A3, N) {
              return n.call(A3, N);
            };
            function p(A3, N) {
              for (var R in N)
                i(N, R) && (A3[R] = N[R]);
              return A3;
            }
            var l = /^[ \t]*(?:\r\n|\r|\n)/, g = /(?:\r\n|\r|\n)[ \t]*$/, a = /^(?:[\r\n]|$)/, c = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, h = /^[ \t]*[\r\n][ \t\r\n]*$/;
            function C(A3, N, R) {
              var j = 0, _ = A3[0].match(c);
              _ && (j = _[1].length);
              var O = "(\\r\\n|\\r|\\n).{0," + j + "}", x = new RegExp(O, "g");
              N && (A3 = A3.slice(1));
              var k = R.newline, $ = R.trimLeadingNewline, t = R.trimTrailingNewline, o = typeof k == "string", E = A3.length, f = A3.map(function(F, P2) {
                return F = F.replace(x, "$1"), P2 === 0 && $ && (F = F.replace(l, "")), P2 === E - 1 && t && (F = F.replace(g, "")), o && (F = F.replace(/\r\n|\n|\r/g, function(M) {
                  return k;
                })), F;
              });
              return f;
            }
            function d(A3, N) {
              for (var R = "", j = 0, _ = A3.length; j < _; j++)
                R += A3[j], j < _ - 1 && (R += N[j]);
              return R;
            }
            function m(A3) {
              return i(A3, "raw") && i(A3, "length");
            }
            function T(A3) {
              var N = s(), R = s();
              function j(O) {
                for (var x = [], k = 1; k < arguments.length; k++)
                  x[k - 1] = arguments[k];
                if (m(O)) {
                  var $ = O, t = (x[0] === j || x[0] === B) && h.test($[0]) && a.test($[1]), o = t ? R : N, E = o.get($);
                  if (E || (E = C($, t, A3), o.set($, E)), x.length === 0)
                    return E[0];
                  var f = d(E, t ? x.slice(1) : x);
                  return f;
                } else
                  return T(p(p({}, A3), O || {}));
              }
              var _ = p(j, { string: function(O) {
                return C([O], false, A3)[0];
              } });
              return _;
            }
            var B = T({ trimLeadingNewline: true, trimTrailingNewline: true });
            if (e.outdent = B, e.default = B, typeof r < "u")
              try {
                r.exports = B, Object.defineProperty(B, "__esModule", { value: true }), B.default = B, B.outdent = B;
              } catch {
              }
          } }), hl = I({ "src/main/core-options.js"(e, r) {
            "use strict";
            q();
            var { outdent: u } = cl(), s = "Config", D = "Editor", n = "Format", i = "Other", p = "Output", l = "Global", g = "Special", a = { cursorOffset: { since: "1.4.0", category: g, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: u`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: D }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: u`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: g, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: i, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: g, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: i }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (c) => typeof c == "string" || typeof c == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (c) => typeof c == "string" || typeof c == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: u`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (c) => typeof c == "string" || typeof c == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: g, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: u`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: D }, rangeStart: { since: "1.4.0", category: g, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: u`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: D }, requirePragma: { since: "1.7.0", category: g, type: "boolean", default: false, description: u`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: i }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
            r.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: D, CATEGORY_FORMAT: n, CATEGORY_OTHER: i, CATEGORY_OUTPUT: p, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: g, options: a };
          } }), pl = I({ "src/main/support.js"(e, r) {
            "use strict";
            q();
            var u = { compare: jr(), lt: al(), gte: ol() }, s = Dl(), D = ll().version, n = hl().options;
            function i() {
              let { plugins: l = [], showUnreleased: g = false, showDeprecated: a = false, showInternal: c = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = D.split("-", 1)[0], C = l.flatMap((A3) => A3.languages || []).filter(m), d = s(Object.assign({}, ...l.map((A3) => {
                let { options: N } = A3;
                return N;
              }), n), "name").filter((A3) => m(A3) && T(A3)).sort((A3, N) => A3.name === N.name ? 0 : A3.name < N.name ? -1 : 1).map(B).map((A3) => {
                A3 = Object.assign({}, A3), Array.isArray(A3.default) && (A3.default = A3.default.length === 1 ? A3.default[0].value : A3.default.filter(m).sort((R, j) => u.compare(j.since, R.since))[0].value), Array.isArray(A3.choices) && (A3.choices = A3.choices.filter((R) => m(R) && T(R)), A3.name === "parser" && p(A3, C, l));
                let N = Object.fromEntries(l.filter((R) => R.defaultOptions && R.defaultOptions[A3.name] !== void 0).map((R) => [R.name, R.defaultOptions[A3.name]]));
                return Object.assign(Object.assign({}, A3), {}, { pluginDefaults: N });
              });
              return { languages: C, options: d };
              function m(A3) {
                return g || !("since" in A3) || A3.since && u.gte(h, A3.since);
              }
              function T(A3) {
                return a || !("deprecated" in A3) || A3.deprecated && u.lt(h, A3.deprecated);
              }
              function B(A3) {
                if (c)
                  return A3;
                let { cliName: N, cliCategory: R, cliDescription: j } = A3;
                return GD(A3, UD);
              }
            }
            function p(l, g, a) {
              let c = new Set(l.choices.map((h) => h.value));
              for (let h of g)
                if (h.parsers) {
                  for (let C of h.parsers)
                    if (!c.has(C)) {
                      c.add(C);
                      let d = a.find((T) => T.parsers && T.parsers[C]), m = h.name;
                      d && d.name && (m += ` (plugin: ${d.name})`), l.choices.push({ value: C, description: m });
                    }
                }
            }
            r.exports = { getSupportInfo: i };
          } }), fl = I({ "src/utils/is-non-empty-array.js"(e, r) {
            "use strict";
            q();
            function u(s) {
              return Array.isArray(s) && s.length > 0;
            }
            r.exports = u;
          } });
          function dl() {
            let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
            return new RegExp(r, e ? void 0 : "g");
          }
          var El = Ee({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
            q();
          } });
          function Cl(e) {
            if (typeof e != "string")
              throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
            return e.replace(dl(), "");
          }
          var ml = Ee({ "node_modules/strip-ansi/index.js"() {
            q(), El();
          } });
          function gl(e) {
            return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
          }
          var Fl = Ee({ "node_modules/is-fullwidth-code-point/index.js"() {
            q();
          } }), Al = I({ "node_modules/emoji-regex/index.js"(e, r) {
            "use strict";
            q(), r.exports = function() {
              return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
            };
          } }), ls = {};
          us(ls, { default: () => vl });
          function vl(e) {
            if (typeof e != "string" || e.length === 0 || (e = Cl(e), e.length === 0))
              return 0;
            e = e.replace((0, cs.default)(), "  ");
            let r = 0;
            for (let u = 0; u < e.length; u++) {
              let s = e.codePointAt(u);
              s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && u++, r += gl(s) ? 2 : 1);
            }
            return r;
          }
          var cs, _l = Ee({ "node_modules/string-width/index.js"() {
            q(), ml(), Fl(), cs = YD(Al());
          } }), Sl = I({ "src/utils/get-string-width.js"(e, r) {
            "use strict";
            q();
            var u = (_l(), ns(ls)).default, s = /[^\x20-\x7F]/;
            function D(n) {
              return n ? s.test(n) ? u(n) : n.length : 0;
            }
            r.exports = D;
          } }), Ur = I({ "src/utils/text/skip.js"(e, r) {
            "use strict";
            q();
            function u(p) {
              return (l, g, a) => {
                let c = a && a.backwards;
                if (g === false)
                  return false;
                let { length: h } = l, C = g;
                for (; C >= 0 && C < h; ) {
                  let d = l.charAt(C);
                  if (p instanceof RegExp) {
                    if (!p.test(d))
                      return C;
                  } else if (!p.includes(d))
                    return C;
                  c ? C-- : C++;
                }
                return C === -1 || C === h ? C : false;
              };
            }
            var s = u(/\s/), D = u(" 	"), n = u(",; 	"), i = u(/[^\n\r]/);
            r.exports = { skipWhitespace: s, skipSpaces: D, skipToLineEnd: n, skipEverythingButNewLine: i };
          } }), hs = I({ "src/utils/text/skip-inline-comment.js"(e, r) {
            "use strict";
            q();
            function u(s, D) {
              if (D === false)
                return false;
              if (s.charAt(D) === "/" && s.charAt(D + 1) === "*") {
                for (let n = D + 2; n < s.length; ++n)
                  if (s.charAt(n) === "*" && s.charAt(n + 1) === "/")
                    return n + 2;
              }
              return D;
            }
            r.exports = u;
          } }), ps = I({ "src/utils/text/skip-trailing-comment.js"(e, r) {
            "use strict";
            q();
            var { skipEverythingButNewLine: u } = Ur();
            function s(D, n) {
              return n === false ? false : D.charAt(n) === "/" && D.charAt(n + 1) === "/" ? u(D, n) : n;
            }
            r.exports = s;
          } }), fs = I({ "src/utils/text/skip-newline.js"(e, r) {
            "use strict";
            q();
            function u(s, D, n) {
              let i = n && n.backwards;
              if (D === false)
                return false;
              let p = s.charAt(D);
              if (i) {
                if (s.charAt(D - 1) === "\r" && p === `
`)
                  return D - 2;
                if (p === `
` || p === "\r" || p === "\u2028" || p === "\u2029")
                  return D - 1;
              } else {
                if (p === "\r" && s.charAt(D + 1) === `
`)
                  return D + 2;
                if (p === `
` || p === "\r" || p === "\u2028" || p === "\u2029")
                  return D + 1;
              }
              return D;
            }
            r.exports = u;
          } }), yl = I({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r) {
            "use strict";
            q();
            var u = hs(), s = fs(), D = ps(), { skipSpaces: n } = Ur();
            function i(p, l) {
              let g = null, a = l;
              for (; a !== g; )
                g = a, a = n(p, a), a = u(p, a), a = D(p, a), a = s(p, a);
              return a;
            }
            r.exports = i;
          } }), Tl = I({ "src/common/util.js"(e, r) {
            "use strict";
            q();
            var { default: u } = (ul(), ns(as)), s = is(), { getSupportInfo: D } = pl(), n = fl(), i = Sl(), { skipWhitespace: p, skipSpaces: l, skipToLineEnd: g, skipEverythingButNewLine: a } = Ur(), c = hs(), h = ps(), C = fs(), d = yl(), m = (v) => v[v.length - 2];
            function T(v) {
              return (S, b, w) => {
                let L = w && w.backwards;
                if (b === false)
                  return false;
                let { length: U } = S, V = b;
                for (; V >= 0 && V < U; ) {
                  let Y = S.charAt(V);
                  if (v instanceof RegExp) {
                    if (!v.test(Y))
                      return V;
                  } else if (!v.includes(Y))
                    return V;
                  L ? V-- : V++;
                }
                return V === -1 || V === U ? V : false;
              };
            }
            function B(v, S) {
              let b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, w = l(v, b.backwards ? S - 1 : S, b), L = C(v, w, b);
              return w !== L;
            }
            function A3(v, S, b) {
              for (let w = S; w < b; ++w)
                if (v.charAt(w) === `
`)
                  return true;
              return false;
            }
            function N(v, S, b) {
              let w = b(S) - 1;
              w = l(v, w, { backwards: true }), w = C(v, w, { backwards: true }), w = l(v, w, { backwards: true });
              let L = C(v, w, { backwards: true });
              return w !== L;
            }
            function R(v, S) {
              let b = null, w = S;
              for (; w !== b; )
                b = w, w = g(v, w), w = c(v, w), w = l(v, w);
              return w = h(v, w), w = C(v, w), w !== false && B(v, w);
            }
            function j(v, S, b) {
              return R(v, b(S));
            }
            function _(v, S, b) {
              return d(v, b(S));
            }
            function O(v, S, b) {
              return v.charAt(_(v, S, b));
            }
            function x(v, S) {
              let b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return l(v, b.backwards ? S - 1 : S, b) !== S;
            }
            function k(v, S) {
              let b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, w = 0;
              for (let L = b; L < v.length; ++L)
                v[L] === "	" ? w = w + S - w % S : w++;
              return w;
            }
            function $(v, S) {
              let b = v.lastIndexOf(`
`);
              return b === -1 ? 0 : k(v.slice(b + 1).match(/^[\t ]*/)[0], S);
            }
            function t(v, S) {
              let b = { quote: '"', regex: /"/g, escaped: "&quot;" }, w = { quote: "'", regex: /'/g, escaped: "&apos;" }, L = S === "'" ? w : b, U = L === w ? b : w, V = L;
              if (v.includes(L.quote) || v.includes(U.quote)) {
                let Y = (v.match(L.regex) || []).length, te = (v.match(U.regex) || []).length;
                V = Y > te ? U : L;
              }
              return V;
            }
            function o(v, S) {
              let b = v.slice(1, -1), w = S.parser === "json" || S.parser === "json5" && S.quoteProps === "preserve" && !S.singleQuote ? '"' : S.__isInHtmlAttribute ? "'" : t(b, S.singleQuote ? "'" : '"').quote;
              return E(b, w, !(S.parser === "css" || S.parser === "less" || S.parser === "scss" || S.__embeddedInHtml));
            }
            function E(v, S, b) {
              let w = S === '"' ? "'" : '"', L = /\\(.)|(["'])/gs, U = v.replace(L, (V, Y, te) => Y === w ? Y : te === S ? "\\" + te : te || (b && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(Y) ? Y : "\\" + Y));
              return S + U + S;
            }
            function f(v) {
              return v.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
            }
            function F(v, S) {
              let b = v.match(new RegExp(`(${u(S)})+`, "g"));
              return b === null ? 0 : b.reduce((w, L) => Math.max(w, L.length / S.length), 0);
            }
            function P2(v, S) {
              let b = v.match(new RegExp(`(${u(S)})+`, "g"));
              if (b === null)
                return 0;
              let w = /* @__PURE__ */ new Map(), L = 0;
              for (let U of b) {
                let V = U.length / S.length;
                w.set(V, true), V > L && (L = V);
              }
              for (let U = 1; U < L; U++)
                if (!w.get(U))
                  return U;
              return L + 1;
            }
            function M(v, S) {
              (v.comments || (v.comments = [])).push(S), S.printed = false, S.nodeDescription = ee(v);
            }
            function W(v, S) {
              S.leading = true, S.trailing = false, M(v, S);
            }
            function X(v, S, b) {
              S.leading = false, S.trailing = false, b && (S.marker = b), M(v, S);
            }
            function H(v, S) {
              S.leading = false, S.trailing = true, M(v, S);
            }
            function z(v, S) {
              let { languages: b } = D({ plugins: S.plugins }), w = b.find((L) => {
                let { name: U } = L;
                return U.toLowerCase() === v;
              }) || b.find((L) => {
                let { aliases: U } = L;
                return Array.isArray(U) && U.includes(v);
              }) || b.find((L) => {
                let { extensions: U } = L;
                return Array.isArray(U) && U.includes(`.${v}`);
              });
              return w && w.parsers[0];
            }
            function J(v) {
              return v && v.type === "front-matter";
            }
            function Z(v) {
              let S = /* @__PURE__ */ new WeakMap();
              return function(b) {
                return S.has(b) || S.set(b, Symbol(v)), S.get(b);
              };
            }
            function ee(v) {
              let S = v.type || v.kind || "(unknown type)", b = String(v.name || v.id && (typeof v.id == "object" ? v.id.name : v.id) || v.key && (typeof v.key == "object" ? v.key.name : v.key) || v.value && (typeof v.value == "object" ? "" : String(v.value)) || v.operator || "");
              return b.length > 20 && (b = b.slice(0, 19) + "\u2026"), S + (b ? " " + b : "");
            }
            r.exports = { inferParserByLanguage: z, getStringWidth: i, getMaxContinuousCount: F, getMinNotPresentContinuousCount: P2, getPenultimate: m, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: d, getNextNonSpaceNonCommentCharacterIndex: _, getNextNonSpaceNonCommentCharacter: O, skip: T, skipWhitespace: p, skipSpaces: l, skipToLineEnd: g, skipEverythingButNewLine: a, skipInlineComment: c, skipTrailingComment: h, skipNewline: C, isNextLineEmptyAfterIndex: R, isNextLineEmpty: j, isPreviousLineEmpty: N, hasNewline: B, hasNewlineInRange: A3, hasSpaces: x, getAlignmentSize: k, getIndentSize: $, getPreferredQuote: t, printString: o, printNumber: f, makeString: E, addLeadingComment: W, addDanglingComment: X, addTrailingComment: H, isFrontMatterNode: J, isNonEmptyArray: n, createGroupIdMapper: Z };
          } }), Bl = I({ "vendors/html-tag-names.json"(e, r) {
            r.exports = { htmlTagNames: ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"] };
          } }), ds = I({ "src/language-html/utils/array-to-map.js"(e, r) {
            "use strict";
            q();
            function u(s) {
              let D = /* @__PURE__ */ Object.create(null);
              for (let n of s)
                D[n] = true;
              return D;
            }
            r.exports = u;
          } }), bl = I({ "src/language-html/utils/html-tag-names.js"(e, r) {
            "use strict";
            q();
            var { htmlTagNames: u } = Bl(), s = ds(), D = s(u);
            r.exports = D;
          } }), wl = I({ "vendors/html-element-attributes.json"(e, r) {
            r.exports = { htmlElementAttributes: { "*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["for", "form"], legend: ["align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "media", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"], select: ["autocomplete", "disabled", "form", "multiple", "name", "required", "size"], slot: ["name"], source: ["height", "media", "sizes", "src", "srcset", "type", "width"], style: ["media", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"] } };
          } }), Nl = I({ "src/language-html/utils/map-object.js"(e, r) {
            "use strict";
            q();
            function u(s, D) {
              let n = /* @__PURE__ */ Object.create(null);
              for (let [i, p] of Object.entries(s))
                n[i] = D(p, i);
              return n;
            }
            r.exports = u;
          } }), Ol = I({ "src/language-html/utils/html-elements-attributes.js"(e, r) {
            "use strict";
            q();
            var { htmlElementAttributes: u } = wl(), s = Nl(), D = ds(), n = s(u, D);
            r.exports = n;
          } }), ql = I({ "src/language-html/utils/is-unknown-namespace.js"(e, r) {
            "use strict";
            q();
            function u(s) {
              return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
            }
            r.exports = u;
          } }), Il = I({ "src/language-html/pragma.js"(e, r) {
            "use strict";
            q();
            function u(D) {
              return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(D);
            }
            function s(D) {
              return `<!-- @format -->

` + D.replace(/^\s*\n/, "");
            }
            r.exports = { hasPragma: u, insertPragma: s };
          } }), Rl = I({ "src/language-html/ast.js"(e, r) {
            "use strict";
            q();
            var u = { attrs: true, children: true }, s = /* @__PURE__ */ new Set(["parent"]), D = class {
              constructor() {
                let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                for (let p of /* @__PURE__ */ new Set([...s, ...Object.keys(i)]))
                  this.setProperty(p, i[p]);
              }
              setProperty(i, p) {
                if (this[i] !== p) {
                  if (i in u && (p = p.map((l) => this.createChild(l))), !s.has(i)) {
                    this[i] = p;
                    return;
                  }
                  Object.defineProperty(this, i, { value: p, enumerable: false, configurable: true });
                }
              }
              map(i) {
                let p;
                for (let l in u) {
                  let g = this[l];
                  if (g) {
                    let a = n(g, (c) => c.map(i));
                    p !== g && (p || (p = new D({ parent: this.parent })), p.setProperty(l, a));
                  }
                }
                if (p)
                  for (let l in this)
                    l in u || (p[l] = this[l]);
                return i(p || this);
              }
              walk(i) {
                for (let p in u) {
                  let l = this[p];
                  if (l)
                    for (let g = 0; g < l.length; g++)
                      l[g].walk(i);
                }
                i(this);
              }
              createChild(i) {
                let p = i instanceof D ? i.clone() : new D(i);
                return p.setProperty("parent", this), p;
              }
              insertChildBefore(i, p) {
                this.children.splice(this.children.indexOf(i), 0, this.createChild(p));
              }
              removeChild(i) {
                this.children.splice(this.children.indexOf(i), 1);
              }
              replaceChild(i, p) {
                this.children[this.children.indexOf(i)] = this.createChild(p);
              }
              clone() {
                return new D(this);
              }
              get firstChild() {
                var i;
                return (i = this.children) === null || i === void 0 ? void 0 : i[0];
              }
              get lastChild() {
                var i;
                return (i = this.children) === null || i === void 0 ? void 0 : i[this.children.length - 1];
              }
              get prev() {
                var i;
                return (i = this.parent) === null || i === void 0 ? void 0 : i.children[this.parent.children.indexOf(this) - 1];
              }
              get next() {
                var i;
                return (i = this.parent) === null || i === void 0 ? void 0 : i.children[this.parent.children.indexOf(this) + 1];
              }
              get rawName() {
                return this.hasExplicitNamespace ? this.fullName : this.name;
              }
              get fullName() {
                return this.namespace ? this.namespace + ":" + this.name : this.name;
              }
              get attrMap() {
                return Object.fromEntries(this.attrs.map((i) => [i.fullName, i.value]));
              }
            };
            function n(i, p) {
              let l = i.map(p);
              return l.some((g, a) => g !== i[a]) ? l : i;
            }
            r.exports = { Node: D };
          } }), xl = I({ "src/language-html/conditional-comment.js"(e, r) {
            "use strict";
            q();
            var { ParseSourceSpan: u } = ye(), s = [{ regex: /^(\[if([^\]]*)]>)(.*?)<!\s*\[endif]$/s, parse: n }, { regex: /^\[if([^\]]*)]><!$/, parse: i }, { regex: /^<!\s*\[endif]$/, parse: p }];
            function D(l, g) {
              if (l.value)
                for (let { regex: a, parse: c } of s) {
                  let h = l.value.match(a);
                  if (h)
                    return c(l, g, h);
                }
              return null;
            }
            function n(l, g, a) {
              let [, c, h, C] = a, d = 4 + c.length, m = l.sourceSpan.start.moveBy(d), T = m.moveBy(C.length), [B, A3] = (() => {
                try {
                  return [true, g(C, m).children];
                } catch {
                  let N = { type: "text", value: C, sourceSpan: new u(m, T) };
                  return [false, [N]];
                }
              })();
              return { type: "ieConditionalComment", complete: B, children: A3, condition: h.trim().replace(/\s+/g, " "), sourceSpan: l.sourceSpan, startSourceSpan: new u(l.sourceSpan.start, m), endSourceSpan: new u(T, l.sourceSpan.end) };
            }
            function i(l, g, a) {
              let [, c] = a;
              return { type: "ieConditionalStartComment", condition: c.trim().replace(/\s+/g, " "), sourceSpan: l.sourceSpan };
            }
            function p(l) {
              return { type: "ieConditionalEndComment", sourceSpan: l.sourceSpan };
            }
            r.exports = { parseIeConditionalComment: D };
          } }), Pl = I({ "src/language-html/loc.js"(e, r) {
            "use strict";
            q();
            function u(D) {
              return D.sourceSpan.start.offset;
            }
            function s(D) {
              return D.sourceSpan.end.offset;
            }
            r.exports = { locStart: u, locEnd: s };
          } }), Je = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/tags.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            var r;
            (function(l) {
              l[l.RAW_TEXT = 0] = "RAW_TEXT", l[l.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", l[l.PARSABLE_DATA = 2] = "PARSABLE_DATA";
            })(r = e.TagContentType || (e.TagContentType = {}));
            function u(l) {
              if (l[0] != ":")
                return [null, l];
              let g = l.indexOf(":", 1);
              if (g == -1)
                throw new Error(`Unsupported format "${l}" expecting ":namespace:name"`);
              return [l.slice(1, g), l.slice(g + 1)];
            }
            e.splitNsName = u;
            function s(l) {
              return u(l)[1] === "ng-container";
            }
            e.isNgContainer = s;
            function D(l) {
              return u(l)[1] === "ng-content";
            }
            e.isNgContent = D;
            function n(l) {
              return u(l)[1] === "ng-template";
            }
            e.isNgTemplate = n;
            function i(l) {
              return l === null ? null : u(l)[0];
            }
            e.getNsPrefix = i;
            function p(l, g) {
              return l ? `:${l}:${g}` : g;
            }
            e.mergeNsAndName = p, e.NAMED_ENTITIES = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", AMP: "&", amp: "&", And: "\u2A53", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", ap: "\u2248", apacir: "\u2A6F", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", Barwed: "\u2306", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", Because: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxDL: "\u2557", boxDl: "\u2556", boxdL: "\u2555", boxdl: "\u2510", boxDR: "\u2554", boxDr: "\u2553", boxdR: "\u2552", boxdr: "\u250C", boxH: "\u2550", boxh: "\u2500", boxHD: "\u2566", boxHd: "\u2564", boxhD: "\u2565", boxhd: "\u252C", boxHU: "\u2569", boxHu: "\u2567", boxhU: "\u2568", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxUL: "\u255D", boxUl: "\u255C", boxuL: "\u255B", boxul: "\u2518", boxUR: "\u255A", boxUr: "\u2559", boxuR: "\u2558", boxur: "\u2514", boxV: "\u2551", boxv: "\u2502", boxVH: "\u256C", boxVh: "\u256B", boxvH: "\u256A", boxvh: "\u253C", boxVL: "\u2563", boxVl: "\u2562", boxvL: "\u2561", boxvl: "\u2524", boxVR: "\u2560", boxVr: "\u255F", boxvR: "\u255E", boxvr: "\u251C", bprime: "\u2035", Breve: "\u02D8", breve: "\u02D8", brvbar: "\xA6", Bscr: "\u212C", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", Cap: "\u22D2", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", CenterDot: "\xB7", centerdot: "\xB7", Cfr: "\u212D", cfr: "\u{1D520}", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", cir: "\u25CB", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", Colon: "\u2237", colon: ":", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", Conint: "\u222F", conint: "\u222E", ContourIntegral: "\u222E", Copf: "\u2102", copf: "\u{1D554}", coprod: "\u2210", Coproduct: "\u2210", COPY: "\xA9", copy: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", Cross: "\u2A2F", cross: "\u2717", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", Cup: "\u22D3", cup: "\u222A", cupbrcap: "\u2A48", CupCap: "\u224D", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", Dagger: "\u2021", dagger: "\u2020", daleth: "\u2138", Darr: "\u21A1", dArr: "\u21D3", darr: "\u2193", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", DD: "\u2145", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", Diamond: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", Downarrow: "\u21D3", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", ecir: "\u2256", Ecirc: "\xCA", ecirc: "\xEA", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", eDot: "\u2251", edot: "\u0117", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp: "\u2003", emsp13: "\u2004", emsp14: "\u2005", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", Escr: "\u2130", escr: "\u212F", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", ExponentialE: "\u2147", exponentiale: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", ForAll: "\u2200", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", Fscr: "\u2131", fscr: "\u{1D4BB}", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", gE: "\u2267", ge: "\u2265", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", Gg: "\u22D9", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gl: "\u2277", gla: "\u2AA5", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gnE: "\u2269", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", GT: ">", Gt: "\u226B", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", hArr: "\u21D4", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", Hfr: "\u210C", hfr: "\u{1D525}", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", Hopf: "\u210D", hopf: "\u{1D559}", horbar: "\u2015", HorizontalLine: "\u2500", Hscr: "\u210B", hscr: "\u{1D4BD}", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", Ifr: "\u2111", ifr: "\u{1D526}", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Im: "\u2111", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", Int: "\u222C", int: "\u222B", intcal: "\u22BA", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", Iscr: "\u2110", iscr: "\u{1D4BE}", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", Lang: "\u27EA", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", Larr: "\u219E", lArr: "\u21D0", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", lAtail: "\u291B", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lBarr: "\u290E", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", lE: "\u2266", le: "\u2264", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", Leftarrow: "\u21D0", leftarrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", Ll: "\u22D8", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lnE: "\u2268", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftarrow: "\u27F5", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", Lscr: "\u2112", lscr: "\u{1D4C1}", Lsh: "\u21B0", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", LT: "<", Lt: "\u226A", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", Mscr: "\u2133", mscr: "\u{1D4C2}", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", nearhk: "\u2924", neArr: "\u21D7", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: `
`, nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlArr: "\u21CD", nlarr: "\u219A", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nLeftarrow: "\u21CD", nleftarrow: "\u219A", nLeftrightarrow: "\u21CE", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", nopf: "\u{1D55F}", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nRightarrow: "\u21CF", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nVDash: "\u22AF", nVdash: "\u22AE", nvDash: "\u22AD", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwArr: "\u21D6", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", ocir: "\u229A", Ocirc: "\xD4", ocirc: "\xF4", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", Or: "\u2A54", or: "\u2228", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", Otimes: "\u2A37", otimes: "\u2297", otimesas: "\u2A36", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", Popf: "\u2119", popf: "\u{1D561}", pound: "\xA3", Pr: "\u2ABB", pr: "\u227A", prap: "\u2AB7", prcue: "\u227C", prE: "\u2AB3", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", Prime: "\u2033", prime: "\u2032", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportion: "\u2237", Proportional: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", Qopf: "\u211A", qopf: "\u{1D562}", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", QUOT: '"', quot: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", Rang: "\u27EB", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", Rarr: "\u21A0", rArr: "\u21D2", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", rAtail: "\u291C", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", RBarr: "\u2910", rBarr: "\u290F", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", Re: "\u211C", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", REG: "\xAE", reg: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", Rfr: "\u211C", rfr: "\u{1D52F}", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", Rightarrow: "\u21D2", rightarrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", Ropf: "\u211D", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", Rscr: "\u211B", rscr: "\u{1D4C7}", Rsh: "\u21B1", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", Sc: "\u2ABC", sc: "\u227B", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", sccue: "\u227D", scE: "\u2AB4", sce: "\u2AB0", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", searhk: "\u2925", seArr: "\u21D8", searr: "\u2198", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", Square: "\u25A1", square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", Sub: "\u22D0", sub: "\u2282", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", Subset: "\u22D0", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", Sum: "\u2211", sum: "\u2211", sung: "\u266A", Sup: "\u22D1", sup: "\u2283", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", Supset: "\u22D1", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swArr: "\u21D9", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", Therefore: "\u2234", therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", thinsp: "\u2009", ThinSpace: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", Tilde: "\u223C", tilde: "\u02DC", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", TRADE: "\u2122", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", Uarr: "\u219F", uArr: "\u21D1", uarr: "\u2191", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrow: "\u2191", Uparrow: "\u21D1", uparrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", Updownarrow: "\u21D5", updownarrow: "\u2195", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", upsi: "\u03C5", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTee: "\u22A5", UpTeeArrow: "\u21A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", vArr: "\u21D5", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", Vbar: "\u2AEB", vBar: "\u2AE8", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", VDash: "\u22AB", Vdash: "\u22A9", vDash: "\u22A8", vdash: "\u22A2", Vdashl: "\u2AE6", Vee: "\u22C1", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", Verbar: "\u2016", verbar: "|", Vert: "\u2016", vert: "|", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", Wedge: "\u22C0", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", Xi: "\u039E", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", Yuml: "\u0178", yuml: "\xFF", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", Zfr: "\u2128", zfr: "\u{1D537}", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", Zopf: "\u2124", zopf: "\u{1D56B}", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" }, e.NGSP_UNICODE = "\uE500", e.NAMED_ENTITIES.ngsp = e.NGSP_UNICODE;
          } }), Es = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/html_tags.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Je(), u = class {
              constructor() {
                let { closedByChildren: i, implicitNamespacePrefix: p, contentType: l = r.TagContentType.PARSABLE_DATA, closedByParent: g = false, isVoid: a = false, ignoreFirstLf: c = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                this.closedByChildren = {}, this.closedByParent = false, this.canSelfClose = false, i && i.length > 0 && i.forEach((h) => this.closedByChildren[h] = true), this.isVoid = a, this.closedByParent = g || a, this.implicitNamespacePrefix = p || null, this.contentType = l, this.ignoreFirstLf = c;
              }
              isClosedByChild(i) {
                return this.isVoid || i.toLowerCase() in this.closedByChildren;
              }
            };
            e.HtmlTagDefinition = u;
            var s, D;
            function n(i) {
              return D || (s = new u(), D = { base: new u({ isVoid: true }), meta: new u({ isVoid: true }), area: new u({ isVoid: true }), embed: new u({ isVoid: true }), link: new u({ isVoid: true }), img: new u({ isVoid: true }), input: new u({ isVoid: true }), param: new u({ isVoid: true }), hr: new u({ isVoid: true }), br: new u({ isVoid: true }), source: new u({ isVoid: true }), track: new u({ isVoid: true }), wbr: new u({ isVoid: true }), p: new u({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true }), thead: new u({ closedByChildren: ["tbody", "tfoot"] }), tbody: new u({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }), tfoot: new u({ closedByChildren: ["tbody"], closedByParent: true }), tr: new u({ closedByChildren: ["tr"], closedByParent: true }), td: new u({ closedByChildren: ["td", "th"], closedByParent: true }), th: new u({ closedByChildren: ["td", "th"], closedByParent: true }), col: new u({ isVoid: true }), svg: new u({ implicitNamespacePrefix: "svg" }), math: new u({ implicitNamespacePrefix: "math" }), li: new u({ closedByChildren: ["li"], closedByParent: true }), dt: new u({ closedByChildren: ["dt", "dd"] }), dd: new u({ closedByChildren: ["dt", "dd"], closedByParent: true }), rb: new u({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rt: new u({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rtc: new u({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }), rp: new u({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), optgroup: new u({ closedByChildren: ["optgroup"], closedByParent: true }), option: new u({ closedByChildren: ["option", "optgroup"], closedByParent: true }), pre: new u({ ignoreFirstLf: true }), listing: new u({ ignoreFirstLf: true }), style: new u({ contentType: r.TagContentType.RAW_TEXT }), script: new u({ contentType: r.TagContentType.RAW_TEXT }), title: new u({ contentType: r.TagContentType.ESCAPABLE_RAW_TEXT }), textarea: new u({ contentType: r.TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }) }), D[i] || s;
            }
            e.getHtmlTagDefinition = n;
          } }), kl = I({ "node_modules/angular-html-parser/lib/compiler/src/ast_path.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            var r = class {
              constructor(u) {
                let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
                this.path = u, this.position = s;
              }
              get empty() {
                return !this.path || !this.path.length;
              }
              get head() {
                return this.path[0];
              }
              get tail() {
                return this.path[this.path.length - 1];
              }
              parentOf(u) {
                return u && this.path[this.path.indexOf(u) - 1];
              }
              childOf(u) {
                return this.path[this.path.indexOf(u) + 1];
              }
              first(u) {
                for (let s = this.path.length - 1; s >= 0; s--) {
                  let D = this.path[s];
                  if (D instanceof u)
                    return D;
                }
              }
              push(u) {
                this.path.push(u);
              }
              pop() {
                return this.path.pop();
              }
            };
            e.AstPath = r;
          } }), Cs = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/ast.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            var r = kl(), u = class {
              constructor(d, m, T) {
                this.value = d, this.sourceSpan = m, this.i18n = T, this.type = "text";
              }
              visit(d, m) {
                return d.visitText(this, m);
              }
            };
            e.Text = u;
            var s = class {
              constructor(d, m) {
                this.value = d, this.sourceSpan = m, this.type = "cdata";
              }
              visit(d, m) {
                return d.visitCdata(this, m);
              }
            };
            e.CDATA = s;
            var D = class {
              constructor(d, m, T, B, A3, N) {
                this.switchValue = d, this.type = m, this.cases = T, this.sourceSpan = B, this.switchValueSourceSpan = A3, this.i18n = N;
              }
              visit(d, m) {
                return d.visitExpansion(this, m);
              }
            };
            e.Expansion = D;
            var n = class {
              constructor(d, m, T, B, A3) {
                this.value = d, this.expression = m, this.sourceSpan = T, this.valueSourceSpan = B, this.expSourceSpan = A3;
              }
              visit(d, m) {
                return d.visitExpansionCase(this, m);
              }
            };
            e.ExpansionCase = n;
            var i = class {
              constructor(d, m, T) {
                let B = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, A3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, N = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
                this.name = d, this.value = m, this.sourceSpan = T, this.valueSpan = B, this.nameSpan = A3, this.i18n = N, this.type = "attribute";
              }
              visit(d, m) {
                return d.visitAttribute(this, m);
              }
            };
            e.Attribute = i;
            var p = class {
              constructor(d, m, T, B) {
                let A3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, N = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, R = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, j = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
                this.name = d, this.attrs = m, this.children = T, this.sourceSpan = B, this.startSourceSpan = A3, this.endSourceSpan = N, this.nameSpan = R, this.i18n = j, this.type = "element";
              }
              visit(d, m) {
                return d.visitElement(this, m);
              }
            };
            e.Element = p;
            var l = class {
              constructor(d, m) {
                this.value = d, this.sourceSpan = m, this.type = "comment";
              }
              visit(d, m) {
                return d.visitComment(this, m);
              }
            };
            e.Comment = l;
            var g = class {
              constructor(d, m) {
                this.value = d, this.sourceSpan = m, this.type = "docType";
              }
              visit(d, m) {
                return d.visitDocType(this, m);
              }
            };
            e.DocType = g;
            function a(d, m) {
              let T = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, B = [], A3 = d.visit ? (N) => d.visit(N, T) || N.visit(d, T) : (N) => N.visit(d, T);
              return m.forEach((N) => {
                let R = A3(N);
                R && B.push(R);
              }), B;
            }
            e.visitAll = a;
            var c = class {
              constructor() {
              }
              visitElement(d, m) {
                this.visitChildren(m, (T) => {
                  T(d.attrs), T(d.children);
                });
              }
              visitAttribute(d, m) {
              }
              visitText(d, m) {
              }
              visitCdata(d, m) {
              }
              visitComment(d, m) {
              }
              visitDocType(d, m) {
              }
              visitExpansion(d, m) {
                return this.visitChildren(m, (T) => {
                  T(d.cases);
                });
              }
              visitExpansionCase(d, m) {
              }
              visitChildren(d, m) {
                let T = [], B = this;
                function A3(N) {
                  N && T.push(a(B, N, d));
                }
                return m(A3), Array.prototype.concat.apply([], T);
              }
            };
            e.RecursiveVisitor = c;
            function h(d) {
              let m = d.sourceSpan.start.offset, T = d.sourceSpan.end.offset;
              return d instanceof p && (d.endSourceSpan ? T = d.endSourceSpan.end.offset : d.children && d.children.length && (T = h(d.children[d.children.length - 1]).end)), { start: m, end: T };
            }
            function C(d, m) {
              let T = [], B = new class extends c {
                visit(A3, N) {
                  let R = h(A3);
                  if (R.start <= m && m < R.end)
                    T.push(A3);
                  else
                    return true;
                }
              }();
              return a(B, d), new r.AstPath(T, m);
            }
            e.findNode = C;
          } }), Ll = I({ "node_modules/angular-html-parser/lib/compiler/src/assertions.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            function r(D, n) {
              if (n != null) {
                if (!Array.isArray(n))
                  throw new Error(`Expected '${D}' to be an array of strings.`);
                for (let i = 0; i < n.length; i += 1)
                  if (typeof n[i] != "string")
                    throw new Error(`Expected '${D}' to be an array of strings.`);
              }
            }
            e.assertArrayOfStrings = r;
            var u = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
            function s(D, n) {
              if (n != null && !(Array.isArray(n) && n.length == 2))
                throw new Error(`Expected '${D}' to be an array, [start, end].`);
              if (n != null) {
                let i = n[0], p = n[1];
                u.forEach((l) => {
                  if (l.test(i) || l.test(p))
                    throw new Error(`['${i}', '${p}'] contains unusable interpolation symbol.`);
                });
              }
            }
            e.assertInterpolationSymbols = s;
          } }), $l = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/interpolation_config.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ll(), u = class {
              constructor(s, D) {
                this.start = s, this.end = D;
              }
              static fromArray(s) {
                return s ? (r.assertInterpolationSymbols("interpolation", s), new u(s[0], s[1])) : e.DEFAULT_INTERPOLATION_CONFIG;
              }
            };
            e.InterpolationConfig = u, e.DEFAULT_INTERPOLATION_CONFIG = new u("{{", "}}");
          } }), Ml = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/lexer.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            var r = ss(), u = ye(), s = $l(), D = Je(), n;
            (function(t) {
              t[t.TAG_OPEN_START = 0] = "TAG_OPEN_START", t[t.TAG_OPEN_END = 1] = "TAG_OPEN_END", t[t.TAG_OPEN_END_VOID = 2] = "TAG_OPEN_END_VOID", t[t.TAG_CLOSE = 3] = "TAG_CLOSE", t[t.TEXT = 4] = "TEXT", t[t.ESCAPABLE_RAW_TEXT = 5] = "ESCAPABLE_RAW_TEXT", t[t.RAW_TEXT = 6] = "RAW_TEXT", t[t.COMMENT_START = 7] = "COMMENT_START", t[t.COMMENT_END = 8] = "COMMENT_END", t[t.CDATA_START = 9] = "CDATA_START", t[t.CDATA_END = 10] = "CDATA_END", t[t.ATTR_NAME = 11] = "ATTR_NAME", t[t.ATTR_QUOTE = 12] = "ATTR_QUOTE", t[t.ATTR_VALUE = 13] = "ATTR_VALUE", t[t.DOC_TYPE_START = 14] = "DOC_TYPE_START", t[t.DOC_TYPE_END = 15] = "DOC_TYPE_END", t[t.EXPANSION_FORM_START = 16] = "EXPANSION_FORM_START", t[t.EXPANSION_CASE_VALUE = 17] = "EXPANSION_CASE_VALUE", t[t.EXPANSION_CASE_EXP_START = 18] = "EXPANSION_CASE_EXP_START", t[t.EXPANSION_CASE_EXP_END = 19] = "EXPANSION_CASE_EXP_END", t[t.EXPANSION_FORM_END = 20] = "EXPANSION_FORM_END", t[t.EOF = 21] = "EOF";
            })(n = e.TokenType || (e.TokenType = {}));
            var i = class {
              constructor(t, o, E) {
                this.type = t, this.parts = o, this.sourceSpan = E;
              }
            };
            e.Token = i;
            var p = class extends u.ParseError {
              constructor(t, o, E) {
                super(E, t), this.tokenType = o;
              }
            };
            e.TokenError = p;
            var l = class {
              constructor(t, o) {
                this.tokens = t, this.errors = o;
              }
            };
            e.TokenizeResult = l;
            function g(t, o, E) {
              let f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
              return new d(new u.ParseSourceFile(t, o), E, f).tokenize();
            }
            e.tokenize = g;
            var a = /\r\n?/g;
            function c(t) {
              return `Unexpected character "${t === r.$EOF ? "EOF" : String.fromCharCode(t)}"`;
            }
            function h(t) {
              return `Unknown entity "${t}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
            }
            var C = class {
              constructor(t) {
                this.error = t;
              }
            }, d = class {
              constructor(t, o, E) {
                this._getTagContentType = o, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this._tokenizeIcu = E.tokenizeExpansionForms || false, this._interpolationConfig = E.interpolationConfig || s.DEFAULT_INTERPOLATION_CONFIG, this._leadingTriviaCodePoints = E.leadingTriviaChars && E.leadingTriviaChars.map((F) => F.codePointAt(0) || 0), this._canSelfClose = E.canSelfClose || false, this._allowHtmComponentClosingTags = E.allowHtmComponentClosingTags || false;
                let f = E.range || { endPos: t.content.length, startPos: 0, startLine: 0, startCol: 0 };
                this._cursor = E.escapedString ? new k(t, f) : new x(t, f);
                try {
                  this._cursor.init();
                } catch (F) {
                  this.handleError(F);
                }
              }
              _processCarriageReturns(t) {
                return t.replace(a, `
`);
              }
              tokenize() {
                for (; this._cursor.peek() !== r.$EOF; ) {
                  let t = this._cursor.clone();
                  try {
                    if (this._attemptCharCode(r.$LT))
                      if (this._attemptCharCode(r.$BANG))
                        this._attemptStr("[CDATA[") ? this._consumeCdata(t) : this._attemptStr("--") ? this._consumeComment(t) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(t) : this._consumeBogusComment(t);
                      else if (this._attemptCharCode(r.$SLASH))
                        this._consumeTagClose(t);
                      else {
                        let o = this._cursor.clone();
                        this._attemptCharCode(r.$QUESTION) ? (this._cursor = o, this._consumeBogusComment(t)) : this._consumeTagOpen(t);
                      }
                    else
                      this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeText();
                  } catch (o) {
                    this.handleError(o);
                  }
                }
                return this._beginToken(n.EOF), this._endToken([]), new l(O(this.tokens), this.errors);
              }
              _tokenizeExpansionForm() {
                if (this.isExpansionFormStart())
                  return this._consumeExpansionFormStart(), true;
                if (R(this._cursor.peek()) && this._isInExpansionForm())
                  return this._consumeExpansionCaseStart(), true;
                if (this._cursor.peek() === r.$RBRACE) {
                  if (this._isInExpansionCase())
                    return this._consumeExpansionCaseEnd(), true;
                  if (this._isInExpansionForm())
                    return this._consumeExpansionFormEnd(), true;
                }
                return false;
              }
              _beginToken(t) {
                let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._cursor.clone();
                this._currentTokenStart = o, this._currentTokenType = t;
              }
              _endToken(t) {
                let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._cursor.clone();
                if (this._currentTokenStart === null)
                  throw new p("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(o));
                if (this._currentTokenType === null)
                  throw new p("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
                let E = new i(this._currentTokenType, t, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
                return this.tokens.push(E), this._currentTokenStart = null, this._currentTokenType = null, E;
              }
              _createError(t, o) {
                this._isInExpansionForm() && (t += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
                let E = new p(t, this._currentTokenType, o);
                return this._currentTokenStart = null, this._currentTokenType = null, new C(E);
              }
              handleError(t) {
                if (t instanceof $ && (t = this._createError(t.msg, this._cursor.getSpan(t.cursor))), t instanceof C)
                  this.errors.push(t.error);
                else
                  throw t;
              }
              _attemptCharCode(t) {
                return this._cursor.peek() === t ? (this._cursor.advance(), true) : false;
              }
              _attemptCharCodeCaseInsensitive(t) {
                return j(this._cursor.peek(), t) ? (this._cursor.advance(), true) : false;
              }
              _requireCharCode(t) {
                let o = this._cursor.clone();
                if (!this._attemptCharCode(t))
                  throw this._createError(c(this._cursor.peek()), this._cursor.getSpan(o));
              }
              _attemptStr(t) {
                let o = t.length;
                if (this._cursor.charsLeft() < o)
                  return false;
                let E = this._cursor.clone();
                for (let f = 0; f < o; f++)
                  if (!this._attemptCharCode(t.charCodeAt(f)))
                    return this._cursor = E, false;
                return true;
              }
              _attemptStrCaseInsensitive(t) {
                for (let o = 0; o < t.length; o++)
                  if (!this._attemptCharCodeCaseInsensitive(t.charCodeAt(o)))
                    return false;
                return true;
              }
              _requireStr(t) {
                let o = this._cursor.clone();
                if (!this._attemptStr(t))
                  throw this._createError(c(this._cursor.peek()), this._cursor.getSpan(o));
              }
              _requireStrCaseInsensitive(t) {
                let o = this._cursor.clone();
                if (!this._attemptStrCaseInsensitive(t))
                  throw this._createError(c(this._cursor.peek()), this._cursor.getSpan(o));
              }
              _attemptCharCodeUntilFn(t) {
                for (; !t(this._cursor.peek()); )
                  this._cursor.advance();
              }
              _requireCharCodeUntilFn(t, o) {
                let E = this._cursor.clone();
                if (this._attemptCharCodeUntilFn(t), this._cursor.clone().diff(E) < o)
                  throw this._createError(c(this._cursor.peek()), this._cursor.getSpan(E));
              }
              _attemptUntilChar(t) {
                for (; this._cursor.peek() !== t; )
                  this._cursor.advance();
              }
              _readChar(t) {
                if (t && this._cursor.peek() === r.$AMPERSAND)
                  return this._decodeEntity();
                {
                  let o = String.fromCodePoint(this._cursor.peek());
                  return this._cursor.advance(), o;
                }
              }
              _decodeEntity() {
                let t = this._cursor.clone();
                if (this._cursor.advance(), this._attemptCharCode(r.$HASH)) {
                  let o = this._attemptCharCode(r.$x) || this._attemptCharCode(r.$X), E = this._cursor.clone();
                  if (this._attemptCharCodeUntilFn(A3), this._cursor.peek() != r.$SEMICOLON)
                    throw this._createError(c(this._cursor.peek()), this._cursor.getSpan());
                  let f = this._cursor.getChars(E);
                  this._cursor.advance();
                  try {
                    let F = parseInt(f, o ? 16 : 10);
                    return String.fromCharCode(F);
                  } catch {
                    throw this._createError(h(this._cursor.getChars(t)), this._cursor.getSpan());
                  }
                } else {
                  let o = this._cursor.clone();
                  if (this._attemptCharCodeUntilFn(N), this._cursor.peek() != r.$SEMICOLON)
                    return this._cursor = o, "&";
                  let E = this._cursor.getChars(o);
                  this._cursor.advance();
                  let f = D.NAMED_ENTITIES[E];
                  if (!f)
                    throw this._createError(h(E), this._cursor.getSpan(t));
                  return f;
                }
              }
              _consumeRawText(t, o) {
                this._beginToken(t ? n.ESCAPABLE_RAW_TEXT : n.RAW_TEXT);
                let E = [];
                for (; ; ) {
                  let f = this._cursor.clone(), F = o();
                  if (this._cursor = f, F)
                    break;
                  E.push(this._readChar(t));
                }
                return this._endToken([this._processCarriageReturns(E.join(""))]);
              }
              _consumeComment(t) {
                this._beginToken(n.COMMENT_START, t), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(n.COMMENT_END), this._requireStr("-->"), this._endToken([]);
              }
              _consumeBogusComment(t) {
                this._beginToken(n.COMMENT_START, t), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === r.$GT), this._beginToken(n.COMMENT_END), this._cursor.advance(), this._endToken([]);
              }
              _consumeCdata(t) {
                this._beginToken(n.CDATA_START, t), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(n.CDATA_END), this._requireStr("]]>"), this._endToken([]);
              }
              _consumeDocType(t) {
                this._beginToken(n.DOC_TYPE_START, t), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === r.$GT), this._beginToken(n.DOC_TYPE_END), this._cursor.advance(), this._endToken([]);
              }
              _consumePrefixAndName() {
                let t = this._cursor.clone(), o = "";
                for (; this._cursor.peek() !== r.$COLON && !B(this._cursor.peek()); )
                  this._cursor.advance();
                let E;
                this._cursor.peek() === r.$COLON ? (o = this._cursor.getChars(t), this._cursor.advance(), E = this._cursor.clone()) : E = t, this._requireCharCodeUntilFn(T, o === "" ? 0 : 1);
                let f = this._cursor.getChars(E);
                return [o, f];
              }
              _consumeTagOpen(t) {
                let o, E, f, F = this.tokens.length, P2 = this._cursor.clone(), M = [];
                try {
                  if (!r.isAsciiLetter(this._cursor.peek()))
                    throw this._createError(c(this._cursor.peek()), this._cursor.getSpan(t));
                  for (f = this._consumeTagOpenStart(t), E = f.parts[0], o = f.parts[1], this._attemptCharCodeUntilFn(m); this._cursor.peek() !== r.$SLASH && this._cursor.peek() !== r.$GT; ) {
                    let [X, H] = this._consumeAttributeName();
                    if (this._attemptCharCodeUntilFn(m), this._attemptCharCode(r.$EQ)) {
                      this._attemptCharCodeUntilFn(m);
                      let z = this._consumeAttributeValue();
                      M.push({ prefix: X, name: H, value: z });
                    } else
                      M.push({ prefix: X, name: H });
                    this._attemptCharCodeUntilFn(m);
                  }
                  this._consumeTagOpenEnd();
                } catch (X) {
                  if (X instanceof C) {
                    this._cursor = P2, f && (this.tokens.length = F), this._beginToken(n.TEXT, t), this._endToken(["<"]);
                    return;
                  }
                  throw X;
                }
                if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === n.TAG_OPEN_END_VOID)
                  return;
                let W = this._getTagContentType(o, E, this._fullNameStack.length > 0, M);
                this._handleFullNameStackForTagOpen(E, o), W === D.TagContentType.RAW_TEXT ? this._consumeRawTextWithTagClose(E, o, false) : W === D.TagContentType.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(E, o, true);
              }
              _consumeRawTextWithTagClose(t, o, E) {
                let f = this._consumeRawText(E, () => !this._attemptCharCode(r.$LT) || !this._attemptCharCode(r.$SLASH) || (this._attemptCharCodeUntilFn(m), !this._attemptStrCaseInsensitive(t ? `${t}:${o}` : o)) ? false : (this._attemptCharCodeUntilFn(m), this._attemptCharCode(r.$GT)));
                this._beginToken(n.TAG_CLOSE), this._requireCharCodeUntilFn((F) => F === r.$GT, 3), this._cursor.advance(), this._endToken([t, o]), this._handleFullNameStackForTagClose(t, o);
              }
              _consumeTagOpenStart(t) {
                this._beginToken(n.TAG_OPEN_START, t);
                let o = this._consumePrefixAndName();
                return this._endToken(o);
              }
              _consumeAttributeName() {
                let t = this._cursor.peek();
                if (t === r.$SQ || t === r.$DQ)
                  throw this._createError(c(t), this._cursor.getSpan());
                this._beginToken(n.ATTR_NAME);
                let o = this._consumePrefixAndName();
                return this._endToken(o), o;
              }
              _consumeAttributeValue() {
                let t;
                if (this._cursor.peek() === r.$SQ || this._cursor.peek() === r.$DQ) {
                  this._beginToken(n.ATTR_QUOTE);
                  let o = this._cursor.peek();
                  this._cursor.advance(), this._endToken([String.fromCodePoint(o)]), this._beginToken(n.ATTR_VALUE);
                  let E = [];
                  for (; this._cursor.peek() !== o; )
                    E.push(this._readChar(true));
                  t = this._processCarriageReturns(E.join("")), this._endToken([t]), this._beginToken(n.ATTR_QUOTE), this._cursor.advance(), this._endToken([String.fromCodePoint(o)]);
                } else {
                  this._beginToken(n.ATTR_VALUE);
                  let o = this._cursor.clone();
                  this._requireCharCodeUntilFn(T, 1), t = this._processCarriageReturns(this._cursor.getChars(o)), this._endToken([t]);
                }
                return t;
              }
              _consumeTagOpenEnd() {
                let t = this._attemptCharCode(r.$SLASH) ? n.TAG_OPEN_END_VOID : n.TAG_OPEN_END;
                this._beginToken(t), this._requireCharCode(r.$GT), this._endToken([]);
              }
              _consumeTagClose(t) {
                if (this._beginToken(n.TAG_CLOSE, t), this._attemptCharCodeUntilFn(m), this._allowHtmComponentClosingTags && this._attemptCharCode(r.$SLASH))
                  this._attemptCharCodeUntilFn(m), this._requireCharCode(r.$GT), this._endToken([]);
                else {
                  let [o, E] = this._consumePrefixAndName();
                  this._attemptCharCodeUntilFn(m), this._requireCharCode(r.$GT), this._endToken([o, E]), this._handleFullNameStackForTagClose(o, E);
                }
              }
              _consumeExpansionFormStart() {
                this._beginToken(n.EXPANSION_FORM_START), this._requireCharCode(r.$LBRACE), this._endToken([]), this._expansionCaseStack.push(n.EXPANSION_FORM_START), this._beginToken(n.RAW_TEXT);
                let t = this._readUntil(r.$COMMA);
                this._endToken([t]), this._requireCharCode(r.$COMMA), this._attemptCharCodeUntilFn(m), this._beginToken(n.RAW_TEXT);
                let o = this._readUntil(r.$COMMA);
                this._endToken([o]), this._requireCharCode(r.$COMMA), this._attemptCharCodeUntilFn(m);
              }
              _consumeExpansionCaseStart() {
                this._beginToken(n.EXPANSION_CASE_VALUE);
                let t = this._readUntil(r.$LBRACE).trim();
                this._endToken([t]), this._attemptCharCodeUntilFn(m), this._beginToken(n.EXPANSION_CASE_EXP_START), this._requireCharCode(r.$LBRACE), this._endToken([]), this._attemptCharCodeUntilFn(m), this._expansionCaseStack.push(n.EXPANSION_CASE_EXP_START);
              }
              _consumeExpansionCaseEnd() {
                this._beginToken(n.EXPANSION_CASE_EXP_END), this._requireCharCode(r.$RBRACE), this._endToken([]), this._attemptCharCodeUntilFn(m), this._expansionCaseStack.pop();
              }
              _consumeExpansionFormEnd() {
                this._beginToken(n.EXPANSION_FORM_END), this._requireCharCode(r.$RBRACE), this._endToken([]), this._expansionCaseStack.pop();
              }
              _consumeText() {
                let t = this._cursor.clone();
                this._beginToken(n.TEXT, t);
                let o = [];
                do
                  this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (o.push(this._interpolationConfig.start), this._inInterpolation = true) : this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end) ? (o.push(this._interpolationConfig.end), this._inInterpolation = false) : o.push(this._readChar(true));
                while (!this._isTextEnd());
                this._endToken([this._processCarriageReturns(o.join(""))]);
              }
              _isTextEnd() {
                return !!(this._cursor.peek() === r.$LT || this._cursor.peek() === r.$EOF || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === r.$RBRACE && this._isInExpansionCase()));
              }
              _readUntil(t) {
                let o = this._cursor.clone();
                return this._attemptUntilChar(t), this._cursor.getChars(o);
              }
              _isInExpansionCase() {
                return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === n.EXPANSION_CASE_EXP_START;
              }
              _isInExpansionForm() {
                return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === n.EXPANSION_FORM_START;
              }
              isExpansionFormStart() {
                if (this._cursor.peek() !== r.$LBRACE)
                  return false;
                if (this._interpolationConfig) {
                  let t = this._cursor.clone(), o = this._attemptStr(this._interpolationConfig.start);
                  return this._cursor = t, !o;
                }
                return true;
              }
              _handleFullNameStackForTagOpen(t, o) {
                let E = D.mergeNsAndName(t, o);
                (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === E) && this._fullNameStack.push(E);
              }
              _handleFullNameStackForTagClose(t, o) {
                let E = D.mergeNsAndName(t, o);
                this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === E && this._fullNameStack.pop();
              }
            };
            function m(t) {
              return !r.isWhitespace(t) || t === r.$EOF;
            }
            function T(t) {
              return r.isWhitespace(t) || t === r.$GT || t === r.$SLASH || t === r.$SQ || t === r.$DQ || t === r.$EQ;
            }
            function B(t) {
              return (t < r.$a || r.$z < t) && (t < r.$A || r.$Z < t) && (t < r.$0 || t > r.$9);
            }
            function A3(t) {
              return t == r.$SEMICOLON || t == r.$EOF || !r.isAsciiHexDigit(t);
            }
            function N(t) {
              return t == r.$SEMICOLON || t == r.$EOF || !r.isAsciiLetter(t);
            }
            function R(t) {
              return t === r.$EQ || r.isAsciiLetter(t) || r.isDigit(t);
            }
            function j(t, o) {
              return _(t) == _(o);
            }
            function _(t) {
              return t >= r.$a && t <= r.$z ? t - r.$a + r.$A : t;
            }
            function O(t) {
              let o = [], E;
              for (let f = 0; f < t.length; f++) {
                let F = t[f];
                E && E.type == n.TEXT && F.type == n.TEXT ? (E.parts[0] += F.parts[0], E.sourceSpan.end = F.sourceSpan.end) : (E = F, o.push(E));
              }
              return o;
            }
            var x = class {
              constructor(t, o) {
                if (t instanceof x)
                  this.file = t.file, this.input = t.input, this.end = t.end, this.state = Object.assign({}, t.state);
                else {
                  if (!o)
                    throw new Error("Programming error: the range argument must be provided with a file argument.");
                  this.file = t, this.input = t.content, this.end = o.endPos, this.state = { peek: -1, offset: o.startPos, line: o.startLine, column: o.startCol };
                }
              }
              clone() {
                return new x(this);
              }
              peek() {
                return this.state.peek;
              }
              charsLeft() {
                return this.end - this.state.offset;
              }
              diff(t) {
                return this.state.offset - t.state.offset;
              }
              advance() {
                this.advanceState(this.state);
              }
              init() {
                this.updatePeek(this.state);
              }
              getSpan(t, o) {
                if (t = t || this, o)
                  for (t = t.clone(); this.diff(t) > 0 && o.indexOf(t.peek()) !== -1; )
                    t.advance();
                return new u.ParseSourceSpan(new u.ParseLocation(t.file, t.state.offset, t.state.line, t.state.column), new u.ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));
              }
              getChars(t) {
                return this.input.substring(t.state.offset, this.state.offset);
              }
              charAt(t) {
                return this.input.charCodeAt(t);
              }
              advanceState(t) {
                if (t.offset >= this.end)
                  throw this.state = t, new $('Unexpected character "EOF"', this);
                let o = this.charAt(t.offset);
                o === r.$LF ? (t.line++, t.column = 0) : r.isNewLine(o) || t.column++, t.offset++, this.updatePeek(t);
              }
              updatePeek(t) {
                t.peek = t.offset >= this.end ? r.$EOF : this.charAt(t.offset);
              }
            }, k = class extends x {
              constructor(t, o) {
                t instanceof k ? (super(t), this.internalState = Object.assign({}, t.internalState)) : (super(t, o), this.internalState = this.state);
              }
              advance() {
                this.state = this.internalState, super.advance(), this.processEscapeSequence();
              }
              init() {
                super.init(), this.processEscapeSequence();
              }
              clone() {
                return new k(this);
              }
              getChars(t) {
                let o = t.clone(), E = "";
                for (; o.internalState.offset < this.internalState.offset; )
                  E += String.fromCodePoint(o.peek()), o.advance();
                return E;
              }
              processEscapeSequence() {
                let t = () => this.internalState.peek;
                if (t() === r.$BACKSLASH)
                  if (this.internalState = Object.assign({}, this.state), this.advanceState(this.internalState), t() === r.$n)
                    this.state.peek = r.$LF;
                  else if (t() === r.$r)
                    this.state.peek = r.$CR;
                  else if (t() === r.$v)
                    this.state.peek = r.$VTAB;
                  else if (t() === r.$t)
                    this.state.peek = r.$TAB;
                  else if (t() === r.$b)
                    this.state.peek = r.$BSPACE;
                  else if (t() === r.$f)
                    this.state.peek = r.$FF;
                  else if (t() === r.$u)
                    if (this.advanceState(this.internalState), t() === r.$LBRACE) {
                      this.advanceState(this.internalState);
                      let o = this.clone(), E = 0;
                      for (; t() !== r.$RBRACE; )
                        this.advanceState(this.internalState), E++;
                      this.state.peek = this.decodeHexDigits(o, E);
                    } else {
                      let o = this.clone();
                      this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(o, 4);
                    }
                  else if (t() === r.$x) {
                    this.advanceState(this.internalState);
                    let o = this.clone();
                    this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(o, 2);
                  } else if (r.isOctalDigit(t())) {
                    let o = "", E = 0, f = this.clone();
                    for (; r.isOctalDigit(t()) && E < 3; )
                      f = this.clone(), o += String.fromCodePoint(t()), this.advanceState(this.internalState), E++;
                    this.state.peek = parseInt(o, 8), this.internalState = f.internalState;
                  } else
                    r.isNewLine(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
              }
              decodeHexDigits(t, o) {
                let E = this.input.substr(t.internalState.offset, o), f = parseInt(E, 16);
                if (isNaN(f))
                  throw t.state = t.internalState, new $("Invalid hexadecimal escape sequence", t);
                return f;
              }
            }, $ = class {
              constructor(t, o) {
                this.msg = t, this.cursor = o;
              }
            };
            e.CursorError = $;
          } }), Zn = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/parser.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            var r = ye(), u = Cs(), s = Ml(), D = Je(), n = class extends r.ParseError {
              constructor(a, c, h) {
                super(c, h), this.elementName = a;
              }
              static create(a, c, h) {
                return new n(a, c, h);
              }
            };
            e.TreeError = n;
            var i = class {
              constructor(a, c) {
                this.rootNodes = a, this.errors = c;
              }
            };
            e.ParseTreeResult = i;
            var p = class {
              constructor(a) {
                this.getTagDefinition = a;
              }
              parse(a, c, h) {
                let C = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, d = arguments.length > 4 ? arguments[4] : void 0, m = (x) => function(k) {
                  for (var $ = arguments.length, t = new Array($ > 1 ? $ - 1 : 0), o = 1; o < $; o++)
                    t[o - 1] = arguments[o];
                  return x(k.toLowerCase(), ...t);
                }, T = C ? this.getTagDefinition : m(this.getTagDefinition), B = (x) => T(x).contentType, A3 = C ? d : m(d), N = d ? (x, k, $, t) => {
                  let o = A3(x, k, $, t);
                  return o !== void 0 ? o : B(x);
                } : B, R = s.tokenize(a, c, N, h), j = h && h.canSelfClose || false, _ = h && h.allowHtmComponentClosingTags || false, O = new l(R.tokens, T, j, _, C).build();
                return new i(O.rootNodes, R.errors.concat(O.errors));
              }
            };
            e.Parser = p;
            var l = class {
              constructor(a, c, h, C, d) {
                this.tokens = a, this.getTagDefinition = c, this.canSelfClose = h, this.allowHtmComponentClosingTags = C, this.isTagNameCaseSensitive = d, this._index = -1, this._rootNodes = [], this._errors = [], this._elementStack = [], this._advance();
              }
              build() {
                for (; this._peek.type !== s.TokenType.EOF; )
                  this._peek.type === s.TokenType.TAG_OPEN_START ? this._consumeStartTag(this._advance()) : this._peek.type === s.TokenType.TAG_CLOSE ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === s.TokenType.CDATA_START ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === s.TokenType.COMMENT_START ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === s.TokenType.TEXT || this._peek.type === s.TokenType.RAW_TEXT || this._peek.type === s.TokenType.ESCAPABLE_RAW_TEXT ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === s.TokenType.EXPANSION_FORM_START ? this._consumeExpansion(this._advance()) : this._peek.type === s.TokenType.DOC_TYPE_START ? this._consumeDocType(this._advance()) : this._advance();
                return new i(this._rootNodes, this._errors);
              }
              _advance() {
                let a = this._peek;
                return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], a;
              }
              _advanceIf(a) {
                return this._peek.type === a ? this._advance() : null;
              }
              _consumeCdata(a) {
                let c = this._advance(), h = this._getText(c), C = this._advanceIf(s.TokenType.CDATA_END);
                this._addToParent(new u.CDATA(h, new r.ParseSourceSpan(a.sourceSpan.start, (C || c).sourceSpan.end)));
              }
              _consumeComment(a) {
                let c = this._advanceIf(s.TokenType.RAW_TEXT), h = this._advanceIf(s.TokenType.COMMENT_END), C = c != null ? c.parts[0].trim() : null, d = new r.ParseSourceSpan(a.sourceSpan.start, (h || c || a).sourceSpan.end);
                this._addToParent(new u.Comment(C, d));
              }
              _consumeDocType(a) {
                let c = this._advanceIf(s.TokenType.RAW_TEXT), h = this._advanceIf(s.TokenType.DOC_TYPE_END), C = c != null ? c.parts[0].trim() : null, d = new r.ParseSourceSpan(a.sourceSpan.start, (h || c || a).sourceSpan.end);
                this._addToParent(new u.DocType(C, d));
              }
              _consumeExpansion(a) {
                let c = this._advance(), h = this._advance(), C = [];
                for (; this._peek.type === s.TokenType.EXPANSION_CASE_VALUE; ) {
                  let m = this._parseExpansionCase();
                  if (!m)
                    return;
                  C.push(m);
                }
                if (this._peek.type !== s.TokenType.EXPANSION_FORM_END) {
                  this._errors.push(n.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
                  return;
                }
                let d = new r.ParseSourceSpan(a.sourceSpan.start, this._peek.sourceSpan.end);
                this._addToParent(new u.Expansion(c.parts[0], h.parts[0], C, d, c.sourceSpan)), this._advance();
              }
              _parseExpansionCase() {
                let a = this._advance();
                if (this._peek.type !== s.TokenType.EXPANSION_CASE_EXP_START)
                  return this._errors.push(n.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
                let c = this._advance(), h = this._collectExpansionExpTokens(c);
                if (!h)
                  return null;
                let C = this._advance();
                h.push(new s.Token(s.TokenType.EOF, [], C.sourceSpan));
                let d = new l(h, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive).build();
                if (d.errors.length > 0)
                  return this._errors = this._errors.concat(d.errors), null;
                let m = new r.ParseSourceSpan(a.sourceSpan.start, C.sourceSpan.end), T = new r.ParseSourceSpan(c.sourceSpan.start, C.sourceSpan.end);
                return new u.ExpansionCase(a.parts[0], d.rootNodes, m, a.sourceSpan, T);
              }
              _collectExpansionExpTokens(a) {
                let c = [], h = [s.TokenType.EXPANSION_CASE_EXP_START];
                for (; ; ) {
                  if ((this._peek.type === s.TokenType.EXPANSION_FORM_START || this._peek.type === s.TokenType.EXPANSION_CASE_EXP_START) && h.push(this._peek.type), this._peek.type === s.TokenType.EXPANSION_CASE_EXP_END)
                    if (g(h, s.TokenType.EXPANSION_CASE_EXP_START)) {
                      if (h.pop(), h.length == 0)
                        return c;
                    } else
                      return this._errors.push(n.create(null, a.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                  if (this._peek.type === s.TokenType.EXPANSION_FORM_END)
                    if (g(h, s.TokenType.EXPANSION_FORM_START))
                      h.pop();
                    else
                      return this._errors.push(n.create(null, a.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                  if (this._peek.type === s.TokenType.EOF)
                    return this._errors.push(n.create(null, a.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                  c.push(this._advance());
                }
              }
              _getText(a) {
                let c = a.parts[0];
                if (c.length > 0 && c[0] == `
`) {
                  let h = this._getParentElement();
                  h != null && h.children.length == 0 && this.getTagDefinition(h.name).ignoreFirstLf && (c = c.substring(1));
                }
                return c;
              }
              _consumeText(a) {
                let c = this._getText(a);
                c.length > 0 && this._addToParent(new u.Text(c, a.sourceSpan));
              }
              _closeVoidElement() {
                let a = this._getParentElement();
                a && this.getTagDefinition(a.name).isVoid && this._elementStack.pop();
              }
              _consumeStartTag(a) {
                let c = a.parts[0], h = a.parts[1], C = [];
                for (; this._peek.type === s.TokenType.ATTR_NAME; )
                  C.push(this._consumeAttr(this._advance()));
                let d = this._getElementFullName(c, h, this._getParentElement()), m = false;
                if (this._peek.type === s.TokenType.TAG_OPEN_END_VOID) {
                  this._advance(), m = true;
                  let R = this.getTagDefinition(d);
                  this.canSelfClose || R.canSelfClose || D.getNsPrefix(d) !== null || R.isVoid || this._errors.push(n.create(d, a.sourceSpan, `Only void and foreign elements can be self closed "${a.parts[1]}"`));
                } else
                  this._peek.type === s.TokenType.TAG_OPEN_END && (this._advance(), m = false);
                let T = this._peek.sourceSpan.start, B = new r.ParseSourceSpan(a.sourceSpan.start, T), A3 = new r.ParseSourceSpan(a.sourceSpan.start.moveBy(1), a.sourceSpan.end), N = new u.Element(d, C, [], B, B, void 0, A3);
                this._pushElement(N), m && (this._popElement(d), N.endSourceSpan = B);
              }
              _pushElement(a) {
                let c = this._getParentElement();
                c && this.getTagDefinition(c.name).isClosedByChild(a.name) && this._elementStack.pop(), this._addToParent(a), this._elementStack.push(a);
              }
              _consumeEndTag(a) {
                let c = this.allowHtmComponentClosingTags && a.parts.length === 0 ? null : this._getElementFullName(a.parts[0], a.parts[1], this._getParentElement());
                if (this._getParentElement() && (this._getParentElement().endSourceSpan = a.sourceSpan), c && this.getTagDefinition(c).isVoid)
                  this._errors.push(n.create(c, a.sourceSpan, `Void elements do not have end tags "${a.parts[1]}"`));
                else if (!this._popElement(c)) {
                  let h = `Unexpected closing tag "${c}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
                  this._errors.push(n.create(c, a.sourceSpan, h));
                }
              }
              _popElement(a) {
                for (let c = this._elementStack.length - 1; c >= 0; c--) {
                  let h = this._elementStack[c];
                  if (!a || (D.getNsPrefix(h.name) ? h.name == a : h.name.toLowerCase() == a.toLowerCase()))
                    return this._elementStack.splice(c, this._elementStack.length - c), true;
                  if (!this.getTagDefinition(h.name).closedByParent)
                    return false;
                }
                return false;
              }
              _consumeAttr(a) {
                let c = D.mergeNsAndName(a.parts[0], a.parts[1]), h = a.sourceSpan.end, C = "", d, m;
                if (this._peek.type === s.TokenType.ATTR_QUOTE && (m = this._advance().sourceSpan.start), this._peek.type === s.TokenType.ATTR_VALUE) {
                  let T = this._advance();
                  C = T.parts[0], h = T.sourceSpan.end, d = T.sourceSpan;
                }
                return this._peek.type === s.TokenType.ATTR_QUOTE && (h = this._advance().sourceSpan.end, d = new r.ParseSourceSpan(m, h)), new u.Attribute(c, C, new r.ParseSourceSpan(a.sourceSpan.start, h), d, a.sourceSpan);
              }
              _getParentElement() {
                return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
              }
              _getParentElementSkippingContainers() {
                let a = null;
                for (let c = this._elementStack.length - 1; c >= 0; c--) {
                  if (!D.isNgContainer(this._elementStack[c].name))
                    return { parent: this._elementStack[c], container: a };
                  a = this._elementStack[c];
                }
                return { parent: null, container: a };
              }
              _addToParent(a) {
                let c = this._getParentElement();
                c != null ? c.children.push(a) : this._rootNodes.push(a);
              }
              _insertBeforeContainer(a, c, h) {
                if (!c)
                  this._addToParent(h), this._elementStack.push(h);
                else {
                  if (a) {
                    let C = a.children.indexOf(c);
                    a.children[C] = h;
                  } else
                    this._rootNodes.push(h);
                  h.children.push(c), this._elementStack.splice(this._elementStack.indexOf(c), 0, h);
                }
              }
              _getElementFullName(a, c, h) {
                return a === "" && (a = this.getTagDefinition(c).implicitNamespacePrefix || "", a === "" && h != null && (a = D.getNsPrefix(h.name))), D.mergeNsAndName(a, c);
              }
            };
            function g(a, c) {
              return a.length > 0 && a[a.length - 1] === c;
            }
          } }), jl = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/html_parser.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Es(), u = Zn(), s = Zn();
            e.ParseTreeResult = s.ParseTreeResult, e.TreeError = s.TreeError;
            var D = class extends u.Parser {
              constructor() {
                super(r.getHtmlTagDefinition);
              }
              parse(n, i, p) {
                let l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, g = arguments.length > 4 ? arguments[4] : void 0;
                return super.parse(n, i, p, l, g);
              }
            };
            e.HtmlParser = D;
          } }), ms = I({ "node_modules/angular-html-parser/lib/angular-html-parser/src/index.js"(e) {
            "use strict";
            q(), Object.defineProperty(e, "__esModule", { value: true });
            var r = jl(), u = Je();
            e.TagContentType = u.TagContentType;
            var s = null, D = () => (s || (s = new r.HtmlParser()), s);
            function n(i) {
              let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { canSelfClose: l = false, allowHtmComponentClosingTags: g = false, isTagNameCaseSensitive: a = false, getTagContentType: c } = p;
              return D().parse(i, "angular-html-parser", { tokenizeExpansionForms: false, interpolationConfig: void 0, canSelfClose: l, allowHtmComponentClosingTags: g }, a, c);
            }
            e.parse = n;
          } });
          q();
          var { ParseSourceSpan: Ye, ParseLocation: es, ParseSourceFile: Ul } = ye(), Gl = ZD(), Vl = is(), Xl = el(), { inferParserByLanguage: Hl } = Tl(), zl = bl(), $r = Ol(), rs = ql(), { hasPragma: Wl } = Il(), { Node: Yl } = Rl(), { parseIeConditionalComment: Ql } = xl(), { locStart: Kl, locEnd: Jl } = Pl();
          function Zl(e, r, u) {
            let { recognizeSelfClosing: s, normalizeTagName: D, normalizeAttributeName: n, allowHtmComponentClosingTags: i, isTagNameCaseSensitive: p, getTagContentType: l } = r, g = ms(), { RecursiveVisitor: a, visitAll: c } = Cs(), { ParseSourceSpan: h } = ye(), { getHtmlTagDefinition: C } = Es(), { rootNodes: d, errors: m } = g.parse(e, { canSelfClose: s, allowHtmComponentClosingTags: i, isTagNameCaseSensitive: p, getTagContentType: l });
            if (u.parser === "vue")
              if (d.some((O) => O.type === "docType" && O.value === "html" || O.type === "element" && O.name.toLowerCase() === "html")) {
                s = true, D = true, n = true, i = true, p = false;
                let O = g.parse(e, { canSelfClose: s, allowHtmComponentClosingTags: i, isTagNameCaseSensitive: p });
                d = O.rootNodes, m = O.errors;
              } else {
                let O = (x) => {
                  if (!x || x.type !== "element" || x.name !== "template")
                    return false;
                  let k = x.attrs.find((t) => t.name === "lang"), $ = k && k.value;
                  return !$ || Hl($, u) === "html";
                };
                if (d.some(O)) {
                  let x, k = () => g.parse(e, { canSelfClose: s, allowHtmComponentClosingTags: i, isTagNameCaseSensitive: p }), $ = () => x || (x = k()), t = (o) => $().rootNodes.find((E) => {
                    let { startSourceSpan: f } = E;
                    return f && f.start.offset === o.startSourceSpan.start.offset;
                  });
                  for (let o = 0; o < d.length; o++) {
                    let E = d[o], { endSourceSpan: f, startSourceSpan: F } = E;
                    if (f === null)
                      m = $().errors, d[o] = t(E) || E;
                    else if (O(E)) {
                      let M = $(), W = F.end.offset, X = f.start.offset;
                      for (let H of M.errors) {
                        let { offset: z } = H.span.start;
                        if (W < z && z < X) {
                          m = [H];
                          break;
                        }
                      }
                      d[o] = t(E) || E;
                    }
                  }
                }
              }
            if (m.length > 0) {
              let { msg: _, span: { start: O, end: x } } = m[0];
              throw Xl(_, { start: { line: O.line + 1, column: O.col + 1 }, end: { line: x.line + 1, column: x.col + 1 } });
            }
            let T = (_) => {
              let O = _.name.startsWith(":") ? _.name.slice(1).split(":")[0] : null, x = _.nameSpan.toString(), k = O !== null && x.startsWith(`${O}:`), $ = k ? x.slice(O.length + 1) : x;
              _.name = $, _.namespace = O, _.hasExplicitNamespace = k;
            }, B = (_) => {
              switch (_.type) {
                case "element":
                  T(_);
                  for (let O of _.attrs)
                    T(O), O.valueSpan ? (O.value = O.valueSpan.toString(), /["']/.test(O.value[0]) && (O.value = O.value.slice(1, -1))) : O.value = null;
                  break;
                case "comment":
                  _.value = _.sourceSpan.toString().slice(4, -3);
                  break;
                case "text":
                  _.value = _.sourceSpan.toString();
                  break;
              }
            }, A3 = (_, O) => {
              let x = _.toLowerCase();
              return O(x) ? x : _;
            }, N = (_) => {
              if (_.type === "element" && (D && (!_.namespace || _.namespace === _.tagDefinition.implicitNamespacePrefix || rs(_)) && (_.name = A3(_.name, (O) => O in zl)), n)) {
                let O = $r[_.name] || /* @__PURE__ */ Object.create(null);
                for (let x of _.attrs)
                  x.namespace || (x.name = A3(x.name, (k) => _.name in $r && (k in $r["*"] || k in O)));
              }
            }, R = (_) => {
              _.sourceSpan && _.endSourceSpan && (_.sourceSpan = new h(_.sourceSpan.start, _.endSourceSpan.end));
            }, j = (_) => {
              if (_.type === "element") {
                let O = C(p ? _.name : _.name.toLowerCase());
                !_.namespace || _.namespace === O.implicitNamespacePrefix || rs(_) ? _.tagDefinition = O : _.tagDefinition = C("");
              }
            };
            return c(new class extends a {
              visit(_) {
                B(_), j(_), N(_), R(_);
              }
            }(), d), d;
          }
          function gs(e, r, u) {
            let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, { frontMatter: D, content: n } = s ? Gl(e) : { frontMatter: null, content: e }, i = new Ul(e, r.filepath), p = new es(i, 0, 0, 0), l = p.moveBy(e.length), g = { type: "root", sourceSpan: new Ye(p, l), children: Zl(n, u, r) };
            if (D) {
              let h = new es(i, 0, 0, 0), C = h.moveBy(D.raw.length);
              D.sourceSpan = new Ye(h, C), g.children.unshift(D);
            }
            let a = new Yl(g), c = (h, C) => {
              let { offset: d } = C, m = e.slice(0, d).replace(/[^\n\r]/g, " "), B = gs(m + h, r, u, false);
              B.sourceSpan = new Ye(C, Vl(B.children).sourceSpan.end);
              let A3 = B.children[0];
              return A3.length === d ? B.children.shift() : (A3.sourceSpan = new Ye(A3.sourceSpan.start.moveBy(d), A3.sourceSpan.end), A3.value = A3.value.slice(d)), B;
            };
            return a.walk((h) => {
              if (h.type === "comment") {
                let C = Ql(h, c);
                C && h.parent.replaceChild(h, C);
              }
            }), a;
          }
          function Qe() {
            let { name: e, recognizeSelfClosing: r = false, normalizeTagName: u = false, normalizeAttributeName: s = false, allowHtmComponentClosingTags: D = false, isTagNameCaseSensitive: n = false, getTagContentType: i } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return { parse: (p, l, g) => gs(p, Object.assign({ parser: e }, g), { recognizeSelfClosing: r, normalizeTagName: u, normalizeAttributeName: s, allowHtmComponentClosingTags: D, isTagNameCaseSensitive: n, getTagContentType: i }), hasPragma: Wl, astFormat: "html", locStart: Kl, locEnd: Jl };
          }
          Fs.exports = { parsers: { html: Qe({ name: "html", recognizeSelfClosing: true, normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true }), angular: Qe({ name: "angular" }), vue: Qe({ name: "vue", recognizeSelfClosing: true, isTagNameCaseSensitive: true, getTagContentType: (e, r, u, s) => {
            if (e.toLowerCase() !== "html" && !u && (e !== "template" || s.some((D) => {
              let { name: n, value: i } = D;
              return n === "lang" && i !== "html" && i !== "" && i !== void 0;
            })))
              return ms().TagContentType.RAW_TEXT;
          } }), lwc: Qe({ name: "lwc" }) } };
        });
        return ec();
      });
    } });
    require_standalone = __commonJS2({ "../../node_modules/prettier/standalone.js"(exports, module2) {
      (function(e) {
        if (typeof exports == "object" && typeof module2 == "object")
          module2.exports = e();
        else if (typeof define == "function" && define.amd)
          define(e);
        else {
          var f = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
          f.prettier = e();
        }
      })(function() {
        "use strict";
        var Ne = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports), Qe = Ne((Ng, nu) => {
          var ur = function(e) {
            return e && e.Math == Math && e;
          };
          nu.exports = ur(typeof globalThis == "object" && globalThis) || ur(typeof window == "object" && window) || ur(typeof self == "object" && self) || ur(typeof global == "object" && global) || function() {
            return this;
          }() || Function("return this")();
        }), dt = Ne((wg, uu) => {
          uu.exports = function(e) {
            try {
              return !!e();
            } catch {
              return true;
            }
          };
        }), Ft = Ne((_g, su) => {
          var vo = dt();
          su.exports = !vo(function() {
            return Object.defineProperty({}, 1, { get: function() {
              return 7;
            } })[1] != 7;
          });
        }), sr = Ne((Pg, iu) => {
          var Co = dt();
          iu.exports = !Co(function() {
            var e = function() {
            }.bind();
            return typeof e != "function" || e.hasOwnProperty("prototype");
          });
        }), At = Ne((Ig, au) => {
          var Eo = sr(), ir = Function.prototype.call;
          au.exports = Eo ? ir.bind(ir) : function() {
            return ir.apply(ir, arguments);
          };
        }), pu = Ne((cu) => {
          "use strict";
          var ou = {}.propertyIsEnumerable, lu = Object.getOwnPropertyDescriptor, Fo = lu && !ou.call({ 1: 2 }, 1);
          cu.f = Fo ? function(n) {
            var t = lu(this, n);
            return !!t && t.enumerable;
          } : ou;
        }), ar = Ne((Lg, fu) => {
          fu.exports = function(e, n) {
            return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: n };
          };
        }), ct = Ne((jg, du) => {
          var Du = sr(), mu = Function.prototype, Ao = mu.bind, Mr = mu.call, So = Du && Ao.bind(Mr, Mr);
          du.exports = Du ? function(e) {
            return e && So(e);
          } : function(e) {
            return e && function() {
              return Mr.apply(e, arguments);
            };
          };
        }), or = Ne((Og, yu) => {
          var gu = ct(), xo = gu({}.toString), bo = gu("".slice);
          yu.exports = function(e) {
            return bo(xo(e), 8, -1);
          };
        }), vu = Ne((qg, hu) => {
          var To = Qe(), Bo = ct(), No = dt(), wo = or(), Rr = To.Object, _o = Bo("".split);
          hu.exports = No(function() {
            return !Rr("z").propertyIsEnumerable(0);
          }) ? function(e) {
            return wo(e) == "String" ? _o(e, "") : Rr(e);
          } : Rr;
        }), $r = Ne((Mg, Cu) => {
          var Po = Qe(), Io = Po.TypeError;
          Cu.exports = function(e) {
            if (e == null)
              throw Io("Can't call method on " + e);
            return e;
          };
        }), lr = Ne((Rg, Eu) => {
          var ko = vu(), Lo = $r();
          Eu.exports = function(e) {
            return ko(Lo(e));
          };
        }), pt = Ne(($g, Fu) => {
          Fu.exports = function(e) {
            return typeof e == "function";
          };
        }), St = Ne((Vg, Au) => {
          var jo = pt();
          Au.exports = function(e) {
            return typeof e == "object" ? e !== null : jo(e);
          };
        }), $t = Ne((Wg, Su) => {
          var Vr = Qe(), Oo = pt(), qo = function(e) {
            return Oo(e) ? e : void 0;
          };
          Su.exports = function(e, n) {
            return arguments.length < 2 ? qo(Vr[e]) : Vr[e] && Vr[e][n];
          };
        }), Wr = Ne((Hg, xu) => {
          var Mo = ct();
          xu.exports = Mo({}.isPrototypeOf);
        }), Tu = Ne((Gg, bu) => {
          var Ro = $t();
          bu.exports = Ro("navigator", "userAgent") || "";
        }), ku = Ne((Ug, Iu) => {
          var Pu = Qe(), Hr = Tu(), Bu = Pu.process, Nu = Pu.Deno, wu = Bu && Bu.versions || Nu && Nu.version, _u = wu && wu.v8, mt, cr;
          _u && (mt = _u.split("."), cr = mt[0] > 0 && mt[0] < 4 ? 1 : +(mt[0] + mt[1])), !cr && Hr && (mt = Hr.match(/Edge\/(\d+)/), (!mt || mt[1] >= 74) && (mt = Hr.match(/Chrome\/(\d+)/), mt && (cr = +mt[1]))), Iu.exports = cr;
        }), Gr = Ne((Jg, ju) => {
          var Lu = ku(), $o = dt();
          ju.exports = !!Object.getOwnPropertySymbols && !$o(function() {
            var e = Symbol();
            return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Lu && Lu < 41;
          });
        }), Ur = Ne((zg, Ou) => {
          var Vo = Gr();
          Ou.exports = Vo && !Symbol.sham && typeof Symbol.iterator == "symbol";
        }), Jr = Ne((Xg, qu) => {
          var Wo = Qe(), Ho = $t(), Go = pt(), Uo = Wr(), Jo = Ur(), zo = Wo.Object;
          qu.exports = Jo ? function(e) {
            return typeof e == "symbol";
          } : function(e) {
            var n = Ho("Symbol");
            return Go(n) && Uo(n.prototype, zo(e));
          };
        }), pr = Ne((Kg, Mu) => {
          var Xo = Qe(), Ko = Xo.String;
          Mu.exports = function(e) {
            try {
              return Ko(e);
            } catch {
              return "Object";
            }
          };
        }), Vt = Ne((Yg, Ru) => {
          var Yo = Qe(), Qo = pt(), Zo = pr(), el = Yo.TypeError;
          Ru.exports = function(e) {
            if (Qo(e))
              return e;
            throw el(Zo(e) + " is not a function");
          };
        }), fr = Ne((Qg, $u) => {
          var tl = Vt();
          $u.exports = function(e, n) {
            var t = e[n];
            return t == null ? void 0 : tl(t);
          };
        }), Wu = Ne((Zg, Vu) => {
          var rl = Qe(), zr = At(), Xr = pt(), Kr = St(), nl = rl.TypeError;
          Vu.exports = function(e, n) {
            var t, s;
            if (n === "string" && Xr(t = e.toString) && !Kr(s = zr(t, e)) || Xr(t = e.valueOf) && !Kr(s = zr(t, e)) || n !== "string" && Xr(t = e.toString) && !Kr(s = zr(t, e)))
              return s;
            throw nl("Can't convert object to primitive value");
          };
        }), Gu = Ne((e0, Hu) => {
          Hu.exports = false;
        }), Dr = Ne((t0, Ju) => {
          var Uu = Qe(), ul = Object.defineProperty;
          Ju.exports = function(e, n) {
            try {
              ul(Uu, e, { value: n, configurable: true, writable: true });
            } catch {
              Uu[e] = n;
            }
            return n;
          };
        }), mr = Ne((r0, Xu) => {
          var sl = Qe(), il = Dr(), zu = "__core-js_shared__", al = sl[zu] || il(zu, {});
          Xu.exports = al;
        }), Yr = Ne((n0, Yu) => {
          var ol = Gu(), Ku = mr();
          (Yu.exports = function(e, n) {
            return Ku[e] || (Ku[e] = n !== void 0 ? n : {});
          })("versions", []).push({ version: "3.22.2", mode: ol ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
        }), dr = Ne((u0, Qu) => {
          var ll = Qe(), cl = $r(), pl = ll.Object;
          Qu.exports = function(e) {
            return pl(cl(e));
          };
        }), ht = Ne((s0, Zu) => {
          var fl = ct(), Dl = dr(), ml = fl({}.hasOwnProperty);
          Zu.exports = Object.hasOwn || function(n, t) {
            return ml(Dl(n), t);
          };
        }), Qr = Ne((i0, es) => {
          var dl = ct(), gl = 0, yl = Math.random(), hl = dl(1 .toString);
          es.exports = function(e) {
            return "Symbol(" + (e === void 0 ? "" : e) + ")_" + hl(++gl + yl, 36);
          };
        }), bt = Ne((a0, ss) => {
          var vl = Qe(), Cl = Yr(), ts = ht(), El = Qr(), rs = Gr(), us = Ur(), _t = Cl("wks"), xt = vl.Symbol, ns = xt && xt.for, Fl = us ? xt : xt && xt.withoutSetter || El;
          ss.exports = function(e) {
            if (!ts(_t, e) || !(rs || typeof _t[e] == "string")) {
              var n = "Symbol." + e;
              rs && ts(xt, e) ? _t[e] = xt[e] : us && ns ? _t[e] = ns(n) : _t[e] = Fl(n);
            }
            return _t[e];
          };
        }), ls = Ne((o0, os) => {
          var Al = Qe(), Sl = At(), is = St(), as = Jr(), xl = fr(), bl = Wu(), Tl = bt(), Bl = Al.TypeError, Nl = Tl("toPrimitive");
          os.exports = function(e, n) {
            if (!is(e) || as(e))
              return e;
            var t = xl(e, Nl), s;
            if (t) {
              if (n === void 0 && (n = "default"), s = Sl(t, e, n), !is(s) || as(s))
                return s;
              throw Bl("Can't convert object to primitive value");
            }
            return n === void 0 && (n = "number"), bl(e, n);
          };
        }), gr = Ne((l0, cs) => {
          var wl = ls(), _l = Jr();
          cs.exports = function(e) {
            var n = wl(e, "string");
            return _l(n) ? n : n + "";
          };
        }), Ds = Ne((c0, fs) => {
          var Pl = Qe(), ps = St(), Zr = Pl.document, Il = ps(Zr) && ps(Zr.createElement);
          fs.exports = function(e) {
            return Il ? Zr.createElement(e) : {};
          };
        }), en = Ne((p0, ms) => {
          var kl = Ft(), Ll = dt(), jl = Ds();
          ms.exports = !kl && !Ll(function() {
            return Object.defineProperty(jl("div"), "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        }), tn = Ne((gs) => {
          var Ol = Ft(), ql = At(), Ml = pu(), Rl = ar(), $l = lr(), Vl = gr(), Wl = ht(), Hl = en(), ds = Object.getOwnPropertyDescriptor;
          gs.f = Ol ? ds : function(n, t) {
            if (n = $l(n), t = Vl(t), Hl)
              try {
                return ds(n, t);
              } catch {
              }
            if (Wl(n, t))
              return Rl(!ql(Ml.f, n, t), n[t]);
          };
        }), hs = Ne((D0, ys) => {
          var Gl = Ft(), Ul = dt();
          ys.exports = Gl && Ul(function() {
            return Object.defineProperty(function() {
            }, "prototype", { value: 42, writable: false }).prototype != 42;
          });
        }), Pt = Ne((m0, Cs) => {
          var vs = Qe(), Jl = St(), zl = vs.String, Xl = vs.TypeError;
          Cs.exports = function(e) {
            if (Jl(e))
              return e;
            throw Xl(zl(e) + " is not an object");
          };
        }), hr = Ne((Fs) => {
          var Kl = Qe(), Yl = Ft(), Ql = en(), Zl = hs(), yr = Pt(), Es = gr(), ec = Kl.TypeError, rn = Object.defineProperty, tc = Object.getOwnPropertyDescriptor, nn = "enumerable", un = "configurable", sn = "writable";
          Fs.f = Yl ? Zl ? function(n, t, s) {
            if (yr(n), t = Es(t), yr(s), typeof n == "function" && t === "prototype" && "value" in s && sn in s && !s[sn]) {
              var a = tc(n, t);
              a && a[sn] && (n[t] = s.value, s = { configurable: un in s ? s[un] : a[un], enumerable: nn in s ? s[nn] : a[nn], writable: false });
            }
            return rn(n, t, s);
          } : rn : function(n, t, s) {
            if (yr(n), t = Es(t), yr(s), Ql)
              try {
                return rn(n, t, s);
              } catch {
              }
            if ("get" in s || "set" in s)
              throw ec("Accessors not supported");
            return "value" in s && (n[t] = s.value), n;
          };
        }), vr = Ne((g0, As) => {
          var rc = Ft(), nc = hr(), uc = ar();
          As.exports = rc ? function(e, n, t) {
            return nc.f(e, n, uc(1, t));
          } : function(e, n, t) {
            return e[n] = t, e;
          };
        }), Cr = Ne((y0, Ss) => {
          var sc = ct(), ic = pt(), an = mr(), ac = sc(Function.toString);
          ic(an.inspectSource) || (an.inspectSource = function(e) {
            return ac(e);
          }), Ss.exports = an.inspectSource;
        }), Ts = Ne((h0, bs) => {
          var oc = Qe(), lc = pt(), cc = Cr(), xs = oc.WeakMap;
          bs.exports = lc(xs) && /native code/.test(cc(xs));
        }), ws = Ne((v0, Ns) => {
          var pc = Yr(), fc = Qr(), Bs = pc("keys");
          Ns.exports = function(e) {
            return Bs[e] || (Bs[e] = fc(e));
          };
        }), on = Ne((C0, _s) => {
          _s.exports = {};
        }), Os = Ne((E0, js) => {
          var Dc = Ts(), Ls = Qe(), ln = ct(), mc = St(), dc = vr(), cn = ht(), pn = mr(), gc = ws(), yc = on(), Ps = "Object already initialized", Dn = Ls.TypeError, hc = Ls.WeakMap, Er, Wt, Fr, vc = function(e) {
            return Fr(e) ? Wt(e) : Er(e, {});
          }, Cc = function(e) {
            return function(n) {
              var t;
              if (!mc(n) || (t = Wt(n)).type !== e)
                throw Dn("Incompatible receiver, " + e + " required");
              return t;
            };
          };
          Dc || pn.state ? (vt = pn.state || (pn.state = new hc()), Is = ln(vt.get), fn = ln(vt.has), ks = ln(vt.set), Er = function(e, n) {
            if (fn(vt, e))
              throw new Dn(Ps);
            return n.facade = e, ks(vt, e, n), n;
          }, Wt = function(e) {
            return Is(vt, e) || {};
          }, Fr = function(e) {
            return fn(vt, e);
          }) : (Tt = gc("state"), yc[Tt] = true, Er = function(e, n) {
            if (cn(e, Tt))
              throw new Dn(Ps);
            return n.facade = e, dc(e, Tt, n), n;
          }, Wt = function(e) {
            return cn(e, Tt) ? e[Tt] : {};
          }, Fr = function(e) {
            return cn(e, Tt);
          });
          var vt, Is, fn, ks, Tt;
          js.exports = { set: Er, get: Wt, has: Fr, enforce: vc, getterFor: Cc };
        }), Rs = Ne((F0, Ms) => {
          var mn = Ft(), Ec = ht(), qs = Function.prototype, Fc = mn && Object.getOwnPropertyDescriptor, dn = Ec(qs, "name"), Ac = dn && function() {
          }.name === "something", Sc = dn && (!mn || mn && Fc(qs, "name").configurable);
          Ms.exports = { EXISTS: dn, PROPER: Ac, CONFIGURABLE: Sc };
        }), Gs = Ne((A0, Hs) => {
          var xc = Qe(), $s = pt(), bc = ht(), Vs = vr(), Tc = Dr(), Bc = Cr(), Ws = Os(), Nc = Rs().CONFIGURABLE, wc = Ws.get, _c = Ws.enforce, Pc = String(String).split("String");
          (Hs.exports = function(e, n, t, s) {
            var a = s ? !!s.unsafe : false, r = s ? !!s.enumerable : false, u = s ? !!s.noTargetGet : false, i = s && s.name !== void 0 ? s.name : n, l;
            if ($s(t) && (String(i).slice(0, 7) === "Symbol(" && (i = "[" + String(i).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!bc(t, "name") || Nc && t.name !== i) && Vs(t, "name", i), l = _c(t), l.source || (l.source = Pc.join(typeof i == "string" ? i : ""))), e === xc) {
              r ? e[n] = t : Tc(n, t);
              return;
            } else
              a ? !u && e[n] && (r = true) : delete e[n];
            r ? e[n] = t : Vs(e, n, t);
          })(Function.prototype, "toString", function() {
            return $s(this) && wc(this).source || Bc(this);
          });
        }), Ar = Ne((S0, Us) => {
          var Ic = Math.ceil, kc = Math.floor;
          Us.exports = function(e) {
            var n = +e;
            return n !== n || n === 0 ? 0 : (n > 0 ? kc : Ic)(n);
          };
        }), zs = Ne((x0, Js) => {
          var Lc = Ar(), jc = Math.max, Oc = Math.min;
          Js.exports = function(e, n) {
            var t = Lc(e);
            return t < 0 ? jc(t + n, 0) : Oc(t, n);
          };
        }), Ks = Ne((b0, Xs) => {
          var qc = Ar(), Mc = Math.min;
          Xs.exports = function(e) {
            return e > 0 ? Mc(qc(e), 9007199254740991) : 0;
          };
        }), It = Ne((T0, Ys) => {
          var Rc = Ks();
          Ys.exports = function(e) {
            return Rc(e.length);
          };
        }), ei = Ne((B0, Zs) => {
          var $c = lr(), Vc = zs(), Wc = It(), Qs = function(e) {
            return function(n, t, s) {
              var a = $c(n), r = Wc(a), u = Vc(s, r), i;
              if (e && t != t) {
                for (; r > u; )
                  if (i = a[u++], i != i)
                    return true;
              } else
                for (; r > u; u++)
                  if ((e || u in a) && a[u] === t)
                    return e || u || 0;
              return !e && -1;
            };
          };
          Zs.exports = { includes: Qs(true), indexOf: Qs(false) };
        }), ni = Ne((N0, ri) => {
          var Hc = ct(), gn = ht(), Gc = lr(), Uc = ei().indexOf, Jc = on(), ti = Hc([].push);
          ri.exports = function(e, n) {
            var t = Gc(e), s = 0, a = [], r;
            for (r in t)
              !gn(Jc, r) && gn(t, r) && ti(a, r);
            for (; n.length > s; )
              gn(t, r = n[s++]) && (~Uc(a, r) || ti(a, r));
            return a;
          };
        }), si = Ne((w0, ui) => {
          ui.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
        }), ai = Ne((ii) => {
          var zc = ni(), Xc = si(), Kc = Xc.concat("length", "prototype");
          ii.f = Object.getOwnPropertyNames || function(n) {
            return zc(n, Kc);
          };
        }), li = Ne((oi) => {
          oi.f = Object.getOwnPropertySymbols;
        }), pi = Ne((I0, ci) => {
          var Yc = $t(), Qc = ct(), Zc = ai(), ep = li(), tp = Pt(), rp = Qc([].concat);
          ci.exports = Yc("Reflect", "ownKeys") || function(n) {
            var t = Zc.f(tp(n)), s = ep.f;
            return s ? rp(t, s(n)) : t;
          };
        }), mi = Ne((k0, Di) => {
          var fi = ht(), np = pi(), up = tn(), sp = hr();
          Di.exports = function(e, n, t) {
            for (var s = np(n), a = sp.f, r = up.f, u = 0; u < s.length; u++) {
              var i = s[u];
              !fi(e, i) && !(t && fi(t, i)) && a(e, i, r(n, i));
            }
          };
        }), gi = Ne((L0, di) => {
          var ip = dt(), ap = pt(), op = /#|\.prototype\./, Ht = function(e, n) {
            var t = cp[lp(e)];
            return t == fp ? true : t == pp ? false : ap(n) ? ip(n) : !!n;
          }, lp = Ht.normalize = function(e) {
            return String(e).replace(op, ".").toLowerCase();
          }, cp = Ht.data = {}, pp = Ht.NATIVE = "N", fp = Ht.POLYFILL = "P";
          di.exports = Ht;
        }), Gt = Ne((j0, yi) => {
          var yn = Qe(), Dp = tn().f, mp = vr(), dp = Gs(), gp = Dr(), yp = mi(), hp = gi();
          yi.exports = function(e, n) {
            var t = e.target, s = e.global, a = e.stat, r, u, i, l, c, y;
            if (s ? u = yn : a ? u = yn[t] || gp(t, {}) : u = (yn[t] || {}).prototype, u)
              for (i in n) {
                if (c = n[i], e.noTargetGet ? (y = Dp(u, i), l = y && y.value) : l = u[i], r = hp(s ? i : t + (a ? "." : "#") + i, e.forced), !r && l !== void 0) {
                  if (typeof c == typeof l)
                    continue;
                  yp(c, l);
                }
                (e.sham || l && l.sham) && mp(c, "sham", true), dp(u, i, c, e);
              }
          };
        }), hn = Ne((O0, hi) => {
          var vp = or();
          hi.exports = Array.isArray || function(n) {
            return vp(n) == "Array";
          };
        }), vn = Ne((q0, Ci) => {
          var vi = ct(), Cp = Vt(), Ep = sr(), Fp = vi(vi.bind);
          Ci.exports = function(e, n) {
            return Cp(e), n === void 0 ? e : Ep ? Fp(e, n) : function() {
              return e.apply(n, arguments);
            };
          };
        }), Cn = Ne((M0, Fi) => {
          "use strict";
          var Ap = Qe(), Sp = hn(), xp = It(), bp = vn(), Tp = Ap.TypeError, Ei = function(e, n, t, s, a, r, u, i) {
            for (var l = a, c = 0, y = u ? bp(u, i) : false, h, g; c < s; ) {
              if (c in t) {
                if (h = y ? y(t[c], c, n) : t[c], r > 0 && Sp(h))
                  g = xp(h), l = Ei(e, n, h, g, l, r - 1) - 1;
                else {
                  if (l >= 9007199254740991)
                    throw Tp("Exceed the acceptable array length");
                  e[l] = h;
                }
                l++;
              }
              c++;
            }
            return l;
          };
          Fi.exports = Ei;
        }), xi = Ne((R0, Si) => {
          var Bp = bt(), Np = Bp("toStringTag"), Ai = {};
          Ai[Np] = "z", Si.exports = String(Ai) === "[object z]";
        }), En = Ne(($0, bi) => {
          var wp = Qe(), _p = xi(), Pp = pt(), Sr = or(), Ip = bt(), kp = Ip("toStringTag"), Lp = wp.Object, jp = Sr(function() {
            return arguments;
          }()) == "Arguments", Op = function(e, n) {
            try {
              return e[n];
            } catch {
            }
          };
          bi.exports = _p ? Sr : function(e) {
            var n, t, s;
            return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Op(n = Lp(e), kp)) == "string" ? t : jp ? Sr(n) : (s = Sr(n)) == "Object" && Pp(n.callee) ? "Arguments" : s;
          };
        }), Pi = Ne((V0, _i) => {
          var qp = ct(), Mp = dt(), Ti = pt(), Rp = En(), $p = $t(), Vp = Cr(), Bi = function() {
          }, Wp = [], Ni = $p("Reflect", "construct"), Fn = /^\s*(?:class|function)\b/, Hp = qp(Fn.exec), Gp = !Fn.exec(Bi), Ut = function(n) {
            if (!Ti(n))
              return false;
            try {
              return Ni(Bi, Wp, n), true;
            } catch {
              return false;
            }
          }, wi = function(n) {
            if (!Ti(n))
              return false;
            switch (Rp(n)) {
              case "AsyncFunction":
              case "GeneratorFunction":
              case "AsyncGeneratorFunction":
                return false;
            }
            try {
              return Gp || !!Hp(Fn, Vp(n));
            } catch {
              return true;
            }
          };
          wi.sham = true, _i.exports = !Ni || Mp(function() {
            var e;
            return Ut(Ut.call) || !Ut(Object) || !Ut(function() {
              e = true;
            }) || e;
          }) ? wi : Ut;
        }), ji = Ne((W0, Li) => {
          var Up = Qe(), Ii = hn(), Jp = Pi(), zp = St(), Xp = bt(), Kp = Xp("species"), ki = Up.Array;
          Li.exports = function(e) {
            var n;
            return Ii(e) && (n = e.constructor, Jp(n) && (n === ki || Ii(n.prototype)) ? n = void 0 : zp(n) && (n = n[Kp], n === null && (n = void 0))), n === void 0 ? ki : n;
          };
        }), An = Ne((H0, Oi) => {
          var Yp = ji();
          Oi.exports = function(e, n) {
            return new (Yp(e))(n === 0 ? 0 : n);
          };
        }), qi = Ne(() => {
          "use strict";
          var Qp = Gt(), Zp = Cn(), ef = Vt(), tf = dr(), rf = It(), nf = An();
          Qp({ target: "Array", proto: true }, { flatMap: function(n) {
            var t = tf(this), s = rf(t), a;
            return ef(n), a = nf(t, 0), a.length = Zp(a, t, t, s, 0, 1, n, arguments.length > 1 ? arguments[1] : void 0), a;
          } });
        }), Sn = Ne((J0, Mi) => {
          Mi.exports = {};
        }), $i = Ne((z0, Ri) => {
          var uf = bt(), sf = Sn(), af = uf("iterator"), of = Array.prototype;
          Ri.exports = function(e) {
            return e !== void 0 && (sf.Array === e || of[af] === e);
          };
        }), xn = Ne((X0, Wi) => {
          var lf = En(), Vi = fr(), cf = Sn(), pf = bt(), ff = pf("iterator");
          Wi.exports = function(e) {
            if (e != null)
              return Vi(e, ff) || Vi(e, "@@iterator") || cf[lf(e)];
          };
        }), Gi = Ne((K0, Hi) => {
          var Df = Qe(), mf = At(), df = Vt(), gf = Pt(), yf = pr(), hf = xn(), vf = Df.TypeError;
          Hi.exports = function(e, n) {
            var t = arguments.length < 2 ? hf(e) : n;
            if (df(t))
              return gf(mf(t, e));
            throw vf(yf(e) + " is not iterable");
          };
        }), zi = Ne((Y0, Ji) => {
          var Cf = At(), Ui = Pt(), Ef = fr();
          Ji.exports = function(e, n, t) {
            var s, a;
            Ui(e);
            try {
              if (s = Ef(e, "return"), !s) {
                if (n === "throw")
                  throw t;
                return t;
              }
              s = Cf(s, e);
            } catch (r) {
              a = true, s = r;
            }
            if (n === "throw")
              throw t;
            if (a)
              throw s;
            return Ui(s), t;
          };
        }), Zi = Ne((Q0, Qi) => {
          var Ff = Qe(), Af = vn(), Sf = At(), xf = Pt(), bf = pr(), Tf = $i(), Bf = It(), Xi = Wr(), Nf = Gi(), wf = xn(), Ki = zi(), _f = Ff.TypeError, xr = function(e, n) {
            this.stopped = e, this.result = n;
          }, Yi = xr.prototype;
          Qi.exports = function(e, n, t) {
            var s = t && t.that, a = !!(t && t.AS_ENTRIES), r = !!(t && t.IS_ITERATOR), u = !!(t && t.INTERRUPTED), i = Af(n, s), l, c, y, h, g, p, D, v = function(T) {
              return l && Ki(l, "normal", T), new xr(true, T);
            }, w = function(T) {
              return a ? (xf(T), u ? i(T[0], T[1], v) : i(T[0], T[1])) : u ? i(T, v) : i(T);
            };
            if (r)
              l = e;
            else {
              if (c = wf(e), !c)
                throw _f(bf(e) + " is not iterable");
              if (Tf(c)) {
                for (y = 0, h = Bf(e); h > y; y++)
                  if (g = w(e[y]), g && Xi(Yi, g))
                    return g;
                return new xr(false);
              }
              l = Nf(e, c);
            }
            for (p = l.next; !(D = Sf(p, l)).done; ) {
              try {
                g = w(D.value);
              } catch (T) {
                Ki(l, "throw", T);
              }
              if (typeof g == "object" && g && Xi(Yi, g))
                return g;
            }
            return new xr(false);
          };
        }), ta = Ne((Z0, ea) => {
          "use strict";
          var Pf = gr(), If = hr(), kf = ar();
          ea.exports = function(e, n, t) {
            var s = Pf(n);
            s in e ? If.f(e, s, kf(0, t)) : e[s] = t;
          };
        }), ra = Ne(() => {
          var Lf = Gt(), jf = Zi(), Of = ta();
          Lf({ target: "Object", stat: true }, { fromEntries: function(n) {
            var t = {};
            return jf(n, function(s, a) {
              Of(t, s, a);
            }, { AS_ENTRIES: true }), t;
          } });
        }), na = Ne(() => {
          var qf = Gt(), Mf = Qe();
          qf({ global: true }, { globalThis: Mf });
        }), ua = Ne(() => {
          na();
        }), sa = Ne(() => {
          "use strict";
          var Rf = Gt(), $f = Cn(), Vf = dr(), Wf = It(), Hf = Ar(), Gf = An();
          Rf({ target: "Array", proto: true }, { flat: function() {
            var n = arguments.length ? arguments[0] : void 0, t = Vf(this), s = Wf(t), a = Gf(t, 0);
            return a.length = $f(a, t, t, s, 0, n === void 0 ? 1 : Hf(n)), a;
          } });
        }), Tg = Ne((ly, mo) => {
          var Uf = ["cliName", "cliCategory", "cliDescription"], Jf = ["_"], zf = ["languageId"];
          function Ln(e, n) {
            if (e == null)
              return {};
            var t = Xf(e, n), s, a;
            if (Object.getOwnPropertySymbols) {
              var r = Object.getOwnPropertySymbols(e);
              for (a = 0; a < r.length; a++)
                s = r[a], !(n.indexOf(s) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s) || (t[s] = e[s]));
            }
            return t;
          }
          function Xf(e, n) {
            if (e == null)
              return {};
            var t = {}, s = Object.keys(e), a, r;
            for (r = 0; r < s.length; r++)
              a = s[r], !(n.indexOf(a) >= 0) && (t[a] = e[a]);
            return t;
          }
          qi(), ra(), ua(), sa();
          var Kf = Object.create, wr = Object.defineProperty, Yf = Object.getOwnPropertyDescriptor, jn = Object.getOwnPropertyNames, Qf = Object.getPrototypeOf, Zf = Object.prototype.hasOwnProperty, gt = (e, n) => function() {
            return e && (n = (0, e[jn(e)[0]])(e = 0)), n;
          }, ee = (e, n) => function() {
            return n || (0, e[jn(e)[0]])((n = { exports: {} }).exports, n), n.exports;
          }, zt = (e, n) => {
            for (var t in n)
              wr(e, t, { get: n[t], enumerable: true });
          }, pa = (e, n, t, s) => {
            if (n && typeof n == "object" || typeof n == "function")
              for (let a of jn(n))
                !Zf.call(e, a) && a !== t && wr(e, a, { get: () => n[a], enumerable: !(s = Yf(n, a)) || s.enumerable });
            return e;
          }, eD = (e, n, t) => (t = e != null ? Kf(Qf(e)) : {}, pa(n || !e || !e.__esModule ? wr(t, "default", { value: e, enumerable: true }) : t, e)), ft = (e) => pa(wr({}, "__esModule", { value: true }), e), ia, aa, Nt, re = gt({ "<define:process>"() {
            ia = {}, aa = [], Nt = { env: ia, argv: aa };
          } }), fa = ee({ "package.json"(e, n) {
            n.exports = { version: "2.8.0" };
          } }), tD = ee({ "node_modules/diff/lib/diff/base.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.default = n;
            function n() {
            }
            n.prototype = { diff: function(r, u) {
              var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = i.callback;
              typeof i == "function" && (l = i, i = {}), this.options = i;
              var c = this;
              function y(A3) {
                return l ? (setTimeout(function() {
                  l(void 0, A3);
                }, 0), true) : A3;
              }
              r = this.castInput(r), u = this.castInput(u), r = this.removeEmpty(this.tokenize(r)), u = this.removeEmpty(this.tokenize(u));
              var h = u.length, g = r.length, p = 1, D = h + g, v = [{ newPos: -1, components: [] }], w = this.extractCommon(v[0], u, r, 0);
              if (v[0].newPos + 1 >= h && w + 1 >= g)
                return y([{ value: this.join(u), count: u.length }]);
              function T() {
                for (var A3 = -1 * p; A3 <= p; A3 += 2) {
                  var B = void 0, I = v[A3 - 1], P2 = v[A3 + 1], R = (P2 ? P2.newPos : 0) - A3;
                  I && (v[A3 - 1] = void 0);
                  var f = I && I.newPos + 1 < h, x = P2 && 0 <= R && R < g;
                  if (!f && !x) {
                    v[A3] = void 0;
                    continue;
                  }
                  if (!f || x && I.newPos < P2.newPos ? (B = s(P2), c.pushComponent(B.components, void 0, true)) : (B = I, B.newPos++, c.pushComponent(B.components, true, void 0)), R = c.extractCommon(B, u, r, A3), B.newPos + 1 >= h && R + 1 >= g)
                    return y(t(c, B.components, u, r, c.useLongestToken));
                  v[A3] = B;
                }
                p++;
              }
              if (l)
                (function A3() {
                  setTimeout(function() {
                    if (p > D)
                      return l();
                    T() || A3();
                  }, 0);
                })();
              else
                for (; p <= D; ) {
                  var F = T();
                  if (F)
                    return F;
                }
            }, pushComponent: function(r, u, i) {
              var l = r[r.length - 1];
              l && l.added === u && l.removed === i ? r[r.length - 1] = { count: l.count + 1, added: u, removed: i } : r.push({ count: 1, added: u, removed: i });
            }, extractCommon: function(r, u, i, l) {
              for (var c = u.length, y = i.length, h = r.newPos, g = h - l, p = 0; h + 1 < c && g + 1 < y && this.equals(u[h + 1], i[g + 1]); )
                h++, g++, p++;
              return p && r.components.push({ count: p }), r.newPos = h, g;
            }, equals: function(r, u) {
              return this.options.comparator ? this.options.comparator(r, u) : r === u || this.options.ignoreCase && r.toLowerCase() === u.toLowerCase();
            }, removeEmpty: function(r) {
              for (var u = [], i = 0; i < r.length; i++)
                r[i] && u.push(r[i]);
              return u;
            }, castInput: function(r) {
              return r;
            }, tokenize: function(r) {
              return r.split("");
            }, join: function(r) {
              return r.join("");
            } };
            function t(a, r, u, i, l) {
              for (var c = 0, y = r.length, h = 0, g = 0; c < y; c++) {
                var p = r[c];
                if (p.removed) {
                  if (p.value = a.join(i.slice(g, g + p.count)), g += p.count, c && r[c - 1].added) {
                    var v = r[c - 1];
                    r[c - 1] = r[c], r[c] = v;
                  }
                } else {
                  if (!p.added && l) {
                    var D = u.slice(h, h + p.count);
                    D = D.map(function(T, F) {
                      var A3 = i[g + F];
                      return A3.length > T.length ? A3 : T;
                    }), p.value = a.join(D);
                  } else
                    p.value = a.join(u.slice(h, h + p.count));
                  h += p.count, p.added || (g += p.count);
                }
              }
              var w = r[y - 1];
              return y > 1 && typeof w.value == "string" && (w.added || w.removed) && a.equals("", w.value) && (r[y - 2].value += w.value, r.pop()), r;
            }
            function s(a) {
              return { newPos: a.newPos, components: a.components.slice(0) };
            }
          } }), rD = ee({ "node_modules/diff/lib/diff/array.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a, e.arrayDiff = void 0;
            var n = t(tD());
            function t(r) {
              return r && r.__esModule ? r : { default: r };
            }
            var s = new n.default();
            e.arrayDiff = s, s.tokenize = function(r) {
              return r.slice();
            }, s.join = s.removeEmpty = function(r) {
              return r;
            };
            function a(r, u, i) {
              return s.diff(r, u, i);
            }
          } }), On = ee({ "src/document/doc-builders.js"(e, n) {
            "use strict";
            re();
            function t(E) {
              return { type: "concat", parts: E };
            }
            function s(E) {
              return { type: "indent", contents: E };
            }
            function a(E, o) {
              return { type: "align", contents: o, n: E };
            }
            function r(E) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              return { type: "group", id: o.id, contents: E, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
            }
            function u(E) {
              return a(Number.NEGATIVE_INFINITY, E);
            }
            function i(E) {
              return a({ type: "root" }, E);
            }
            function l(E) {
              return a(-1, E);
            }
            function c(E, o) {
              return r(E[0], Object.assign(Object.assign({}, o), {}, { expandedStates: E }));
            }
            function y(E) {
              return { type: "fill", parts: E };
            }
            function h(E, o) {
              let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return { type: "if-break", breakContents: E, flatContents: o, groupId: d.groupId };
            }
            function g(E, o) {
              return { type: "indent-if-break", contents: E, groupId: o.groupId, negate: o.negate };
            }
            function p(E) {
              return { type: "line-suffix", contents: E };
            }
            var D = { type: "line-suffix-boundary" }, v = { type: "break-parent" }, w = { type: "trim" }, T = { type: "line", hard: true }, F = { type: "line", hard: true, literal: true }, A3 = { type: "line" }, B = { type: "line", soft: true }, I = t([T, v]), P2 = t([F, v]), R = { type: "cursor", placeholder: Symbol("cursor") };
            function f(E, o) {
              let d = [];
              for (let C = 0; C < o.length; C++)
                C !== 0 && d.push(E), d.push(o[C]);
              return t(d);
            }
            function x(E, o, d) {
              let C = E;
              if (o > 0) {
                for (let _ = 0; _ < Math.floor(o / d); ++_)
                  C = s(C);
                C = a(o % d, C), C = a(Number.NEGATIVE_INFINITY, C);
              }
              return C;
            }
            function m(E, o) {
              return { type: "label", label: E, contents: o };
            }
            n.exports = { concat: t, join: f, line: A3, softline: B, hardline: I, literalline: P2, group: r, conditionalGroup: c, fill: y, lineSuffix: p, lineSuffixBoundary: D, cursor: R, breakParent: v, ifBreak: h, trim: w, indent: s, indentIfBreak: g, align: a, addAlignmentToDoc: x, markAsRoot: i, dedentToRoot: u, dedent: l, hardlineWithoutBreakParent: T, literallineWithoutBreakParent: F, label: m };
          } }), qn = ee({ "src/common/end-of-line.js"(e, n) {
            "use strict";
            re();
            function t(u) {
              let i = u.indexOf("\r");
              return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
            }
            function s(u) {
              switch (u) {
                case "cr":
                  return "\r";
                case "crlf":
                  return `\r
`;
                default:
                  return `
`;
              }
            }
            function a(u, i) {
              let l;
              switch (i) {
                case `
`:
                  l = /\n/g;
                  break;
                case "\r":
                  l = /\r/g;
                  break;
                case `\r
`:
                  l = /\r\n/g;
                  break;
                default:
                  throw new Error(`Unexpected "eol" ${JSON.stringify(i)}.`);
              }
              let c = u.match(l);
              return c ? c.length : 0;
            }
            function r(u) {
              return u.replace(/\r\n?/g, `
`);
            }
            n.exports = { guessEndOfLine: t, convertEndOfLineToChars: s, countEndOfLineChars: a, normalizeEndOfLine: r };
          } }), lt = ee({ "src/utils/get-last.js"(e, n) {
            "use strict";
            re();
            var t = (s) => s[s.length - 1];
            n.exports = t;
          } });
          function nD() {
            let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
            return new RegExp(n, e ? void 0 : "g");
          }
          var uD = gt({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
            re();
          } });
          function sD(e) {
            if (typeof e != "string")
              throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
            return e.replace(nD(), "");
          }
          var iD = gt({ "node_modules/strip-ansi/index.js"() {
            re(), uD();
          } });
          function aD(e) {
            return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
          }
          var oD = gt({ "node_modules/is-fullwidth-code-point/index.js"() {
            re();
          } }), lD = ee({ "node_modules/emoji-regex/index.js"(e, n) {
            "use strict";
            re(), n.exports = function() {
              return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
            };
          } }), Da = {};
          zt(Da, { default: () => cD });
          function cD(e) {
            if (typeof e != "string" || e.length === 0 || (e = sD(e), e.length === 0))
              return 0;
            e = e.replace((0, ma.default)(), "  ");
            let n = 0;
            for (let t = 0; t < e.length; t++) {
              let s = e.codePointAt(t);
              s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, n += aD(s) ? 2 : 1);
            }
            return n;
          }
          var ma, pD = gt({ "node_modules/string-width/index.js"() {
            re(), iD(), oD(), ma = eD(lD());
          } }), da = ee({ "src/utils/get-string-width.js"(e, n) {
            "use strict";
            re();
            var t = (pD(), ft(Da)).default, s = /[^\x20-\x7F]/;
            function a(r) {
              return r ? s.test(r) ? t(r) : r.length : 0;
            }
            n.exports = a;
          } }), Xt = ee({ "src/document/doc-utils.js"(e, n) {
            "use strict";
            re();
            var t = lt(), { literalline: s, join: a } = On(), r = (o) => Array.isArray(o) || o && o.type === "concat", u = (o) => {
              if (Array.isArray(o))
                return o;
              if (o.type !== "concat" && o.type !== "fill")
                throw new Error("Expect doc type to be `concat` or `fill`.");
              return o.parts;
            }, i = {};
            function l(o, d, C, _) {
              let b = [o];
              for (; b.length > 0; ) {
                let N = b.pop();
                if (N === i) {
                  C(b.pop());
                  continue;
                }
                if (C && b.push(N, i), !d || d(N) !== false)
                  if (r(N) || N.type === "fill") {
                    let k = u(N);
                    for (let $ = k.length, M = $ - 1; M >= 0; --M)
                      b.push(k[M]);
                  } else if (N.type === "if-break")
                    N.flatContents && b.push(N.flatContents), N.breakContents && b.push(N.breakContents);
                  else if (N.type === "group" && N.expandedStates)
                    if (_)
                      for (let k = N.expandedStates.length, $ = k - 1; $ >= 0; --$)
                        b.push(N.expandedStates[$]);
                    else
                      b.push(N.contents);
                  else
                    N.contents && b.push(N.contents);
              }
            }
            function c(o, d) {
              let C = /* @__PURE__ */ new Map();
              return _(o);
              function _(N) {
                if (C.has(N))
                  return C.get(N);
                let k = b(N);
                return C.set(N, k), k;
              }
              function b(N) {
                if (Array.isArray(N))
                  return d(N.map(_));
                if (N.type === "concat" || N.type === "fill") {
                  let k = N.parts.map(_);
                  return d(Object.assign(Object.assign({}, N), {}, { parts: k }));
                }
                if (N.type === "if-break") {
                  let k = N.breakContents && _(N.breakContents), $ = N.flatContents && _(N.flatContents);
                  return d(Object.assign(Object.assign({}, N), {}, { breakContents: k, flatContents: $ }));
                }
                if (N.type === "group" && N.expandedStates) {
                  let k = N.expandedStates.map(_), $ = k[0];
                  return d(Object.assign(Object.assign({}, N), {}, { contents: $, expandedStates: k }));
                }
                if (N.contents) {
                  let k = _(N.contents);
                  return d(Object.assign(Object.assign({}, N), {}, { contents: k }));
                }
                return d(N);
              }
            }
            function y(o, d, C) {
              let _ = C, b = false;
              function N(k) {
                let $ = d(k);
                if ($ !== void 0 && (b = true, _ = $), b)
                  return false;
              }
              return l(o, N), _;
            }
            function h(o) {
              if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent")
                return true;
            }
            function g(o) {
              return y(o, h, false);
            }
            function p(o) {
              if (o.length > 0) {
                let d = t(o);
                !d.expandedStates && !d.break && (d.break = "propagated");
              }
              return null;
            }
            function D(o) {
              let d = /* @__PURE__ */ new Set(), C = [];
              function _(N) {
                if (N.type === "break-parent" && p(C), N.type === "group") {
                  if (C.push(N), d.has(N))
                    return false;
                  d.add(N);
                }
              }
              function b(N) {
                N.type === "group" && C.pop().break && p(C);
              }
              l(o, _, b, true);
            }
            function v(o) {
              return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
            }
            function w(o) {
              return c(o, v);
            }
            var T = (o, d) => o && o.type === "line" && o.hard && d && d.type === "break-parent";
            function F(o) {
              if (!o)
                return o;
              if (r(o) || o.type === "fill") {
                let d = u(o);
                for (; d.length > 1 && T(...d.slice(-2)); )
                  d.length -= 2;
                if (d.length > 0) {
                  let C = F(t(d));
                  d[d.length - 1] = C;
                }
                return Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
              }
              switch (o.type) {
                case "align":
                case "indent":
                case "indent-if-break":
                case "group":
                case "line-suffix":
                case "label": {
                  let d = F(o.contents);
                  return Object.assign(Object.assign({}, o), {}, { contents: d });
                }
                case "if-break": {
                  let d = F(o.breakContents), C = F(o.flatContents);
                  return Object.assign(Object.assign({}, o), {}, { breakContents: d, flatContents: C });
                }
              }
              return o;
            }
            function A3(o) {
              return F(I(o));
            }
            function B(o) {
              switch (o.type) {
                case "fill":
                  if (o.parts.every((C) => C === ""))
                    return "";
                  break;
                case "group":
                  if (!o.contents && !o.id && !o.break && !o.expandedStates)
                    return "";
                  if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates)
                    return o.contents;
                  break;
                case "align":
                case "indent":
                case "indent-if-break":
                case "line-suffix":
                  if (!o.contents)
                    return "";
                  break;
                case "if-break":
                  if (!o.flatContents && !o.breakContents)
                    return "";
                  break;
              }
              if (!r(o))
                return o;
              let d = [];
              for (let C of u(o)) {
                if (!C)
                  continue;
                let [_, ...b] = r(C) ? u(C) : [C];
                typeof _ == "string" && typeof t(d) == "string" ? d[d.length - 1] += _ : d.push(_), d.push(...b);
              }
              return d.length === 0 ? "" : d.length === 1 ? d[0] : Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
            }
            function I(o) {
              return c(o, (d) => B(d));
            }
            function P2(o) {
              let d = [], C = o.filter(Boolean);
              for (; C.length > 0; ) {
                let _ = C.shift();
                if (_) {
                  if (r(_)) {
                    C.unshift(...u(_));
                    continue;
                  }
                  if (d.length > 0 && typeof t(d) == "string" && typeof _ == "string") {
                    d[d.length - 1] += _;
                    continue;
                  }
                  d.push(_);
                }
              }
              return d;
            }
            function R(o) {
              return c(o, (d) => Array.isArray(d) ? P2(d) : d.parts ? Object.assign(Object.assign({}, d), {}, { parts: P2(d.parts) }) : d);
            }
            function f(o) {
              return c(o, (d) => typeof d == "string" && d.includes(`
`) ? x(d) : d);
            }
            function x(o) {
              let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
              return a(d, o.split(`
`)).parts;
            }
            function m(o) {
              if (o.type === "line")
                return true;
            }
            function E(o) {
              return y(o, m, false);
            }
            n.exports = { isConcat: r, getDocParts: u, willBreak: g, traverseDoc: l, findInDoc: y, mapDoc: c, propagateBreaks: D, removeLines: w, stripTrailingHardline: A3, normalizeParts: P2, normalizeDoc: R, cleanDoc: I, replaceTextEndOfLine: x, replaceEndOfLine: f, canBreak: E };
          } }), fD = ee({ "src/document/doc-printer.js"(e, n) {
            "use strict";
            re();
            var { convertEndOfLineToChars: t } = qn(), s = lt(), a = da(), { fill: r, cursor: u, indent: i } = On(), { isConcat: l, getDocParts: c } = Xt(), y, h = 1, g = 2;
            function p() {
              return { value: "", length: 0, queue: [] };
            }
            function D(B, I) {
              return w(B, { type: "indent" }, I);
            }
            function v(B, I, P2) {
              return I === Number.NEGATIVE_INFINITY ? B.root || p() : I < 0 ? w(B, { type: "dedent" }, P2) : I ? I.type === "root" ? Object.assign(Object.assign({}, B), {}, { root: B }) : w(B, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, P2) : B;
            }
            function w(B, I, P2) {
              let R = I.type === "dedent" ? B.queue.slice(0, -1) : [...B.queue, I], f = "", x = 0, m = 0, E = 0;
              for (let k of R)
                switch (k.type) {
                  case "indent":
                    C(), P2.useTabs ? o(1) : d(P2.tabWidth);
                    break;
                  case "stringAlign":
                    C(), f += k.n, x += k.n.length;
                    break;
                  case "numberAlign":
                    m += 1, E += k.n;
                    break;
                  default:
                    throw new Error(`Unexpected type '${k.type}'`);
                }
              return b(), Object.assign(Object.assign({}, B), {}, { value: f, length: x, queue: R });
              function o(k) {
                f += "	".repeat(k), x += P2.tabWidth * k;
              }
              function d(k) {
                f += " ".repeat(k), x += k;
              }
              function C() {
                P2.useTabs ? _() : b();
              }
              function _() {
                m > 0 && o(m), N();
              }
              function b() {
                E > 0 && d(E), N();
              }
              function N() {
                m = 0, E = 0;
              }
            }
            function T(B) {
              if (B.length === 0)
                return 0;
              let I = 0;
              for (; B.length > 0 && typeof s(B) == "string" && /^[\t ]*$/.test(s(B)); )
                I += B.pop().length;
              if (B.length > 0 && typeof s(B) == "string") {
                let P2 = s(B).replace(/[\t ]*$/, "");
                I += s(B).length - P2.length, B[B.length - 1] = P2;
              }
              return I;
            }
            function F(B, I, P2, R, f) {
              let x = I.length, m = [B], E = [];
              for (; P2 >= 0; ) {
                if (m.length === 0) {
                  if (x === 0)
                    return true;
                  m.push(I[--x]);
                  continue;
                }
                let { mode: o, doc: d } = m.pop();
                if (typeof d == "string")
                  E.push(d), P2 -= a(d);
                else if (l(d) || d.type === "fill") {
                  let C = c(d);
                  for (let _ = C.length - 1; _ >= 0; _--)
                    m.push({ mode: o, doc: C[_] });
                } else
                  switch (d.type) {
                    case "indent":
                    case "align":
                    case "indent-if-break":
                    case "label":
                      m.push({ mode: o, doc: d.contents });
                      break;
                    case "trim":
                      P2 += T(E);
                      break;
                    case "group": {
                      if (f && d.break)
                        return false;
                      let C = d.break ? h : o, _ = d.expandedStates && C === h ? s(d.expandedStates) : d.contents;
                      m.push({ mode: C, doc: _ });
                      break;
                    }
                    case "if-break": {
                      let _ = (d.groupId ? y[d.groupId] || g : o) === h ? d.breakContents : d.flatContents;
                      _ && m.push({ mode: o, doc: _ });
                      break;
                    }
                    case "line":
                      if (o === h || d.hard)
                        return true;
                      d.soft || (E.push(" "), P2--);
                      break;
                    case "line-suffix":
                      R = true;
                      break;
                    case "line-suffix-boundary":
                      if (R)
                        return false;
                      break;
                  }
              }
              return false;
            }
            function A3(B, I) {
              y = {};
              let P2 = I.printWidth, R = t(I.endOfLine), f = 0, x = [{ ind: p(), mode: h, doc: B }], m = [], E = false, o = [];
              for (; x.length > 0; ) {
                let { ind: C, mode: _, doc: b } = x.pop();
                if (typeof b == "string") {
                  let N = R !== `
` ? b.replace(/\n/g, R) : b;
                  m.push(N), f += a(N);
                } else if (l(b)) {
                  let N = c(b);
                  for (let k = N.length - 1; k >= 0; k--)
                    x.push({ ind: C, mode: _, doc: N[k] });
                } else
                  switch (b.type) {
                    case "cursor":
                      m.push(u.placeholder);
                      break;
                    case "indent":
                      x.push({ ind: D(C, I), mode: _, doc: b.contents });
                      break;
                    case "align":
                      x.push({ ind: v(C, b.n, I), mode: _, doc: b.contents });
                      break;
                    case "trim":
                      f -= T(m);
                      break;
                    case "group":
                      switch (_) {
                        case g:
                          if (!E) {
                            x.push({ ind: C, mode: b.break ? h : g, doc: b.contents });
                            break;
                          }
                        case h: {
                          E = false;
                          let N = { ind: C, mode: g, doc: b.contents }, k = P2 - f, $ = o.length > 0;
                          if (!b.break && F(N, x, k, $))
                            x.push(N);
                          else if (b.expandedStates) {
                            let M = s(b.expandedStates);
                            if (b.break) {
                              x.push({ ind: C, mode: h, doc: M });
                              break;
                            } else
                              for (let q = 1; q < b.expandedStates.length + 1; q++)
                                if (q >= b.expandedStates.length) {
                                  x.push({ ind: C, mode: h, doc: M });
                                  break;
                                } else {
                                  let J = b.expandedStates[q], L = { ind: C, mode: g, doc: J };
                                  if (F(L, x, k, $)) {
                                    x.push(L);
                                    break;
                                  }
                                }
                          } else
                            x.push({ ind: C, mode: h, doc: b.contents });
                          break;
                        }
                      }
                      b.id && (y[b.id] = s(x).mode);
                      break;
                    case "fill": {
                      let N = P2 - f, { parts: k } = b;
                      if (k.length === 0)
                        break;
                      let [$, M] = k, q = { ind: C, mode: g, doc: $ }, J = { ind: C, mode: h, doc: $ }, L = F(q, [], N, o.length > 0, true);
                      if (k.length === 1) {
                        L ? x.push(q) : x.push(J);
                        break;
                      }
                      let Y = { ind: C, mode: g, doc: M }, V = { ind: C, mode: h, doc: M };
                      if (k.length === 2) {
                        L ? x.push(Y, q) : x.push(V, J);
                        break;
                      }
                      k.splice(0, 2);
                      let O = { ind: C, mode: _, doc: r(k) }, K = k[0];
                      F({ ind: C, mode: g, doc: [$, M, K] }, [], N, o.length > 0, true) ? x.push(O, Y, q) : L ? x.push(O, V, q) : x.push(O, V, J);
                      break;
                    }
                    case "if-break":
                    case "indent-if-break": {
                      let N = b.groupId ? y[b.groupId] : _;
                      if (N === h) {
                        let k = b.type === "if-break" ? b.breakContents : b.negate ? b.contents : i(b.contents);
                        k && x.push({ ind: C, mode: _, doc: k });
                      }
                      if (N === g) {
                        let k = b.type === "if-break" ? b.flatContents : b.negate ? i(b.contents) : b.contents;
                        k && x.push({ ind: C, mode: _, doc: k });
                      }
                      break;
                    }
                    case "line-suffix":
                      o.push({ ind: C, mode: _, doc: b.contents });
                      break;
                    case "line-suffix-boundary":
                      o.length > 0 && x.push({ ind: C, mode: _, doc: { type: "line", hard: true } });
                      break;
                    case "line":
                      switch (_) {
                        case g:
                          if (b.hard)
                            E = true;
                          else {
                            b.soft || (m.push(" "), f += 1);
                            break;
                          }
                        case h:
                          if (o.length > 0) {
                            x.push({ ind: C, mode: _, doc: b }, ...o.reverse()), o.length = 0;
                            break;
                          }
                          b.literal ? C.root ? (m.push(R, C.root.value), f = C.root.length) : (m.push(R), f = 0) : (f -= T(m), m.push(R + C.value), f = C.length);
                          break;
                      }
                      break;
                    case "label":
                      x.push({ ind: C, mode: _, doc: b.contents });
                      break;
                    default:
                  }
                x.length === 0 && o.length > 0 && (x.push(...o.reverse()), o.length = 0);
              }
              let d = m.indexOf(u.placeholder);
              if (d !== -1) {
                let C = m.indexOf(u.placeholder, d + 1), _ = m.slice(0, d).join(""), b = m.slice(d + 1, C).join(""), N = m.slice(C + 1).join("");
                return { formatted: _ + b + N, cursorNodeStart: _.length, cursorNodeText: b };
              }
              return { formatted: m.join("") };
            }
            n.exports = { printDocToString: A3 };
          } }), DD = ee({ "src/document/doc-debug.js"(e, n) {
            "use strict";
            re();
            var { isConcat: t, getDocParts: s } = Xt();
            function a(u) {
              if (!u)
                return "";
              if (t(u)) {
                let i = [];
                for (let l of s(u))
                  if (t(l))
                    i.push(...a(l).parts);
                  else {
                    let c = a(l);
                    c !== "" && i.push(c);
                  }
                return { type: "concat", parts: i };
              }
              return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a(u.breakContents), flatContents: a(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents) }) : u;
            }
            function r(u) {
              let i = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ new Set();
              return c(a(u));
              function c(h, g, p) {
                if (typeof h == "string")
                  return JSON.stringify(h);
                if (t(h)) {
                  let D = s(h).map(c).filter(Boolean);
                  return D.length === 1 ? D[0] : `[${D.join(", ")}]`;
                }
                if (h.type === "line") {
                  let D = Array.isArray(p) && p[g + 1] && p[g + 1].type === "break-parent";
                  return h.literal ? D ? "literalline" : "literallineWithoutBreakParent" : h.hard ? D ? "hardline" : "hardlineWithoutBreakParent" : h.soft ? "softline" : "line";
                }
                if (h.type === "break-parent")
                  return Array.isArray(p) && p[g - 1] && p[g - 1].type === "line" && p[g - 1].hard ? void 0 : "breakParent";
                if (h.type === "trim")
                  return "trim";
                if (h.type === "indent")
                  return "indent(" + c(h.contents) + ")";
                if (h.type === "align")
                  return h.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + c(h.contents) + ")" : h.n < 0 ? "dedent(" + c(h.contents) + ")" : h.n.type === "root" ? "markAsRoot(" + c(h.contents) + ")" : "align(" + JSON.stringify(h.n) + ", " + c(h.contents) + ")";
                if (h.type === "if-break")
                  return "ifBreak(" + c(h.breakContents) + (h.flatContents ? ", " + c(h.flatContents) : "") + (h.groupId ? (h.flatContents ? "" : ', ""') + `, { groupId: ${y(h.groupId)} }` : "") + ")";
                if (h.type === "indent-if-break") {
                  let D = [];
                  h.negate && D.push("negate: true"), h.groupId && D.push(`groupId: ${y(h.groupId)}`);
                  let v = D.length > 0 ? `, { ${D.join(", ")} }` : "";
                  return `indentIfBreak(${c(h.contents)}${v})`;
                }
                if (h.type === "group") {
                  let D = [];
                  h.break && h.break !== "propagated" && D.push("shouldBreak: true"), h.id && D.push(`id: ${y(h.id)}`);
                  let v = D.length > 0 ? `, { ${D.join(", ")} }` : "";
                  return h.expandedStates ? `conditionalGroup([${h.expandedStates.map((w) => c(w)).join(",")}]${v})` : `group(${c(h.contents)}${v})`;
                }
                if (h.type === "fill")
                  return `fill([${h.parts.map((D) => c(D)).join(", ")}])`;
                if (h.type === "line-suffix")
                  return "lineSuffix(" + c(h.contents) + ")";
                if (h.type === "line-suffix-boundary")
                  return "lineSuffixBoundary";
                if (h.type === "label")
                  return `label(${JSON.stringify(h.label)}, ${c(h.contents)})`;
                throw new Error("Unknown doc type " + h.type);
              }
              function y(h) {
                if (typeof h != "symbol")
                  return JSON.stringify(String(h));
                if (h in i)
                  return i[h];
                let g = String(h).slice(7, -1) || "symbol";
                for (let p = 0; ; p++) {
                  let D = g + (p > 0 ? ` #${p}` : "");
                  if (!l.has(D))
                    return l.add(D), i[h] = `Symbol.for(${JSON.stringify(D)})`;
                }
              }
            }
            n.exports = { printDocToDebug: r };
          } }), qe = ee({ "src/document/index.js"(e, n) {
            "use strict";
            re(), n.exports = { builders: On(), printer: fD(), utils: Xt(), debug: DD() };
          } }), ga = {};
          zt(ga, { default: () => mD });
          function mD(e) {
            if (typeof e != "string")
              throw new TypeError("Expected a string");
            return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
          }
          var dD = gt({ "node_modules/escape-string-regexp/index.js"() {
            re();
          } }), ya = ee({ "node_modules/semver/internal/debug.js"(e, n) {
            re();
            var t = typeof Nt == "object" && Nt.env && Nt.env.NODE_DEBUG && /\bsemver\b/i.test(Nt.env.NODE_DEBUG) ? function() {
              for (var s = arguments.length, a = new Array(s), r = 0; r < s; r++)
                a[r] = arguments[r];
              return console.error("SEMVER", ...a);
            } : () => {
            };
            n.exports = t;
          } }), ha = ee({ "node_modules/semver/internal/constants.js"(e, n) {
            re();
            var t = "2.0.0", s = 256, a = Number.MAX_SAFE_INTEGER || 9007199254740991, r = 16;
            n.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s, MAX_SAFE_INTEGER: a, MAX_SAFE_COMPONENT_LENGTH: r };
          } }), gD = ee({ "node_modules/semver/internal/re.js"(e, n) {
            re();
            var { MAX_SAFE_COMPONENT_LENGTH: t } = ha(), s = ya();
            e = n.exports = {};
            var a = e.re = [], r = e.src = [], u = e.t = {}, i = 0, l = (c, y, h) => {
              let g = i++;
              s(c, g, y), u[c] = g, r[g] = y, a[g] = new RegExp(y, h ? "g" : void 0);
            };
            l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${r[u.NUMERICIDENTIFIER]})\\.(${r[u.NUMERICIDENTIFIER]})\\.(${r[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${r[u.NUMERICIDENTIFIERLOOSE]})\\.(${r[u.NUMERICIDENTIFIERLOOSE]})\\.(${r[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${r[u.NUMERICIDENTIFIER]}|${r[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${r[u.NUMERICIDENTIFIERLOOSE]}|${r[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${r[u.PRERELEASEIDENTIFIER]}(?:\\.${r[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${r[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${r[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${r[u.BUILDIDENTIFIER]}(?:\\.${r[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${r[u.MAINVERSION]}${r[u.PRERELEASE]}?${r[u.BUILD]}?`), l("FULL", `^${r[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${r[u.MAINVERSIONLOOSE]}${r[u.PRERELEASELOOSE]}?${r[u.BUILD]}?`), l("LOOSE", `^${r[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${r[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${r[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${r[u.XRANGEIDENTIFIER]})(?:\\.(${r[u.XRANGEIDENTIFIER]})(?:\\.(${r[u.XRANGEIDENTIFIER]})(?:${r[u.PRERELEASE]})?${r[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${r[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${r[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${r[u.XRANGEIDENTIFIERLOOSE]})(?:${r[u.PRERELEASELOOSE]})?${r[u.BUILD]}?)?)?`), l("XRANGE", `^${r[u.GTLT]}\\s*${r[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${r[u.GTLT]}\\s*${r[u.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), l("COERCERTL", r[u.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${r[u.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", l("TILDE", `^${r[u.LONETILDE]}${r[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${r[u.LONETILDE]}${r[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${r[u.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", l("CARET", `^${r[u.LONECARET]}${r[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${r[u.LONECARET]}${r[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${r[u.GTLT]}\\s*(${r[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${r[u.GTLT]}\\s*(${r[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${r[u.GTLT]}\\s*(${r[u.LOOSEPLAIN]}|${r[u.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${r[u.XRANGEPLAIN]})\\s+-\\s+(${r[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${r[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${r[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
          } }), yD = ee({ "node_modules/semver/internal/parse-options.js"(e, n) {
            re();
            var t = ["includePrerelease", "loose", "rtl"], s = (a) => a ? typeof a != "object" ? { loose: true } : t.filter((r) => a[r]).reduce((r, u) => (r[u] = true, r), {}) : {};
            n.exports = s;
          } }), hD = ee({ "node_modules/semver/internal/identifiers.js"(e, n) {
            re();
            var t = /^[0-9]+$/, s = (r, u) => {
              let i = t.test(r), l = t.test(u);
              return i && l && (r = +r, u = +u), r === u ? 0 : i && !l ? -1 : l && !i ? 1 : r < u ? -1 : 1;
            }, a = (r, u) => s(u, r);
            n.exports = { compareIdentifiers: s, rcompareIdentifiers: a };
          } }), vD = ee({ "node_modules/semver/classes/semver.js"(e, n) {
            re();
            var t = ya(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: a } = ha(), { re: r, t: u } = gD(), i = yD(), { compareIdentifiers: l } = hD(), c = class {
              constructor(y, h) {
                if (h = i(h), y instanceof c) {
                  if (y.loose === !!h.loose && y.includePrerelease === !!h.includePrerelease)
                    return y;
                  y = y.version;
                } else if (typeof y != "string")
                  throw new TypeError(`Invalid Version: ${y}`);
                if (y.length > s)
                  throw new TypeError(`version is longer than ${s} characters`);
                t("SemVer", y, h), this.options = h, this.loose = !!h.loose, this.includePrerelease = !!h.includePrerelease;
                let g = y.trim().match(h.loose ? r[u.LOOSE] : r[u.FULL]);
                if (!g)
                  throw new TypeError(`Invalid Version: ${y}`);
                if (this.raw = y, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > a || this.major < 0)
                  throw new TypeError("Invalid major version");
                if (this.minor > a || this.minor < 0)
                  throw new TypeError("Invalid minor version");
                if (this.patch > a || this.patch < 0)
                  throw new TypeError("Invalid patch version");
                g[4] ? this.prerelease = g[4].split(".").map((p) => {
                  if (/^[0-9]+$/.test(p)) {
                    let D = +p;
                    if (D >= 0 && D < a)
                      return D;
                  }
                  return p;
                }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
              }
              format() {
                return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
              }
              toString() {
                return this.version;
              }
              compare(y) {
                if (t("SemVer.compare", this.version, this.options, y), !(y instanceof c)) {
                  if (typeof y == "string" && y === this.version)
                    return 0;
                  y = new c(y, this.options);
                }
                return y.version === this.version ? 0 : this.compareMain(y) || this.comparePre(y);
              }
              compareMain(y) {
                return y instanceof c || (y = new c(y, this.options)), l(this.major, y.major) || l(this.minor, y.minor) || l(this.patch, y.patch);
              }
              comparePre(y) {
                if (y instanceof c || (y = new c(y, this.options)), this.prerelease.length && !y.prerelease.length)
                  return -1;
                if (!this.prerelease.length && y.prerelease.length)
                  return 1;
                if (!this.prerelease.length && !y.prerelease.length)
                  return 0;
                let h = 0;
                do {
                  let g = this.prerelease[h], p = y.prerelease[h];
                  if (t("prerelease compare", h, g, p), g === void 0 && p === void 0)
                    return 0;
                  if (p === void 0)
                    return 1;
                  if (g === void 0)
                    return -1;
                  if (g !== p)
                    return l(g, p);
                } while (++h);
              }
              compareBuild(y) {
                y instanceof c || (y = new c(y, this.options));
                let h = 0;
                do {
                  let g = this.build[h], p = y.build[h];
                  if (t("prerelease compare", h, g, p), g === void 0 && p === void 0)
                    return 0;
                  if (p === void 0)
                    return 1;
                  if (g === void 0)
                    return -1;
                  if (g !== p)
                    return l(g, p);
                } while (++h);
              }
              inc(y, h) {
                switch (y) {
                  case "premajor":
                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", h);
                    break;
                  case "preminor":
                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", h);
                    break;
                  case "prepatch":
                    this.prerelease.length = 0, this.inc("patch", h), this.inc("pre", h);
                    break;
                  case "prerelease":
                    this.prerelease.length === 0 && this.inc("patch", h), this.inc("pre", h);
                    break;
                  case "major":
                    (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                    break;
                  case "minor":
                    (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                    break;
                  case "patch":
                    this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                    break;
                  case "pre":
                    if (this.prerelease.length === 0)
                      this.prerelease = [0];
                    else {
                      let g = this.prerelease.length;
                      for (; --g >= 0; )
                        typeof this.prerelease[g] == "number" && (this.prerelease[g]++, g = -2);
                      g === -1 && this.prerelease.push(0);
                    }
                    h && (l(this.prerelease[0], h) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [h, 0]) : this.prerelease = [h, 0]);
                    break;
                  default:
                    throw new Error(`invalid increment argument: ${y}`);
                }
                return this.format(), this.raw = this.version, this;
              }
            };
            n.exports = c;
          } }), Mn = ee({ "node_modules/semver/functions/compare.js"(e, n) {
            re();
            var t = vD(), s = (a, r, u) => new t(a, u).compare(new t(r, u));
            n.exports = s;
          } }), CD = ee({ "node_modules/semver/functions/lt.js"(e, n) {
            re();
            var t = Mn(), s = (a, r, u) => t(a, r, u) < 0;
            n.exports = s;
          } }), ED = ee({ "node_modules/semver/functions/gte.js"(e, n) {
            re();
            var t = Mn(), s = (a, r, u) => t(a, r, u) >= 0;
            n.exports = s;
          } }), FD = ee({ "src/utils/arrayify.js"(e, n) {
            "use strict";
            re(), n.exports = (t, s) => Object.entries(t).map((a) => {
              let [r, u] = a;
              return Object.assign({ [s]: r }, u);
            });
          } }), AD = ee({ "node_modules/outdent/lib/index.js"(e, n) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
            function t() {
              for (var F = [], A3 = 0; A3 < arguments.length; A3++)
                F[A3] = arguments[A3];
            }
            function s() {
              return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a();
            }
            function a() {
              return { add: t, delete: t, get: t, set: t, has: function(F) {
                return false;
              } };
            }
            var r = Object.prototype.hasOwnProperty, u = function(F, A3) {
              return r.call(F, A3);
            };
            function i(F, A3) {
              for (var B in A3)
                u(A3, B) && (F[B] = A3[B]);
              return F;
            }
            var l = /^[ \t]*(?:\r\n|\r|\n)/, c = /(?:\r\n|\r|\n)[ \t]*$/, y = /^(?:[\r\n]|$)/, h = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g = /^[ \t]*[\r\n][ \t\r\n]*$/;
            function p(F, A3, B) {
              var I = 0, P2 = F[0].match(h);
              P2 && (I = P2[1].length);
              var R = "(\\r\\n|\\r|\\n).{0," + I + "}", f = new RegExp(R, "g");
              A3 && (F = F.slice(1));
              var x = B.newline, m = B.trimLeadingNewline, E = B.trimTrailingNewline, o = typeof x == "string", d = F.length, C = F.map(function(_, b) {
                return _ = _.replace(f, "$1"), b === 0 && m && (_ = _.replace(l, "")), b === d - 1 && E && (_ = _.replace(c, "")), o && (_ = _.replace(/\r\n|\n|\r/g, function(N) {
                  return x;
                })), _;
              });
              return C;
            }
            function D(F, A3) {
              for (var B = "", I = 0, P2 = F.length; I < P2; I++)
                B += F[I], I < P2 - 1 && (B += A3[I]);
              return B;
            }
            function v(F) {
              return u(F, "raw") && u(F, "length");
            }
            function w(F) {
              var A3 = s(), B = s();
              function I(R) {
                for (var f = [], x = 1; x < arguments.length; x++)
                  f[x - 1] = arguments[x];
                if (v(R)) {
                  var m = R, E = (f[0] === I || f[0] === T) && g.test(m[0]) && y.test(m[1]), o = E ? B : A3, d = o.get(m);
                  if (d || (d = p(m, E, F), o.set(m, d)), f.length === 0)
                    return d[0];
                  var C = D(d, E ? f.slice(1) : f);
                  return C;
                } else
                  return w(i(i({}, F), R || {}));
              }
              var P2 = i(I, { string: function(R) {
                return p([R], false, F)[0];
              } });
              return P2;
            }
            var T = w({ trimLeadingNewline: true, trimTrailingNewline: true });
            if (e.outdent = T, e.default = T, typeof n < "u")
              try {
                n.exports = T, Object.defineProperty(T, "__esModule", { value: true }), T.default = T, T.outdent = T;
              } catch {
              }
          } }), SD = ee({ "src/main/core-options.js"(e, n) {
            "use strict";
            re();
            var { outdent: t } = AD(), s = "Config", a = "Editor", r = "Format", u = "Other", i = "Output", l = "Global", c = "Special", y = { cursorOffset: { since: "1.4.0", category: c, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: c, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: c, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (h) => typeof h == "string" || typeof h == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: t`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: c, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, rangeStart: { since: "1.4.0", category: c, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, requirePragma: { since: "1.7.0", category: c, type: "boolean", default: false, description: t`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
            n.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: a, CATEGORY_FORMAT: r, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: c, options: y };
          } }), Rn = ee({ "src/main/support.js"(e, n) {
            "use strict";
            re();
            var t = { compare: Mn(), lt: CD(), gte: ED() }, s = FD(), a = fa().version, r = SD().options;
            function u() {
              let { plugins: l = [], showUnreleased: c = false, showDeprecated: y = false, showInternal: h = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = a.split("-", 1)[0], p = l.flatMap((F) => F.languages || []).filter(v), D = s(Object.assign({}, ...l.map((F) => {
                let { options: A3 } = F;
                return A3;
              }), r), "name").filter((F) => v(F) && w(F)).sort((F, A3) => F.name === A3.name ? 0 : F.name < A3.name ? -1 : 1).map(T).map((F) => {
                F = Object.assign({}, F), Array.isArray(F.default) && (F.default = F.default.length === 1 ? F.default[0].value : F.default.filter(v).sort((B, I) => t.compare(I.since, B.since))[0].value), Array.isArray(F.choices) && (F.choices = F.choices.filter((B) => v(B) && w(B)), F.name === "parser" && i(F, p, l));
                let A3 = Object.fromEntries(l.filter((B) => B.defaultOptions && B.defaultOptions[F.name] !== void 0).map((B) => [B.name, B.defaultOptions[F.name]]));
                return Object.assign(Object.assign({}, F), {}, { pluginDefaults: A3 });
              });
              return { languages: p, options: D };
              function v(F) {
                return c || !("since" in F) || F.since && t.gte(g, F.since);
              }
              function w(F) {
                return y || !("deprecated" in F) || F.deprecated && t.lt(g, F.deprecated);
              }
              function T(F) {
                if (h)
                  return F;
                let { cliName: A3, cliCategory: B, cliDescription: I } = F;
                return Ln(F, Uf);
              }
            }
            function i(l, c, y) {
              let h = new Set(l.choices.map((g) => g.value));
              for (let g of c)
                if (g.parsers) {
                  for (let p of g.parsers)
                    if (!h.has(p)) {
                      h.add(p);
                      let D = y.find((w) => w.parsers && w.parsers[p]), v = g.name;
                      D && D.name && (v += ` (plugin: ${D.name})`), l.choices.push({ value: p, description: v });
                    }
                }
            }
            n.exports = { getSupportInfo: u };
          } }), $n = ee({ "src/utils/is-non-empty-array.js"(e, n) {
            "use strict";
            re();
            function t(s) {
              return Array.isArray(s) && s.length > 0;
            }
            n.exports = t;
          } }), _r = ee({ "src/utils/text/skip.js"(e, n) {
            "use strict";
            re();
            function t(i) {
              return (l, c, y) => {
                let h = y && y.backwards;
                if (c === false)
                  return false;
                let { length: g } = l, p = c;
                for (; p >= 0 && p < g; ) {
                  let D = l.charAt(p);
                  if (i instanceof RegExp) {
                    if (!i.test(D))
                      return p;
                  } else if (!i.includes(D))
                    return p;
                  h ? p-- : p++;
                }
                return p === -1 || p === g ? p : false;
              };
            }
            var s = t(/\s/), a = t(" 	"), r = t(",; 	"), u = t(/[^\n\r]/);
            n.exports = { skipWhitespace: s, skipSpaces: a, skipToLineEnd: r, skipEverythingButNewLine: u };
          } }), va = ee({ "src/utils/text/skip-inline-comment.js"(e, n) {
            "use strict";
            re();
            function t(s, a) {
              if (a === false)
                return false;
              if (s.charAt(a) === "/" && s.charAt(a + 1) === "*") {
                for (let r = a + 2; r < s.length; ++r)
                  if (s.charAt(r) === "*" && s.charAt(r + 1) === "/")
                    return r + 2;
              }
              return a;
            }
            n.exports = t;
          } }), Ca = ee({ "src/utils/text/skip-trailing-comment.js"(e, n) {
            "use strict";
            re();
            var { skipEverythingButNewLine: t } = _r();
            function s(a, r) {
              return r === false ? false : a.charAt(r) === "/" && a.charAt(r + 1) === "/" ? t(a, r) : r;
            }
            n.exports = s;
          } }), Ea = ee({ "src/utils/text/skip-newline.js"(e, n) {
            "use strict";
            re();
            function t(s, a, r) {
              let u = r && r.backwards;
              if (a === false)
                return false;
              let i = s.charAt(a);
              if (u) {
                if (s.charAt(a - 1) === "\r" && i === `
`)
                  return a - 2;
                if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                  return a - 1;
              } else {
                if (i === "\r" && s.charAt(a + 1) === `
`)
                  return a + 2;
                if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                  return a + 1;
              }
              return a;
            }
            n.exports = t;
          } }), xD = ee({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, n) {
            "use strict";
            re();
            var t = va(), s = Ea(), a = Ca(), { skipSpaces: r } = _r();
            function u(i, l) {
              let c = null, y = l;
              for (; y !== c; )
                c = y, y = r(i, y), y = t(i, y), y = a(i, y), y = s(i, y);
              return y;
            }
            n.exports = u;
          } }), Ge = ee({ "src/common/util.js"(e, n) {
            "use strict";
            re();
            var { default: t } = (dD(), ft(ga)), s = lt(), { getSupportInfo: a } = Rn(), r = $n(), u = da(), { skipWhitespace: i, skipSpaces: l, skipToLineEnd: c, skipEverythingButNewLine: y } = _r(), h = va(), g = Ca(), p = Ea(), D = xD(), v = (V) => V[V.length - 2];
            function w(V) {
              return (O, K, se) => {
                let Q = se && se.backwards;
                if (K === false)
                  return false;
                let { length: le } = O, W = K;
                for (; W >= 0 && W < le; ) {
                  let X = O.charAt(W);
                  if (V instanceof RegExp) {
                    if (!V.test(X))
                      return W;
                  } else if (!V.includes(X))
                    return W;
                  Q ? W-- : W++;
                }
                return W === -1 || W === le ? W : false;
              };
            }
            function T(V, O) {
              let K = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, se = l(V, K.backwards ? O - 1 : O, K), Q = p(V, se, K);
              return se !== Q;
            }
            function F(V, O, K) {
              for (let se = O; se < K; ++se)
                if (V.charAt(se) === `
`)
                  return true;
              return false;
            }
            function A3(V, O, K) {
              let se = K(O) - 1;
              se = l(V, se, { backwards: true }), se = p(V, se, { backwards: true }), se = l(V, se, { backwards: true });
              let Q = p(V, se, { backwards: true });
              return se !== Q;
            }
            function B(V, O) {
              let K = null, se = O;
              for (; se !== K; )
                K = se, se = c(V, se), se = h(V, se), se = l(V, se);
              return se = g(V, se), se = p(V, se), se !== false && T(V, se);
            }
            function I(V, O, K) {
              return B(V, K(O));
            }
            function P2(V, O, K) {
              return D(V, K(O));
            }
            function R(V, O, K) {
              return V.charAt(P2(V, O, K));
            }
            function f(V, O) {
              let K = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return l(V, K.backwards ? O - 1 : O, K) !== O;
            }
            function x(V, O) {
              let K = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, se = 0;
              for (let Q = K; Q < V.length; ++Q)
                V[Q] === "	" ? se = se + O - se % O : se++;
              return se;
            }
            function m(V, O) {
              let K = V.lastIndexOf(`
`);
              return K === -1 ? 0 : x(V.slice(K + 1).match(/^[\t ]*/)[0], O);
            }
            function E(V, O) {
              let K = { quote: '"', regex: /"/g, escaped: "&quot;" }, se = { quote: "'", regex: /'/g, escaped: "&apos;" }, Q = O === "'" ? se : K, le = Q === se ? K : se, W = Q;
              if (V.includes(Q.quote) || V.includes(le.quote)) {
                let X = (V.match(Q.regex) || []).length, oe = (V.match(le.regex) || []).length;
                W = X > oe ? le : Q;
              }
              return W;
            }
            function o(V, O) {
              let K = V.slice(1, -1), se = O.parser === "json" || O.parser === "json5" && O.quoteProps === "preserve" && !O.singleQuote ? '"' : O.__isInHtmlAttribute ? "'" : E(K, O.singleQuote ? "'" : '"').quote;
              return d(K, se, !(O.parser === "css" || O.parser === "less" || O.parser === "scss" || O.__embeddedInHtml));
            }
            function d(V, O, K) {
              let se = O === '"' ? "'" : '"', Q = /\\(.)|(["'])/gs, le = V.replace(Q, (W, X, oe) => X === se ? X : oe === O ? "\\" + oe : oe || (K && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(X) ? X : "\\" + X));
              return O + le + O;
            }
            function C(V) {
              return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
            }
            function _(V, O) {
              let K = V.match(new RegExp(`(${t(O)})+`, "g"));
              return K === null ? 0 : K.reduce((se, Q) => Math.max(se, Q.length / O.length), 0);
            }
            function b(V, O) {
              let K = V.match(new RegExp(`(${t(O)})+`, "g"));
              if (K === null)
                return 0;
              let se = /* @__PURE__ */ new Map(), Q = 0;
              for (let le of K) {
                let W = le.length / O.length;
                se.set(W, true), W > Q && (Q = W);
              }
              for (let le = 1; le < Q; le++)
                if (!se.get(le))
                  return le;
              return Q + 1;
            }
            function N(V, O) {
              (V.comments || (V.comments = [])).push(O), O.printed = false, O.nodeDescription = Y(V);
            }
            function k(V, O) {
              O.leading = true, O.trailing = false, N(V, O);
            }
            function $(V, O, K) {
              O.leading = false, O.trailing = false, K && (O.marker = K), N(V, O);
            }
            function M(V, O) {
              O.leading = false, O.trailing = true, N(V, O);
            }
            function q(V, O) {
              let { languages: K } = a({ plugins: O.plugins }), se = K.find((Q) => {
                let { name: le } = Q;
                return le.toLowerCase() === V;
              }) || K.find((Q) => {
                let { aliases: le } = Q;
                return Array.isArray(le) && le.includes(V);
              }) || K.find((Q) => {
                let { extensions: le } = Q;
                return Array.isArray(le) && le.includes(`.${V}`);
              });
              return se && se.parsers[0];
            }
            function J(V) {
              return V && V.type === "front-matter";
            }
            function L(V) {
              let O = /* @__PURE__ */ new WeakMap();
              return function(K) {
                return O.has(K) || O.set(K, Symbol(V)), O.get(K);
              };
            }
            function Y(V) {
              let O = V.type || V.kind || "(unknown type)", K = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
              return K.length > 20 && (K = K.slice(0, 19) + "\u2026"), O + (K ? " " + K : "");
            }
            n.exports = { inferParserByLanguage: q, getStringWidth: u, getMaxContinuousCount: _, getMinNotPresentContinuousCount: b, getPenultimate: v, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: D, getNextNonSpaceNonCommentCharacterIndex: P2, getNextNonSpaceNonCommentCharacter: R, skip: w, skipWhitespace: i, skipSpaces: l, skipToLineEnd: c, skipEverythingButNewLine: y, skipInlineComment: h, skipTrailingComment: g, skipNewline: p, isNextLineEmptyAfterIndex: B, isNextLineEmpty: I, isPreviousLineEmpty: A3, hasNewline: T, hasNewlineInRange: F, hasSpaces: f, getAlignmentSize: x, getIndentSize: m, getPreferredQuote: E, printString: o, printNumber: C, makeString: d, addLeadingComment: k, addDanglingComment: $, addTrailingComment: M, isFrontMatterNode: J, isNonEmptyArray: r, createGroupIdMapper: L };
          } }), Fa = {};
          zt(Fa, { basename: () => Ta, default: () => Na, delimiter: () => wn, dirname: () => ba, extname: () => Ba, isAbsolute: () => Wn, join: () => Sa, normalize: () => Vn, relative: () => xa, resolve: () => Nr, sep: () => Nn });
          function Aa(e, n) {
            for (var t = 0, s = e.length - 1; s >= 0; s--) {
              var a = e[s];
              a === "." ? e.splice(s, 1) : a === ".." ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);
            }
            if (n)
              for (; t--; t)
                e.unshift("..");
            return e;
          }
          function Nr() {
            for (var e = "", n = false, t = arguments.length - 1; t >= -1 && !n; t--) {
              var s = t >= 0 ? arguments[t] : "/";
              if (typeof s != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              !s || (e = s + "/" + e, n = s.charAt(0) === "/");
            }
            return e = Aa(Hn(e.split("/"), function(a) {
              return !!a;
            }), !n).join("/"), (n ? "/" : "") + e || ".";
          }
          function Vn(e) {
            var n = Wn(e), t = wa(e, -1) === "/";
            return e = Aa(Hn(e.split("/"), function(s) {
              return !!s;
            }), !n).join("/"), !e && !n && (e = "."), e && t && (e += "/"), (n ? "/" : "") + e;
          }
          function Wn(e) {
            return e.charAt(0) === "/";
          }
          function Sa() {
            var e = Array.prototype.slice.call(arguments, 0);
            return Vn(Hn(e, function(n, t) {
              if (typeof n != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return n;
            }).join("/"));
          }
          function xa(e, n) {
            e = Nr(e).substr(1), n = Nr(n).substr(1);
            function t(c) {
              for (var y = 0; y < c.length && c[y] === ""; y++)
                ;
              for (var h = c.length - 1; h >= 0 && c[h] === ""; h--)
                ;
              return y > h ? [] : c.slice(y, h - y + 1);
            }
            for (var s = t(e.split("/")), a = t(n.split("/")), r = Math.min(s.length, a.length), u = r, i = 0; i < r; i++)
              if (s[i] !== a[i]) {
                u = i;
                break;
              }
            for (var l = [], i = u; i < s.length; i++)
              l.push("..");
            return l = l.concat(a.slice(u)), l.join("/");
          }
          function ba(e) {
            var n = Pr(e), t = n[0], s = n[1];
            return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
          }
          function Ta(e, n) {
            var t = Pr(e)[2];
            return n && t.substr(-1 * n.length) === n && (t = t.substr(0, t.length - n.length)), t;
          }
          function Ba(e) {
            return Pr(e)[3];
          }
          function Hn(e, n) {
            if (e.filter)
              return e.filter(n);
            for (var t = [], s = 0; s < e.length; s++)
              n(e[s], s, e) && t.push(e[s]);
            return t;
          }
          var oa, Pr, Nn, wn, Na, wa, bD = gt({ "node-modules-polyfills:path"() {
            re(), oa = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Pr = function(e) {
              return oa.exec(e).slice(1);
            }, Nn = "/", wn = ":", Na = { extname: Ba, basename: Ta, dirname: ba, sep: Nn, delimiter: wn, relative: xa, join: Sa, isAbsolute: Wn, normalize: Vn, resolve: Nr }, wa = "ab".substr(-1) === "b" ? function(e, n, t) {
              return e.substr(n, t);
            } : function(e, n, t) {
              return n < 0 && (n = e.length + n), e.substr(n, t);
            };
          } }), TD = ee({ "node-modules-polyfills-commonjs:path"(e, n) {
            re();
            var t = (bD(), ft(Fa));
            if (t && t.default) {
              n.exports = t.default;
              for (let s in t)
                n.exports[s] = t[s];
            } else
              t && (n.exports = t);
          } }), Kt = ee({ "src/common/errors.js"(e, n) {
            "use strict";
            re();
            var t = class extends Error {
            }, s = class extends Error {
            }, a = class extends Error {
            }, r = class extends Error {
            };
            n.exports = { ConfigError: t, DebugError: s, UndefinedParserError: a, ArgExpansionBailout: r };
          } }), yt = {};
          zt(yt, { __assign: () => Br, __asyncDelegator: () => RD, __asyncGenerator: () => MD, __asyncValues: () => $D, __await: () => Jt, __awaiter: () => ID, __classPrivateFieldGet: () => GD, __classPrivateFieldSet: () => UD, __createBinding: () => LD, __decorate: () => wD, __exportStar: () => jD, __extends: () => BD, __generator: () => kD, __importDefault: () => HD, __importStar: () => WD, __makeTemplateObject: () => VD, __metadata: () => PD, __param: () => _D, __read: () => _a, __rest: () => ND, __spread: () => OD, __spreadArrays: () => qD, __values: () => _n });
          function BD(e, n) {
            Tr(e, n);
            function t() {
              this.constructor = e;
            }
            e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());
          }
          function ND(e, n) {
            var t = {};
            for (var s in e)
              Object.prototype.hasOwnProperty.call(e, s) && n.indexOf(s) < 0 && (t[s] = e[s]);
            if (e != null && typeof Object.getOwnPropertySymbols == "function")
              for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++)
                n.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t[s[a]] = e[s[a]]);
            return t;
          }
          function wD(e, n, t, s) {
            var a = arguments.length, r = a < 3 ? n : s === null ? s = Object.getOwnPropertyDescriptor(n, t) : s, u;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
              r = Reflect.decorate(e, n, t, s);
            else
              for (var i = e.length - 1; i >= 0; i--)
                (u = e[i]) && (r = (a < 3 ? u(r) : a > 3 ? u(n, t, r) : u(n, t)) || r);
            return a > 3 && r && Object.defineProperty(n, t, r), r;
          }
          function _D(e, n) {
            return function(t, s) {
              n(t, s, e);
            };
          }
          function PD(e, n) {
            if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
              return Reflect.metadata(e, n);
          }
          function ID(e, n, t, s) {
            function a(r) {
              return r instanceof t ? r : new t(function(u) {
                u(r);
              });
            }
            return new (t || (t = Promise))(function(r, u) {
              function i(y) {
                try {
                  c(s.next(y));
                } catch (h) {
                  u(h);
                }
              }
              function l(y) {
                try {
                  c(s.throw(y));
                } catch (h) {
                  u(h);
                }
              }
              function c(y) {
                y.done ? r(y.value) : a(y.value).then(i, l);
              }
              c((s = s.apply(e, n || [])).next());
            });
          }
          function kD(e, n) {
            var t = { label: 0, sent: function() {
              if (r[0] & 1)
                throw r[1];
              return r[1];
            }, trys: [], ops: [] }, s, a, r, u;
            return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
              return this;
            }), u;
            function i(c) {
              return function(y) {
                return l([c, y]);
              };
            }
            function l(c) {
              if (s)
                throw new TypeError("Generator is already executing.");
              for (; t; )
                try {
                  if (s = 1, a && (r = c[0] & 2 ? a.return : c[0] ? a.throw || ((r = a.return) && r.call(a), 0) : a.next) && !(r = r.call(a, c[1])).done)
                    return r;
                  switch (a = 0, r && (c = [c[0] & 2, r.value]), c[0]) {
                    case 0:
                    case 1:
                      r = c;
                      break;
                    case 4:
                      return t.label++, { value: c[1], done: false };
                    case 5:
                      t.label++, a = c[1], c = [0];
                      continue;
                    case 7:
                      c = t.ops.pop(), t.trys.pop();
                      continue;
                    default:
                      if (r = t.trys, !(r = r.length > 0 && r[r.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                      }
                      if (c[0] === 3 && (!r || c[1] > r[0] && c[1] < r[3])) {
                        t.label = c[1];
                        break;
                      }
                      if (c[0] === 6 && t.label < r[1]) {
                        t.label = r[1], r = c;
                        break;
                      }
                      if (r && t.label < r[2]) {
                        t.label = r[2], t.ops.push(c);
                        break;
                      }
                      r[2] && t.ops.pop(), t.trys.pop();
                      continue;
                  }
                  c = n.call(e, t);
                } catch (y) {
                  c = [6, y], a = 0;
                } finally {
                  s = r = 0;
                }
              if (c[0] & 5)
                throw c[1];
              return { value: c[0] ? c[1] : void 0, done: true };
            }
          }
          function LD(e, n, t, s) {
            s === void 0 && (s = t), e[s] = n[t];
          }
          function jD(e, n) {
            for (var t in e)
              t !== "default" && !n.hasOwnProperty(t) && (n[t] = e[t]);
          }
          function _n(e) {
            var n = typeof Symbol == "function" && Symbol.iterator, t = n && e[n], s = 0;
            if (t)
              return t.call(e);
            if (e && typeof e.length == "number")
              return { next: function() {
                return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e };
              } };
            throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.");
          }
          function _a(e, n) {
            var t = typeof Symbol == "function" && e[Symbol.iterator];
            if (!t)
              return e;
            var s = t.call(e), a, r = [], u;
            try {
              for (; (n === void 0 || n-- > 0) && !(a = s.next()).done; )
                r.push(a.value);
            } catch (i) {
              u = { error: i };
            } finally {
              try {
                a && !a.done && (t = s.return) && t.call(s);
              } finally {
                if (u)
                  throw u.error;
              }
            }
            return r;
          }
          function OD() {
            for (var e = [], n = 0; n < arguments.length; n++)
              e = e.concat(_a(arguments[n]));
            return e;
          }
          function qD() {
            for (var e = 0, n = 0, t = arguments.length; n < t; n++)
              e += arguments[n].length;
            for (var s = Array(e), a = 0, n = 0; n < t; n++)
              for (var r = arguments[n], u = 0, i = r.length; u < i; u++, a++)
                s[a] = r[u];
            return s;
          }
          function Jt(e) {
            return this instanceof Jt ? (this.v = e, this) : new Jt(e);
          }
          function MD(e, n, t) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var s = t.apply(e, n || []), a, r = [];
            return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function() {
              return this;
            }, a;
            function u(g) {
              s[g] && (a[g] = function(p) {
                return new Promise(function(D, v) {
                  r.push([g, p, D, v]) > 1 || i(g, p);
                });
              });
            }
            function i(g, p) {
              try {
                l(s[g](p));
              } catch (D) {
                h(r[0][3], D);
              }
            }
            function l(g) {
              g.value instanceof Jt ? Promise.resolve(g.value.v).then(c, y) : h(r[0][2], g);
            }
            function c(g) {
              i("next", g);
            }
            function y(g) {
              i("throw", g);
            }
            function h(g, p) {
              g(p), r.shift(), r.length && i(r[0][0], r[0][1]);
            }
          }
          function RD(e) {
            var n, t;
            return n = {}, s("next"), s("throw", function(a) {
              throw a;
            }), s("return"), n[Symbol.iterator] = function() {
              return this;
            }, n;
            function s(a, r) {
              n[a] = e[a] ? function(u) {
                return (t = !t) ? { value: Jt(e[a](u)), done: a === "return" } : r ? r(u) : u;
              } : r;
            }
          }
          function $D(e) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var n = e[Symbol.asyncIterator], t;
            return n ? n.call(e) : (e = typeof _n == "function" ? _n(e) : e[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
              return this;
            }, t);
            function s(r) {
              t[r] = e[r] && function(u) {
                return new Promise(function(i, l) {
                  u = e[r](u), a(i, l, u.done, u.value);
                });
              };
            }
            function a(r, u, i, l) {
              Promise.resolve(l).then(function(c) {
                r({ value: c, done: i });
              }, u);
            }
          }
          function VD(e, n) {
            return Object.defineProperty ? Object.defineProperty(e, "raw", { value: n }) : e.raw = n, e;
          }
          function WD(e) {
            if (e && e.__esModule)
              return e;
            var n = {};
            if (e != null)
              for (var t in e)
                Object.hasOwnProperty.call(e, t) && (n[t] = e[t]);
            return n.default = e, n;
          }
          function HD(e) {
            return e && e.__esModule ? e : { default: e };
          }
          function GD(e, n) {
            if (!n.has(e))
              throw new TypeError("attempted to get private field on non-instance");
            return n.get(e);
          }
          function UD(e, n, t) {
            if (!n.has(e))
              throw new TypeError("attempted to set private field on non-instance");
            return n.set(e, t), t;
          }
          var Tr, Br, Ct = gt({ "node_modules/tslib/tslib.es6.js"() {
            re(), Tr = function(e, n) {
              return Tr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
                t.__proto__ = s;
              } || function(t, s) {
                for (var a in s)
                  s.hasOwnProperty(a) && (t[a] = s[a]);
              }, Tr(e, n);
            }, Br = function() {
              return Br = Object.assign || function(n) {
                for (var t, s = 1, a = arguments.length; s < a; s++) {
                  t = arguments[s];
                  for (var r in t)
                    Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }, Br.apply(this, arguments);
            };
          } }), Pa = ee({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (n) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n) ? n : JSON.stringify(n), value(n) {
              if (n === null || typeof n != "object")
                return JSON.stringify(n);
              if (Array.isArray(n))
                return `[${n.map((s) => e.apiDescriptor.value(s)).join(", ")}]`;
              let t = Object.keys(n);
              return t.length === 0 ? "{}" : `{ ${t.map((s) => `${e.apiDescriptor.key(s)}: ${e.apiDescriptor.value(n[s])}`).join(", ")} }`;
            }, pair: (n) => {
              let { key: t, value: s } = n;
              return e.apiDescriptor.value({ [t]: s });
            } };
          } }), JD = ee({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (Ct(), ft(yt));
            n.__exportStar(Pa(), e);
          } }), Ir = ee({ "scripts/build/shims/chalk.cjs"(e, n) {
            "use strict";
            re();
            var t = (s) => s;
            t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, n.exports = t;
          } }), Ia = ee({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Ir();
            e.commonDeprecatedHandler = (t, s, a) => {
              let { descriptor: r } = a, u = [`${n.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t))} is deprecated`];
              return s && u.push(`we now treat it as ${n.default.blue(typeof s == "string" ? r.key(s) : r.pair(s))}`), u.join("; ") + ".";
            };
          } }), zD = ee({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (Ct(), ft(yt));
            n.__exportStar(Ia(), e);
          } }), XD = ee({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Ir();
            e.commonInvalidHandler = (t, s, a) => [`Invalid ${n.default.red(a.descriptor.key(t))} value.`, `Expected ${n.default.blue(a.schemas[t].expected(a))},`, `but received ${n.default.red(a.descriptor.value(s))}.`].join(" ");
          } }), ka = ee({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (Ct(), ft(yt));
            n.__exportStar(XD(), e);
          } }), KD = ee({ "node_modules/vnopts/node_modules/leven/index.js"(e, n) {
            "use strict";
            re();
            var t = [], s = [];
            n.exports = function(a, r) {
              if (a === r)
                return 0;
              var u = a;
              a.length > r.length && (a = r, r = u);
              var i = a.length, l = r.length;
              if (i === 0)
                return l;
              if (l === 0)
                return i;
              for (; i > 0 && a.charCodeAt(~-i) === r.charCodeAt(~-l); )
                i--, l--;
              if (i === 0)
                return l;
              for (var c = 0; c < i && a.charCodeAt(c) === r.charCodeAt(c); )
                c++;
              if (i -= c, l -= c, i === 0)
                return l;
              for (var y, h, g, p, D = 0, v = 0; D < i; )
                s[c + D] = a.charCodeAt(c + D), t[D] = ++D;
              for (; v < l; )
                for (y = r.charCodeAt(c + v), g = v++, h = v, D = 0; D < i; D++)
                  p = y === s[c + D] ? g : g + 1, g = t[D], h = t[D] = g > h ? p > h ? h + 1 : p : p > g ? g + 1 : p;
              return h;
            };
          } }), La = ee({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Ir(), t = KD();
            e.levenUnknownHandler = (s, a, r) => {
              let { descriptor: u, logger: i, schemas: l } = r, c = [`Ignored unknown option ${n.default.yellow(u.pair({ key: s, value: a }))}.`], y = Object.keys(l).sort().find((h) => t(s, h) < 3);
              y && c.push(`Did you mean ${n.default.blue(u.key(y))}?`), i.warn(c.join(" "));
            };
          } }), YD = ee({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (Ct(), ft(yt));
            n.__exportStar(La(), e);
          } }), QD = ee({ "node_modules/vnopts/lib/handlers/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (Ct(), ft(yt));
            n.__exportStar(zD(), e), n.__exportStar(ka(), e), n.__exportStar(YD(), e);
          } }), Et = ee({ "node_modules/vnopts/lib/schema.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
            function t(r, u) {
              let i = new r(u), l = Object.create(i);
              for (let c of n)
                c in u && (l[c] = a(u[c], i, s.prototype[c].length));
              return l;
            }
            e.createSchema = t;
            var s = class {
              constructor(r) {
                this.name = r.name;
              }
              static create(r) {
                return t(this, r);
              }
              default(r) {
              }
              expected(r) {
                return "nothing";
              }
              validate(r, u) {
                return false;
              }
              deprecated(r, u) {
                return false;
              }
              forward(r, u) {
              }
              redirect(r, u) {
              }
              overlap(r, u, i) {
                return r;
              }
              preprocess(r, u) {
                return r;
              }
              postprocess(r, u) {
                return r;
              }
            };
            e.Schema = s;
            function a(r, u, i) {
              return typeof r == "function" ? function() {
                for (var l = arguments.length, c = new Array(l), y = 0; y < l; y++)
                  c[y] = arguments[y];
                return r(...c.slice(0, i - 1), u, ...c.slice(i - 1));
              } : () => r;
            }
          } }), ZD = ee({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Et(), t = class extends n.Schema {
              constructor(s) {
                super(s), this._sourceName = s.sourceName;
              }
              expected(s) {
                return s.schemas[this._sourceName].expected(s);
              }
              validate(s, a) {
                return a.schemas[this._sourceName].validate(s, a);
              }
              redirect(s, a) {
                return this._sourceName;
              }
            };
            e.AliasSchema = t;
          } }), em = ee({ "node_modules/vnopts/lib/schemas/any.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Et(), t = class extends n.Schema {
              expected() {
                return "anything";
              }
              validate() {
                return true;
              }
            };
            e.AnySchema = t;
          } }), tm = ee({ "node_modules/vnopts/lib/schemas/array.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (Ct(), ft(yt)), t = Et(), s = class extends t.Schema {
              constructor(r) {
                var { valueSchema: u, name: i = u.name } = r, l = n.__rest(r, ["valueSchema", "name"]);
                super(Object.assign({}, l, { name: i })), this._valueSchema = u;
              }
              expected(r) {
                return `an array of ${this._valueSchema.expected(r)}`;
              }
              validate(r, u) {
                if (!Array.isArray(r))
                  return false;
                let i = [];
                for (let l of r) {
                  let c = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);
                  c !== true && i.push(c.value);
                }
                return i.length === 0 ? true : { value: i };
              }
              deprecated(r, u) {
                let i = [];
                for (let l of r) {
                  let c = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);
                  c !== false && i.push(...c.map((y) => {
                    let { value: h } = y;
                    return { value: [h] };
                  }));
                }
                return i;
              }
              forward(r, u) {
                let i = [];
                for (let l of r) {
                  let c = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);
                  i.push(...c.map(a));
                }
                return i;
              }
              redirect(r, u) {
                let i = [], l = [];
                for (let c of r) {
                  let y = u.normalizeRedirectResult(this._valueSchema.redirect(c, u), c);
                  "remain" in y && i.push(y.remain), l.push(...y.redirect.map(a));
                }
                return i.length === 0 ? { redirect: l } : { redirect: l, remain: i };
              }
              overlap(r, u) {
                return r.concat(u);
              }
            };
            e.ArraySchema = s;
            function a(r) {
              let { from: u, to: i } = r;
              return { from: [u], to: i };
            }
          } }), rm = ee({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Et(), t = class extends n.Schema {
              expected() {
                return "true or false";
              }
              validate(s) {
                return typeof s == "boolean";
              }
            };
            e.BooleanSchema = t;
          } }), Gn = ee({ "node_modules/vnopts/lib/utils.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            function n(p, D) {
              let v = /* @__PURE__ */ Object.create(null);
              for (let w of p) {
                let T = w[D];
                if (v[T])
                  throw new Error(`Duplicate ${D} ${JSON.stringify(T)}`);
                v[T] = w;
              }
              return v;
            }
            e.recordFromArray = n;
            function t(p, D) {
              let v = /* @__PURE__ */ new Map();
              for (let w of p) {
                let T = w[D];
                if (v.has(T))
                  throw new Error(`Duplicate ${D} ${JSON.stringify(T)}`);
                v.set(T, w);
              }
              return v;
            }
            e.mapFromArray = t;
            function s() {
              let p = /* @__PURE__ */ Object.create(null);
              return (D) => {
                let v = JSON.stringify(D);
                return p[v] ? true : (p[v] = true, false);
              };
            }
            e.createAutoChecklist = s;
            function a(p, D) {
              let v = [], w = [];
              for (let T of p)
                D(T) ? v.push(T) : w.push(T);
              return [v, w];
            }
            e.partition = a;
            function r(p) {
              return p === Math.floor(p);
            }
            e.isInt = r;
            function u(p, D) {
              if (p === D)
                return 0;
              let v = typeof p, w = typeof D, T = ["undefined", "object", "boolean", "number", "string"];
              return v !== w ? T.indexOf(v) - T.indexOf(w) : v !== "string" ? Number(p) - Number(D) : p.localeCompare(D);
            }
            e.comparePrimitive = u;
            function i(p) {
              return p === void 0 ? {} : p;
            }
            e.normalizeDefaultResult = i;
            function l(p, D) {
              return p === true ? true : p === false ? { value: D } : p;
            }
            e.normalizeValidateResult = l;
            function c(p, D) {
              let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return p === false ? false : p === true ? v ? true : [{ value: D }] : "value" in p ? [p] : p.length === 0 ? false : p;
            }
            e.normalizeDeprecatedResult = c;
            function y(p, D) {
              return typeof p == "string" || "key" in p ? { from: D, to: p } : "from" in p ? { from: p.from, to: p.to } : { from: D, to: p.to };
            }
            e.normalizeTransferResult = y;
            function h(p, D) {
              return p === void 0 ? [] : Array.isArray(p) ? p.map((v) => y(v, D)) : [y(p, D)];
            }
            e.normalizeForwardResult = h;
            function g(p, D) {
              let v = h(typeof p == "object" && "redirect" in p ? p.redirect : p, D);
              return v.length === 0 ? { remain: D, redirect: v } : typeof p == "object" && "remain" in p ? { remain: p.remain, redirect: v } : { redirect: v };
            }
            e.normalizeRedirectResult = g;
          } }), nm = ee({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Et(), t = Gn(), s = class extends n.Schema {
              constructor(a) {
                super(a), this._choices = t.mapFromArray(a.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
              }
              expected(a) {
                let { descriptor: r } = a, u = Array.from(this._choices.keys()).map((c) => this._choices.get(c)).filter((c) => !c.deprecated).map((c) => c.value).sort(t.comparePrimitive).map(r.value), i = u.slice(0, -2), l = u.slice(-2);
                return i.concat(l.join(" or ")).join(", ");
              }
              validate(a) {
                return this._choices.has(a);
              }
              deprecated(a) {
                let r = this._choices.get(a);
                return r && r.deprecated ? { value: a } : false;
              }
              forward(a) {
                let r = this._choices.get(a);
                return r ? r.forward : void 0;
              }
              redirect(a) {
                let r = this._choices.get(a);
                return r ? r.redirect : void 0;
              }
            };
            e.ChoiceSchema = s;
          } }), ja = ee({ "node_modules/vnopts/lib/schemas/number.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Et(), t = class extends n.Schema {
              expected() {
                return "a number";
              }
              validate(s, a) {
                return typeof s == "number";
              }
            };
            e.NumberSchema = t;
          } }), um = ee({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Gn(), t = ja(), s = class extends t.NumberSchema {
              expected() {
                return "an integer";
              }
              validate(a, r) {
                return r.normalizeValidateResult(super.validate(a, r), a) === true && n.isInt(a);
              }
            };
            e.IntegerSchema = s;
          } }), sm = ee({ "node_modules/vnopts/lib/schemas/string.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Et(), t = class extends n.Schema {
              expected() {
                return "a string";
              }
              validate(s) {
                return typeof s == "string";
              }
            };
            e.StringSchema = t;
          } }), im = ee({ "node_modules/vnopts/lib/schemas/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (Ct(), ft(yt));
            n.__exportStar(ZD(), e), n.__exportStar(em(), e), n.__exportStar(tm(), e), n.__exportStar(rm(), e), n.__exportStar(nm(), e), n.__exportStar(um(), e), n.__exportStar(ja(), e), n.__exportStar(sm(), e);
          } }), am = ee({ "node_modules/vnopts/lib/defaults.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Pa(), t = Ia(), s = ka(), a = La();
            e.defaultDescriptor = n.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
          } }), om = ee({ "node_modules/vnopts/lib/normalize.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = am(), t = Gn();
            e.normalize = (a, r, u) => new s(r, u).normalize(a);
            var s = class {
              constructor(a, r) {
                let { logger: u = console, descriptor: i = n.defaultDescriptor, unknown: l = n.defaultUnknownHandler, invalid: c = n.defaultInvalidHandler, deprecated: y = n.defaultDeprecatedHandler } = r || {};
                this._utils = { descriptor: i, logger: u || { warn: () => {
                } }, schemas: t.recordFromArray(a, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = l, this._invalidHandler = c, this._deprecatedHandler = y, this.cleanHistory();
              }
              cleanHistory() {
                this._hasDeprecationWarned = t.createAutoChecklist();
              }
              normalize(a) {
                let r = {}, u = [a], i = () => {
                  for (; u.length !== 0; ) {
                    let l = u.shift(), c = this._applyNormalization(l, r);
                    u.push(...c);
                  }
                };
                i();
                for (let l of Object.keys(this._utils.schemas)) {
                  let c = this._utils.schemas[l];
                  if (!(l in r)) {
                    let y = t.normalizeDefaultResult(c.default(this._utils));
                    "value" in y && u.push({ [l]: y.value });
                  }
                }
                i();
                for (let l of Object.keys(this._utils.schemas)) {
                  let c = this._utils.schemas[l];
                  l in r && (r[l] = c.postprocess(r[l], this._utils));
                }
                return r;
              }
              _applyNormalization(a, r) {
                let u = [], [i, l] = t.partition(Object.keys(a), (c) => c in this._utils.schemas);
                for (let c of i) {
                  let y = this._utils.schemas[c], h = y.preprocess(a[c], this._utils), g = t.normalizeValidateResult(y.validate(h, this._utils), h);
                  if (g !== true) {
                    let { value: T } = g, F = this._invalidHandler(c, T, this._utils);
                    throw typeof F == "string" ? new Error(F) : F;
                  }
                  let p = (T) => {
                    let { from: F, to: A3 } = T;
                    u.push(typeof A3 == "string" ? { [A3]: F } : { [A3.key]: A3.value });
                  }, D = (T) => {
                    let { value: F, redirectTo: A3 } = T, B = t.normalizeDeprecatedResult(y.deprecated(F, this._utils), h, true);
                    if (B !== false)
                      if (B === true)
                        this._hasDeprecationWarned(c) || this._utils.logger.warn(this._deprecatedHandler(c, A3, this._utils));
                      else
                        for (let { value: I } of B) {
                          let P2 = { key: c, value: I };
                          if (!this._hasDeprecationWarned(P2)) {
                            let R = typeof A3 == "string" ? { key: A3, value: I } : A3;
                            this._utils.logger.warn(this._deprecatedHandler(P2, R, this._utils));
                          }
                        }
                  };
                  t.normalizeForwardResult(y.forward(h, this._utils), h).forEach(p);
                  let w = t.normalizeRedirectResult(y.redirect(h, this._utils), h);
                  if (w.redirect.forEach(p), "remain" in w) {
                    let T = w.remain;
                    r[c] = c in r ? y.overlap(r[c], T, this._utils) : T, D({ value: T });
                  }
                  for (let { from: T, to: F } of w.redirect)
                    D({ value: T, redirectTo: F });
                }
                for (let c of l) {
                  let y = a[c], h = this._unknownHandler(c, y, this._utils);
                  if (h)
                    for (let g of Object.keys(h)) {
                      let p = { [g]: h[g] };
                      g in this._utils.schemas ? u.push(p) : Object.assign(r, p);
                    }
                }
                return u;
              }
            };
            e.Normalizer = s;
          } }), lm = ee({ "node_modules/vnopts/lib/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = (Ct(), ft(yt));
            n.__exportStar(JD(), e), n.__exportStar(QD(), e), n.__exportStar(im(), e), n.__exportStar(om(), e), n.__exportStar(Et(), e);
          } }), cm = ee({ "src/main/options-normalizer.js"(e, n) {
            "use strict";
            re();
            var t = lm(), s = lt(), a = { key: (g) => g.length === 1 ? `-${g}` : `--${g}`, value: (g) => t.apiDescriptor.value(g), pair: (g) => {
              let { key: p, value: D } = g;
              return D === false ? `--no-${p}` : D === true ? a.key(p) : D === "" ? `${a.key(p)} without an argument` : `${a.key(p)}=${D}`;
            } }, r = (g) => {
              let { colorsModule: p, levenshteinDistance: D } = g;
              return class extends t.ChoiceSchema {
                constructor(w) {
                  let { name: T, flags: F } = w;
                  super({ name: T, choices: F }), this._flags = [...F].sort();
                }
                preprocess(w, T) {
                  if (typeof w == "string" && w.length > 0 && !this._flags.includes(w)) {
                    let F = this._flags.find((A3) => D(A3, w) < 3);
                    if (F)
                      return T.logger.warn([`Unknown flag ${p.yellow(T.descriptor.value(w))},`, `did you mean ${p.blue(T.descriptor.value(F))}?`].join(" ")), F;
                  }
                  return w;
                }
                expected() {
                  return "a flag";
                }
              };
            }, u;
            function i(g, p) {
              let { logger: D = false, isCLI: v = false, passThrough: w = false, colorsModule: T = null, levenshteinDistance: F = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, A3 = w ? Array.isArray(w) ? (x, m) => w.includes(x) ? { [x]: m } : void 0 : (x, m) => ({ [x]: m }) : (x, m, E) => {
                let o = E.schemas, { _: d } = o, C = Ln(o, Jf);
                return t.levenUnknownHandler(x, m, Object.assign(Object.assign({}, E), {}, { schemas: C }));
              }, B = v ? a : t.apiDescriptor, I = l(p, { isCLI: v, colorsModule: T, levenshteinDistance: F }), P2 = new t.Normalizer(I, { logger: D, unknown: A3, descriptor: B }), R = D !== false;
              R && u && (P2._hasDeprecationWarned = u);
              let f = P2.normalize(g);
              return R && (u = P2._hasDeprecationWarned), v && f["plugin-search"] === false && (f["plugin-search-dir"] = false), f;
            }
            function l(g, p) {
              let { isCLI: D, colorsModule: v, levenshteinDistance: w } = p, T = [];
              D && T.push(t.AnySchema.create({ name: "_" }));
              for (let F of g)
                T.push(c(F, { isCLI: D, optionInfos: g, colorsModule: v, levenshteinDistance: w })), F.alias && D && T.push(t.AliasSchema.create({ name: F.alias, sourceName: F.name }));
              return T;
            }
            function c(g, p) {
              let { isCLI: D, optionInfos: v, colorsModule: w, levenshteinDistance: T } = p, { name: F } = g;
              if (F === "plugin-search-dir" || F === "pluginSearchDirs")
                return t.AnySchema.create({ name: F, preprocess(P2) {
                  return P2 === false || (P2 = Array.isArray(P2) ? P2 : [P2]), P2;
                }, validate(P2) {
                  return P2 === false ? true : P2.every((R) => typeof R == "string");
                }, expected() {
                  return "false or paths to plugin search dir";
                } });
              let A3 = { name: F }, B, I = {};
              switch (g.type) {
                case "int":
                  B = t.IntegerSchema, D && (A3.preprocess = Number);
                  break;
                case "string":
                  B = t.StringSchema;
                  break;
                case "choice":
                  B = t.ChoiceSchema, A3.choices = g.choices.map((P2) => typeof P2 == "object" && P2.redirect ? Object.assign(Object.assign({}, P2), {}, { redirect: { to: { key: g.name, value: P2.redirect } } }) : P2);
                  break;
                case "boolean":
                  B = t.BooleanSchema;
                  break;
                case "flag":
                  B = r({ colorsModule: w, levenshteinDistance: T }), A3.flags = v.flatMap((P2) => [P2.alias, P2.description && P2.name, P2.oppositeDescription && `no-${P2.name}`].filter(Boolean));
                  break;
                case "path":
                  B = t.StringSchema;
                  break;
                default:
                  throw new Error(`Unexpected type ${g.type}`);
              }
              if (g.exception ? A3.validate = (P2, R, f) => g.exception(P2) || R.validate(P2, f) : A3.validate = (P2, R, f) => P2 === void 0 || R.validate(P2, f), g.redirect && (I.redirect = (P2) => P2 ? { to: { key: g.redirect.option, value: g.redirect.value } } : void 0), g.deprecated && (I.deprecated = true), D && !g.array) {
                let P2 = A3.preprocess || ((R) => R);
                A3.preprocess = (R, f, x) => f.preprocess(P2(Array.isArray(R) ? s(R) : R), x);
              }
              return g.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, D ? { preprocess: (P2) => Array.isArray(P2) ? P2 : [P2] } : {}), I), {}, { valueSchema: B.create(A3) })) : B.create(Object.assign(Object.assign({}, A3), I));
            }
            function y(g, p, D) {
              return i(g, p, D);
            }
            function h(g, p, D) {
              return i(g, p, Object.assign({ isCLI: true }, D));
            }
            n.exports = { normalizeApiOptions: y, normalizeCliOptions: h };
          } }), it = ee({ "src/language-js/loc.js"(e, n) {
            "use strict";
            re();
            var t = $n();
            function s(l) {
              var c, y;
              let h = l.range ? l.range[0] : l.start, g = (c = (y = l.declaration) === null || y === void 0 ? void 0 : y.decorators) !== null && c !== void 0 ? c : l.decorators;
              return t(g) ? Math.min(s(g[0]), h) : h;
            }
            function a(l) {
              return l.range ? l.range[1] : l.end;
            }
            function r(l, c) {
              let y = s(l);
              return Number.isInteger(y) && y === s(c);
            }
            function u(l, c) {
              let y = a(l);
              return Number.isInteger(y) && y === a(c);
            }
            function i(l, c) {
              return r(l, c) && u(l, c);
            }
            n.exports = { locStart: s, locEnd: a, hasSameLocStart: r, hasSameLoc: i };
          } }), pm = ee({ "src/main/load-parser.js"(e, n) {
            re(), n.exports = () => {
            };
          } }), fm = ee({ "scripts/build/shims/babel-highlight.cjs"(e, n) {
            "use strict";
            re();
            var t = Ir(), s = { shouldHighlight: () => false, getChalk: () => t };
            n.exports = s;
          } }), Dm = ee({ "node_modules/@babel/code-frame/lib/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i;
            var n = fm(), t = false;
            function s(l) {
              return { gutter: l.grey, marker: l.red.bold, message: l.red.bold };
            }
            var a = /\r\n|[\n\r\u2028\u2029]/;
            function r(l, c, y) {
              let h = Object.assign({ column: 0, line: -1 }, l.start), g = Object.assign({}, h, l.end), { linesAbove: p = 2, linesBelow: D = 3 } = y || {}, v = h.line, w = h.column, T = g.line, F = g.column, A3 = Math.max(v - (p + 1), 0), B = Math.min(c.length, T + D);
              v === -1 && (A3 = 0), T === -1 && (B = c.length);
              let I = T - v, P2 = {};
              if (I)
                for (let R = 0; R <= I; R++) {
                  let f = R + v;
                  if (!w)
                    P2[f] = true;
                  else if (R === 0) {
                    let x = c[f - 1].length;
                    P2[f] = [w, x - w + 1];
                  } else if (R === I)
                    P2[f] = [0, F];
                  else {
                    let x = c[f - R].length;
                    P2[f] = [0, x];
                  }
                }
              else
                w === F ? w ? P2[v] = [w, 0] : P2[v] = true : P2[v] = [w, F - w];
              return { start: A3, end: B, markerLines: P2 };
            }
            function u(l, c) {
              let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h = (y.highlightCode || y.forceColor) && (0, n.shouldHighlight)(y), g = (0, n.getChalk)(y), p = s(g), D = (R, f) => h ? R(f) : f, v = l.split(a), { start: w, end: T, markerLines: F } = r(c, v, y), A3 = c.start && typeof c.start.column == "number", B = String(T).length, P2 = (h ? (0, n.default)(l, y) : l).split(a, T).slice(w, T).map((R, f) => {
                let x = w + 1 + f, E = ` ${` ${x}`.slice(-B)} |`, o = F[x], d = !F[x + 1];
                if (o) {
                  let C = "";
                  if (Array.isArray(o)) {
                    let _ = R.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), b = o[1] || 1;
                    C = [`
 `, D(p.gutter, E.replace(/\d/g, " ")), " ", _, D(p.marker, "^").repeat(b)].join(""), d && y.message && (C += " " + D(p.message, y.message));
                  }
                  return [D(p.marker, ">"), D(p.gutter, E), R.length > 0 ? ` ${R}` : "", C].join("");
                } else
                  return ` ${D(p.gutter, E)}${R.length > 0 ? ` ${R}` : ""}`;
              }).join(`
`);
              return y.message && !A3 && (P2 = `${" ".repeat(B + 1)}${y.message}
${P2}`), h ? g.reset(P2) : P2;
            }
            function i(l, c, y) {
              let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
              if (!t) {
                t = true;
                let p = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                if (Nt.emitWarning)
                  Nt.emitWarning(p, "DeprecationWarning");
                else {
                  let D = new Error(p);
                  D.name = "DeprecationWarning", console.warn(new Error(p));
                }
              }
              return y = Math.max(y, 0), u(l, { start: { column: y, line: c } }, h);
            }
          } }), Un = ee({ "src/main/parser.js"(e, n) {
            "use strict";
            re();
            var { ConfigError: t } = Kt(), s = it(), a = pm(), { locStart: r, locEnd: u } = s, i = Object.getOwnPropertyNames, l = Object.getOwnPropertyDescriptor;
            function c(g) {
              let p = {};
              for (let D of g.plugins)
                if (D.parsers)
                  for (let v of i(D.parsers))
                    Object.defineProperty(p, v, l(D.parsers, v));
              return p;
            }
            function y(g) {
              let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c(g);
              if (typeof g.parser == "function")
                return { parse: g.parser, astFormat: "estree", locStart: r, locEnd: u };
              if (typeof g.parser == "string") {
                if (Object.prototype.hasOwnProperty.call(p, g.parser))
                  return p[g.parser];
                throw new t(`Couldn't resolve parser "${g.parser}". Parsers must be explicitly added to the standalone bundle.`);
              }
            }
            function h(g, p) {
              let D = c(p), v = Object.defineProperties({}, Object.fromEntries(Object.keys(D).map((T) => [T, { enumerable: true, get() {
                return D[T].parse;
              } }]))), w = y(p, D);
              try {
                return w.preprocess && (g = w.preprocess(g, p)), { text: g, ast: w.parse(g, v, p) };
              } catch (T) {
                let { loc: F } = T;
                if (F) {
                  let { codeFrameColumns: A3 } = Dm();
                  throw T.codeFrame = A3(g, F, { highlightCode: true }), T.message += `
` + T.codeFrame, T;
                }
                throw T;
              }
            }
            n.exports = { parse: h, resolveParser: y };
          } }), Oa = ee({ "src/main/options.js"(e, n) {
            "use strict";
            re();
            var t = TD(), { UndefinedParserError: s } = Kt(), { getSupportInfo: a } = Rn(), r = cm(), { resolveParser: u } = Un(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
            function l(h) {
              let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = Object.assign({}, h), D = a({ plugins: h.plugins, showUnreleased: true, showDeprecated: true }).options, v = Object.assign(Object.assign({}, i), Object.fromEntries(D.filter((B) => B.default !== void 0).map((B) => [B.name, B.default])));
              if (!p.parser) {
                if (!p.filepath)
                  (g.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), p.parser = "babel";
                else if (p.parser = y(p.filepath, p.plugins), !p.parser)
                  throw new s(`No parser could be inferred for file: ${p.filepath}`);
              }
              let w = u(r.normalizeApiOptions(p, [D.find((B) => B.name === "parser")], { passThrough: true, logger: false }));
              p.astFormat = w.astFormat, p.locEnd = w.locEnd, p.locStart = w.locStart;
              let T = c(p);
              p.printer = T.printers[p.astFormat];
              let F = Object.fromEntries(D.filter((B) => B.pluginDefaults && B.pluginDefaults[T.name] !== void 0).map((B) => [B.name, B.pluginDefaults[T.name]])), A3 = Object.assign(Object.assign({}, v), F);
              for (let [B, I] of Object.entries(A3))
                (p[B] === null || p[B] === void 0) && (p[B] = I);
              return p.parser === "json" && (p.trailingComma = "none"), r.normalizeApiOptions(p, D, Object.assign({ passThrough: Object.keys(i) }, g));
            }
            function c(h) {
              let { astFormat: g } = h;
              if (!g)
                throw new Error("getPlugin() requires astFormat to be set");
              let p = h.plugins.find((D) => D.printers && D.printers[g]);
              if (!p)
                throw new Error(`Couldn't find plugin for AST format "${g}"`);
              return p;
            }
            function y(h, g) {
              let p = t.basename(h).toLowerCase(), v = a({ plugins: g }).languages.filter((w) => w.since !== null).find((w) => w.extensions && w.extensions.some((T) => p.endsWith(T)) || w.filenames && w.filenames.some((T) => T.toLowerCase() === p));
              return v && v.parsers[0];
            }
            n.exports = { normalize: l, hiddenDefaults: i, inferParser: y };
          } }), mm = ee({ "src/main/massage-ast.js"(e, n) {
            "use strict";
            re();
            function t(s, a, r) {
              if (Array.isArray(s))
                return s.map((c) => t(c, a, r)).filter(Boolean);
              if (!s || typeof s != "object")
                return s;
              let u = a.printer.massageAstNode, i;
              u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
              let l = {};
              for (let [c, y] of Object.entries(s))
                !i.has(c) && typeof y != "function" && (l[c] = t(y, a, s));
              if (u) {
                let c = u(s, l, r);
                if (c === null)
                  return;
                if (c)
                  return c;
              }
              return l;
            }
            n.exports = t;
          } }), Yt = ee({ "scripts/build/shims/assert.cjs"(e, n) {
            "use strict";
            re();
            var t = () => {
            };
            t.ok = t, t.strictEqual = t, n.exports = t;
          } }), et = ee({ "src/main/comments.js"(e, n) {
            "use strict";
            re();
            var t = Yt(), { builders: { line: s, hardline: a, breakParent: r, indent: u, lineSuffix: i, join: l, cursor: c } } = qe(), { hasNewline: y, skipNewline: h, skipSpaces: g, isPreviousLineEmpty: p, addLeadingComment: D, addDanglingComment: v, addTrailingComment: w } = Ge(), T = /* @__PURE__ */ new WeakMap();
            function F(k, $, M) {
              if (!k)
                return;
              let { printer: q, locStart: J, locEnd: L } = $;
              if (M) {
                if (q.canAttachComment && q.canAttachComment(k)) {
                  let V;
                  for (V = M.length - 1; V >= 0 && !(J(M[V]) <= J(k) && L(M[V]) <= L(k)); --V)
                    ;
                  M.splice(V + 1, 0, k);
                  return;
                }
              } else if (T.has(k))
                return T.get(k);
              let Y = q.getCommentChildNodes && q.getCommentChildNodes(k, $) || typeof k == "object" && Object.entries(k).filter((V) => {
                let [O] = V;
                return O !== "enclosingNode" && O !== "precedingNode" && O !== "followingNode" && O !== "tokens" && O !== "comments" && O !== "parent";
              }).map((V) => {
                let [, O] = V;
                return O;
              });
              if (Y) {
                M || (M = [], T.set(k, M));
                for (let V of Y)
                  F(V, $, M);
                return M;
              }
            }
            function A3(k, $, M, q) {
              let { locStart: J, locEnd: L } = M, Y = J($), V = L($), O = F(k, M), K, se, Q = 0, le = O.length;
              for (; Q < le; ) {
                let W = Q + le >> 1, X = O[W], oe = J(X), ae = L(X);
                if (oe <= Y && V <= ae)
                  return A3(X, $, M, X);
                if (ae <= Y) {
                  K = X, Q = W + 1;
                  continue;
                }
                if (V <= oe) {
                  se = X, le = W;
                  continue;
                }
                throw new Error("Comment location overlaps with node location");
              }
              if (q && q.type === "TemplateLiteral") {
                let { quasis: W } = q, X = E(W, $, M);
                K && E(W, K, M) !== X && (K = null), se && E(W, se, M) !== X && (se = null);
              }
              return { enclosingNode: q, precedingNode: K, followingNode: se };
            }
            var B = () => false;
            function I(k, $, M, q) {
              if (!Array.isArray(k))
                return;
              let J = [], { locStart: L, locEnd: Y, printer: { handleComments: V = {} } } = q, { avoidAstMutation: O, ownLine: K = B, endOfLine: se = B, remaining: Q = B } = V, le = k.map((W, X) => Object.assign(Object.assign({}, A3($, W, q)), {}, { comment: W, text: M, options: q, ast: $, isLastComment: k.length - 1 === X }));
              for (let [W, X] of le.entries()) {
                let { comment: oe, precedingNode: ae, enclosingNode: Ae, followingNode: z, text: H, options: Z, ast: ne, isLastComment: fe } = X;
                if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
                  if (L(oe) - L(ne) <= 0) {
                    D(ne, oe);
                    continue;
                  }
                  if (Y(oe) - Y(ne) >= 0) {
                    w(ne, oe);
                    continue;
                  }
                }
                let ge;
                if (O ? ge = [X] : (oe.enclosingNode = Ae, oe.precedingNode = ae, oe.followingNode = z, ge = [oe, H, Z, ne, fe]), R(H, Z, le, W))
                  oe.placement = "ownLine", K(...ge) || (z ? D(z, oe) : ae ? w(ae, oe) : v(Ae || ne, oe));
                else if (f(H, Z, le, W))
                  oe.placement = "endOfLine", se(...ge) || (ae ? w(ae, oe) : z ? D(z, oe) : v(Ae || ne, oe));
                else if (oe.placement = "remaining", !Q(...ge))
                  if (ae && z) {
                    let Ce = J.length;
                    Ce > 0 && J[Ce - 1].followingNode !== z && x(J, H, Z), J.push(X);
                  } else
                    ae ? w(ae, oe) : z ? D(z, oe) : v(Ae || ne, oe);
              }
              if (x(J, M, q), !O)
                for (let W of k)
                  delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
            }
            var P2 = (k) => !/[\S\n\u2028\u2029]/.test(k);
            function R(k, $, M, q) {
              let { comment: J, precedingNode: L } = M[q], { locStart: Y, locEnd: V } = $, O = Y(J);
              if (L)
                for (let K = q - 1; K >= 0; K--) {
                  let { comment: se, precedingNode: Q } = M[K];
                  if (Q !== L || !P2(k.slice(V(se), O)))
                    break;
                  O = Y(se);
                }
              return y(k, O, { backwards: true });
            }
            function f(k, $, M, q) {
              let { comment: J, followingNode: L } = M[q], { locStart: Y, locEnd: V } = $, O = V(J);
              if (L)
                for (let K = q + 1; K < M.length; K++) {
                  let { comment: se, followingNode: Q } = M[K];
                  if (Q !== L || !P2(k.slice(O, Y(se))))
                    break;
                  O = V(se);
                }
              return y(k, O);
            }
            function x(k, $, M) {
              let q = k.length;
              if (q === 0)
                return;
              let { precedingNode: J, followingNode: L, enclosingNode: Y } = k[0], V = M.printer.getGapRegex && M.printer.getGapRegex(Y) || /^[\s(]*$/, O = M.locStart(L), K;
              for (K = q; K > 0; --K) {
                let { comment: se, precedingNode: Q, followingNode: le } = k[K - 1];
                t.strictEqual(Q, J), t.strictEqual(le, L);
                let W = $.slice(M.locEnd(se), O);
                if (V.test(W))
                  O = M.locStart(se);
                else
                  break;
              }
              for (let [se, { comment: Q }] of k.entries())
                se < K ? w(J, Q) : D(L, Q);
              for (let se of [J, L])
                se.comments && se.comments.length > 1 && se.comments.sort((Q, le) => M.locStart(Q) - M.locStart(le));
              k.length = 0;
            }
            function m(k, $) {
              let M = k.getValue();
              return M.printed = true, $.printer.printComment(k, $);
            }
            function E(k, $, M) {
              let q = M.locStart($) - 1;
              for (let J = 1; J < k.length; ++J)
                if (q < M.locStart(k[J]))
                  return J - 1;
              return 0;
            }
            function o(k, $) {
              let M = k.getValue(), q = [m(k, $)], { printer: J, originalText: L, locStart: Y, locEnd: V } = $;
              if (J.isBlockComment && J.isBlockComment(M)) {
                let se = y(L, V(M)) ? y(L, Y(M), { backwards: true }) ? a : s : " ";
                q.push(se);
              } else
                q.push(a);
              let K = h(L, g(L, V(M)));
              return K !== false && y(L, K) && q.push(a), q;
            }
            function d(k, $) {
              let M = k.getValue(), q = m(k, $), { printer: J, originalText: L, locStart: Y } = $, V = J.isBlockComment && J.isBlockComment(M);
              if (y(L, Y(M), { backwards: true })) {
                let K = p(L, M, Y);
                return i([a, K ? a : "", q]);
              }
              let O = [" ", q];
              return V || (O = [i(O), r]), O;
            }
            function C(k, $, M, q) {
              let J = [], L = k.getValue();
              return !L || !L.comments || (k.each(() => {
                let Y = k.getValue();
                !Y.leading && !Y.trailing && (!q || q(Y)) && J.push(m(k, $));
              }, "comments"), J.length === 0) ? "" : M ? l(a, J) : u([a, l(a, J)]);
            }
            function _(k, $, M) {
              let q = k.getValue();
              if (!q)
                return {};
              let J = q.comments || [];
              M && (J = J.filter((O) => !M.has(O)));
              let L = q === $.cursorNode;
              if (J.length === 0) {
                let O = L ? c : "";
                return { leading: O, trailing: O };
              }
              let Y = [], V = [];
              return k.each(() => {
                let O = k.getValue();
                if (M && M.has(O))
                  return;
                let { leading: K, trailing: se } = O;
                K ? Y.push(o(k, $)) : se && V.push(d(k, $));
              }, "comments"), L && (Y.unshift(c), V.push(c)), { leading: Y, trailing: V };
            }
            function b(k, $, M, q) {
              let { leading: J, trailing: L } = _(k, M, q);
              return !J && !L ? $ : [J, $, L];
            }
            function N(k) {
              if (k)
                for (let $ of k) {
                  if (!$.printed)
                    throw new Error('Comment "' + $.value.trim() + '" was not printed. Please report this error!');
                  delete $.printed;
                }
            }
            n.exports = { attach: I, printComments: b, printCommentsSeparately: _, printDanglingComments: C, getSortedChildNodes: F, ensureAllCommentsPrinted: N };
          } }), dm = ee({ "src/common/ast-path.js"(e, n) {
            "use strict";
            re();
            var t = lt();
            function s(u, i) {
              let l = a(u.stack, i);
              return l === -1 ? null : u.stack[l];
            }
            function a(u, i) {
              for (let l = u.length - 1; l >= 0; l -= 2) {
                let c = u[l];
                if (c && !Array.isArray(c) && --i < 0)
                  return l;
              }
              return -1;
            }
            var r = class {
              constructor(u) {
                this.stack = [u];
              }
              getName() {
                let { stack: u } = this, { length: i } = u;
                return i > 1 ? u[i - 2] : null;
              }
              getValue() {
                return t(this.stack);
              }
              getNode() {
                let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u);
              }
              getParentNode() {
                let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u + 1);
              }
              call(u) {
                let { stack: i } = this, { length: l } = i, c = t(i);
                for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++)
                  h[g - 1] = arguments[g];
                for (let D of h)
                  c = c[D], i.push(D, c);
                let p = u(this);
                return i.length = l, p;
              }
              callParent(u) {
                let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = a(this.stack, i + 1), c = this.stack.splice(l + 1), y = u(this);
                return this.stack.push(...c), y;
              }
              each(u) {
                let { stack: i } = this, { length: l } = i, c = t(i);
                for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++)
                  h[g - 1] = arguments[g];
                for (let p of h)
                  c = c[p], i.push(p, c);
                for (let p = 0; p < c.length; ++p)
                  i.push(p, c[p]), u(this, p, c), i.length -= 2;
                i.length = l;
              }
              map(u) {
                let i = [];
                for (var l = arguments.length, c = new Array(l > 1 ? l - 1 : 0), y = 1; y < l; y++)
                  c[y - 1] = arguments[y];
                return this.each((h, g, p) => {
                  i[g] = u(h, g, p);
                }, ...c), i;
              }
              try(u) {
                let { stack: i } = this, l = [...i];
                try {
                  return u();
                } finally {
                  i.length = 0, i.push(...l);
                }
              }
              match() {
                let u = this.stack.length - 1, i = null, l = this.stack[u--];
                for (var c = arguments.length, y = new Array(c), h = 0; h < c; h++)
                  y[h] = arguments[h];
                for (let g of y) {
                  if (l === void 0)
                    return false;
                  let p = null;
                  if (typeof i == "number" && (p = i, i = this.stack[u--], l = this.stack[u--]), g && !g(l, i, p))
                    return false;
                  i = this.stack[u--], l = this.stack[u--];
                }
                return true;
              }
              findAncestor(u) {
                let i = this.stack.length - 1, l = null, c = this.stack[i--];
                for (; c; ) {
                  let y = null;
                  if (typeof l == "number" && (y = l, l = this.stack[i--], c = this.stack[i--]), l !== null && u(c, l, y))
                    return c;
                  l = this.stack[i--], c = this.stack[i--];
                }
              }
            };
            n.exports = r;
          } }), gm = ee({ "src/main/multiparser.js"(e, n) {
            "use strict";
            re();
            var { utils: { stripTrailingHardline: t } } = qe(), { normalize: s } = Oa(), a = et();
            function r(i, l, c, y) {
              if (c.printer.embed && c.embeddedLanguageFormatting === "auto")
                return c.printer.embed(i, l, (h, g, p) => u(h, g, c, y, p), c);
            }
            function u(i, l, c, y) {
              let { stripTrailingHardline: h = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g = s(Object.assign(Object.assign(Object.assign({}, c), l), {}, { parentParser: c.parser, originalText: i }), { passThrough: true }), p = Un().parse(i, g), { ast: D } = p;
              i = p.text;
              let v = D.comments;
              delete D.comments, a.attach(v, D, i, g), g[Symbol.for("comments")] = v || [], g[Symbol.for("tokens")] = D.tokens || [];
              let w = y(D, g);
              return a.ensureAllCommentsPrinted(v), h ? typeof w == "string" ? w.replace(/(?:\r?\n)*$/, "") : t(w) : w;
            }
            n.exports = { printSubtree: r };
          } }), ym = ee({ "src/main/ast-to-doc.js"(e, n) {
            "use strict";
            re();
            var t = dm(), { builders: { hardline: s, addAlignmentToDoc: a }, utils: { propagateBreaks: r } } = qe(), { printComments: u } = et(), i = gm();
            function l(h, g) {
              let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: D } = g;
              D.preprocess && (h = D.preprocess(h, g));
              let v = /* @__PURE__ */ new Map(), w = new t(h), T = F();
              return p > 0 && (T = a([s, T], p, g.tabWidth)), r(T), T;
              function F(B, I) {
                return B === void 0 || B === w ? A3(I) : Array.isArray(B) ? w.call(() => A3(I), ...B) : w.call(() => A3(I), B);
              }
              function A3(B) {
                let I = w.getValue(), P2 = I && typeof I == "object" && B === void 0;
                if (P2 && v.has(I))
                  return v.get(I);
                let R = y(w, g, F, B);
                return P2 && v.set(I, R), R;
              }
            }
            function c(h, g) {
              let { originalText: p, [Symbol.for("comments")]: D, locStart: v, locEnd: w } = g, T = v(h), F = w(h), A3 = /* @__PURE__ */ new Set();
              for (let B of D)
                v(B) >= T && w(B) <= F && (B.printed = true, A3.add(B));
              return { doc: p.slice(T, F), printedComments: A3 };
            }
            function y(h, g, p, D) {
              let v = h.getValue(), { printer: w } = g, T, F;
              if (w.hasPrettierIgnore && w.hasPrettierIgnore(h))
                ({ doc: T, printedComments: F } = c(v, g));
              else {
                if (v)
                  try {
                    T = i.printSubtree(h, p, g, l);
                  } catch (A3) {
                    if (globalThis.PRETTIER_DEBUG)
                      throw A3;
                  }
                T || (T = w.print(h, g, p, D));
              }
              return (!w.willPrintOwnComments || !w.willPrintOwnComments(h, g)) && (T = u(h, T, g, F)), T;
            }
            n.exports = l;
          } }), hm = ee({ "src/main/range-util.js"(e, n) {
            "use strict";
            re();
            var t = Yt(), s = et(), a = (D) => {
              let { parser: v } = D;
              return v === "json" || v === "json5" || v === "json-stringify";
            };
            function r(D, v) {
              let w = [D.node, ...D.parentNodes], T = /* @__PURE__ */ new Set([v.node, ...v.parentNodes]);
              return w.find((F) => y.has(F.type) && T.has(F));
            }
            function u(D) {
              let v = D.length - 1;
              for (; ; ) {
                let w = D[v];
                if (w && (w.type === "Program" || w.type === "File"))
                  v--;
                else
                  break;
              }
              return D.slice(0, v + 1);
            }
            function i(D, v, w) {
              let { locStart: T, locEnd: F } = w, A3 = D.node, B = v.node;
              if (A3 === B)
                return { startNode: A3, endNode: B };
              let I = T(D.node);
              for (let R of u(v.parentNodes))
                if (T(R) >= I)
                  B = R;
                else
                  break;
              let P2 = F(v.node);
              for (let R of u(D.parentNodes)) {
                if (F(R) <= P2)
                  A3 = R;
                else
                  break;
                if (A3 === B)
                  break;
              }
              return { startNode: A3, endNode: B };
            }
            function l(D, v, w, T) {
              let F = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], A3 = arguments.length > 5 ? arguments[5] : void 0, { locStart: B, locEnd: I } = w, P2 = B(D), R = I(D);
              if (!(v > R || v < P2 || A3 === "rangeEnd" && v === P2 || A3 === "rangeStart" && v === R)) {
                for (let f of s.getSortedChildNodes(D, w)) {
                  let x = l(f, v, w, T, [D, ...F], A3);
                  if (x)
                    return x;
                }
                if (!T || T(D, F[0]))
                  return { node: D, parentNodes: F };
              }
            }
            function c(D, v) {
              return v !== "DeclareExportDeclaration" && D !== "TypeParameterDeclaration" && (D === "Directive" || D === "TypeAlias" || D === "TSExportAssignment" || D.startsWith("Declare") || D.startsWith("TSDeclare") || D.endsWith("Statement") || D.endsWith("Declaration"));
            }
            var y = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), h = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
            function g(D, v, w) {
              if (!v)
                return false;
              switch (D.parser) {
                case "flow":
                case "babel":
                case "babel-flow":
                case "babel-ts":
                case "typescript":
                case "acorn":
                case "espree":
                case "meriyah":
                case "__babel_estree":
                  return c(v.type, w && w.type);
                case "json":
                case "json5":
                case "json-stringify":
                  return y.has(v.type);
                case "graphql":
                  return h.has(v.kind);
                case "vue":
                  return v.tag !== "root";
              }
              return false;
            }
            function p(D, v, w) {
              let { rangeStart: T, rangeEnd: F, locStart: A3, locEnd: B } = v;
              t.ok(F > T);
              let I = D.slice(T, F).search(/\S/), P2 = I === -1;
              if (!P2)
                for (T += I; F > T && !/\S/.test(D[F - 1]); --F)
                  ;
              let R = l(w, T, v, (E, o) => g(v, E, o), [], "rangeStart"), f = P2 ? R : l(w, F, v, (E) => g(v, E), [], "rangeEnd");
              if (!R || !f)
                return { rangeStart: 0, rangeEnd: 0 };
              let x, m;
              if (a(v)) {
                let E = r(R, f);
                x = E, m = E;
              } else
                ({ startNode: x, endNode: m } = i(R, f, v));
              return { rangeStart: Math.min(A3(x), A3(m)), rangeEnd: Math.max(B(x), B(m)) };
            }
            n.exports = { calculateRange: p, findNodeAtOffset: l };
          } }), vm = ee({ "src/main/core.js"(e, n) {
            "use strict";
            re();
            var { diffArrays: t } = rD(), { printer: { printDocToString: s }, debug: { printDocToDebug: a } } = qe(), { getAlignmentSize: r } = Ge(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: l, normalizeEndOfLine: c } = qn(), y = Oa().normalize, h = mm(), g = et(), p = Un(), D = ym(), v = hm(), w = "\uFEFF", T = Symbol("cursor");
            function F(m, E, o) {
              let d = E.comments;
              return d && (delete E.comments, g.attach(d, E, m, o)), o[Symbol.for("comments")] = d || [], o[Symbol.for("tokens")] = E.tokens || [], o.originalText = m, d;
            }
            function A3(m, E) {
              let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
              if (!m || m.trim().length === 0)
                return { formatted: "", cursorOffset: -1, comments: [] };
              let { ast: d, text: C } = p.parse(m, E);
              if (E.cursorOffset >= 0) {
                let k = v.findNodeAtOffset(d, E.cursorOffset, E);
                k && k.node && (E.cursorNode = k.node);
              }
              let _ = F(C, d, E), b = D(d, E, o), N = s(b, E);
              if (g.ensureAllCommentsPrinted(_), o > 0) {
                let k = N.formatted.trim();
                N.cursorNodeStart !== void 0 && (N.cursorNodeStart -= N.formatted.indexOf(k)), N.formatted = k + i(E.endOfLine);
              }
              if (E.cursorOffset >= 0) {
                let k, $, M, q, J;
                if (E.cursorNode && N.cursorNodeText ? (k = E.locStart(E.cursorNode), $ = C.slice(k, E.locEnd(E.cursorNode)), M = E.cursorOffset - k, q = N.cursorNodeStart, J = N.cursorNodeText) : (k = 0, $ = C, M = E.cursorOffset, q = 0, J = N.formatted), $ === J)
                  return { formatted: N.formatted, cursorOffset: q + M, comments: _ };
                let L = [...$];
                L.splice(M, 0, T);
                let Y = [...J], V = t(L, Y), O = q;
                for (let K of V)
                  if (K.removed) {
                    if (K.value.includes(T))
                      break;
                  } else
                    O += K.count;
                return { formatted: N.formatted, cursorOffset: O, comments: _ };
              }
              return { formatted: N.formatted, cursorOffset: -1, comments: _ };
            }
            function B(m, E) {
              let { ast: o, text: d } = p.parse(m, E), { rangeStart: C, rangeEnd: _ } = v.calculateRange(d, E, o), b = d.slice(C, _), N = Math.min(C, d.lastIndexOf(`
`, C) + 1), k = d.slice(N, C).match(/^\s*/)[0], $ = r(k, E.tabWidth), M = A3(b, Object.assign(Object.assign({}, E), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: E.cursorOffset > C && E.cursorOffset <= _ ? E.cursorOffset - C : -1, endOfLine: "lf" }), $), q = M.formatted.trimEnd(), { cursorOffset: J } = E;
              J > _ ? J += q.length - b.length : M.cursorOffset >= 0 && (J = M.cursorOffset + C);
              let L = d.slice(0, C) + q + d.slice(_);
              if (E.endOfLine !== "lf") {
                let Y = i(E.endOfLine);
                J >= 0 && Y === `\r
` && (J += l(L.slice(0, J), `
`)), L = L.replace(/\n/g, Y);
              }
              return { formatted: L, cursorOffset: J, comments: M.comments };
            }
            function I(m, E, o) {
              return typeof E != "number" || Number.isNaN(E) || E < 0 || E > m.length ? o : E;
            }
            function P2(m, E) {
              let { cursorOffset: o, rangeStart: d, rangeEnd: C } = E;
              return o = I(m, o, -1), d = I(m, d, 0), C = I(m, C, m.length), Object.assign(Object.assign({}, E), {}, { cursorOffset: o, rangeStart: d, rangeEnd: C });
            }
            function R(m, E) {
              let { cursorOffset: o, rangeStart: d, rangeEnd: C, endOfLine: _ } = P2(m, E), b = m.charAt(0) === w;
              if (b && (m = m.slice(1), o--, d--, C--), _ === "auto" && (_ = u(m)), m.includes("\r")) {
                let N = (k) => l(m.slice(0, Math.max(k, 0)), `\r
`);
                o -= N(o), d -= N(d), C -= N(C), m = c(m);
              }
              return { hasBOM: b, text: m, options: P2(m, Object.assign(Object.assign({}, E), {}, { cursorOffset: o, rangeStart: d, rangeEnd: C, endOfLine: _ })) };
            }
            function f(m, E) {
              let o = p.resolveParser(E);
              return !o.hasPragma || o.hasPragma(m);
            }
            function x(m, E) {
              let { hasBOM: o, text: d, options: C } = R(m, y(E));
              if (C.rangeStart >= C.rangeEnd && d !== "" || C.requirePragma && !f(d, C))
                return { formatted: m, cursorOffset: E.cursorOffset, comments: [] };
              let _;
              return C.rangeStart > 0 || C.rangeEnd < d.length ? _ = B(d, C) : (!C.requirePragma && C.insertPragma && C.printer.insertPragma && !f(d, C) && (d = C.printer.insertPragma(d)), _ = A3(d, C)), o && (_.formatted = w + _.formatted, _.cursorOffset >= 0 && _.cursorOffset++), _;
            }
            n.exports = { formatWithCursor: x, parse(m, E, o) {
              let { text: d, options: C } = R(m, y(E)), _ = p.parse(d, C);
              return o && (_.ast = h(_.ast, C)), _;
            }, formatAST(m, E) {
              E = y(E);
              let o = D(m, E);
              return s(o, E);
            }, formatDoc(m, E) {
              return x(a(m), Object.assign(Object.assign({}, E), {}, { parser: "__js_expression" })).formatted;
            }, printToDoc(m, E) {
              E = y(E);
              let { ast: o, text: d } = p.parse(m, E);
              return F(d, o, E), D(o, E);
            }, printDocToString(m, E) {
              return s(m, y(E));
            } };
          } }), Cm = ee({ "src/common/util-shared.js"(e, n) {
            "use strict";
            re();
            var { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: r, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: c, skipToLineEnd: y, skipEverythingButNewLine: h, skipInlineComment: g, skipTrailingComment: p, hasNewline: D, hasNewlineInRange: v, hasSpaces: w, isNextLineEmpty: T, isNextLineEmptyAfterIndex: F, isPreviousLineEmpty: A3, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I, addLeadingComment: P2, addDanglingComment: R, addTrailingComment: f } = Ge();
            n.exports = { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: r, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: c, skipToLineEnd: y, skipEverythingButNewLine: h, skipInlineComment: g, skipTrailingComment: p, hasNewline: D, hasNewlineInRange: v, hasSpaces: w, isNextLineEmpty: T, isNextLineEmptyAfterIndex: F, isPreviousLineEmpty: A3, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I, addLeadingComment: P2, addDanglingComment: R, addTrailingComment: f };
          } }), wt = ee({ "src/utils/create-language.js"(e, n) {
            "use strict";
            re(), n.exports = function(t, s) {
              let { languageId: a } = t, r = Ln(t, zf);
              return Object.assign(Object.assign({ linguistLanguageId: a }, r), s(t));
            };
          } }), Em = ee({ "node_modules/esutils/lib/ast.js"(e, n) {
            re(), function() {
              "use strict";
              function t(l) {
                if (l == null)
                  return false;
                switch (l.type) {
                  case "ArrayExpression":
                  case "AssignmentExpression":
                  case "BinaryExpression":
                  case "CallExpression":
                  case "ConditionalExpression":
                  case "FunctionExpression":
                  case "Identifier":
                  case "Literal":
                  case "LogicalExpression":
                  case "MemberExpression":
                  case "NewExpression":
                  case "ObjectExpression":
                  case "SequenceExpression":
                  case "ThisExpression":
                  case "UnaryExpression":
                  case "UpdateExpression":
                    return true;
                }
                return false;
              }
              function s(l) {
                if (l == null)
                  return false;
                switch (l.type) {
                  case "DoWhileStatement":
                  case "ForInStatement":
                  case "ForStatement":
                  case "WhileStatement":
                    return true;
                }
                return false;
              }
              function a(l) {
                if (l == null)
                  return false;
                switch (l.type) {
                  case "BlockStatement":
                  case "BreakStatement":
                  case "ContinueStatement":
                  case "DebuggerStatement":
                  case "DoWhileStatement":
                  case "EmptyStatement":
                  case "ExpressionStatement":
                  case "ForInStatement":
                  case "ForStatement":
                  case "IfStatement":
                  case "LabeledStatement":
                  case "ReturnStatement":
                  case "SwitchStatement":
                  case "ThrowStatement":
                  case "TryStatement":
                  case "VariableDeclaration":
                  case "WhileStatement":
                  case "WithStatement":
                    return true;
                }
                return false;
              }
              function r(l) {
                return a(l) || l != null && l.type === "FunctionDeclaration";
              }
              function u(l) {
                switch (l.type) {
                  case "IfStatement":
                    return l.alternate != null ? l.alternate : l.consequent;
                  case "LabeledStatement":
                  case "ForStatement":
                  case "ForInStatement":
                  case "WhileStatement":
                  case "WithStatement":
                    return l.body;
                }
                return null;
              }
              function i(l) {
                var c;
                if (l.type !== "IfStatement" || l.alternate == null)
                  return false;
                c = l.consequent;
                do {
                  if (c.type === "IfStatement" && c.alternate == null)
                    return true;
                  c = u(c);
                } while (c);
                return false;
              }
              n.exports = { isExpression: t, isStatement: a, isIterationStatement: s, isSourceElement: r, isProblematicIfStatement: i, trailingStatement: u };
            }();
          } }), qa = ee({ "node_modules/esutils/lib/code.js"(e, n) {
            re(), function() {
              "use strict";
              var t, s, a, r, u, i;
              s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
              function l(F) {
                return 48 <= F && F <= 57;
              }
              function c(F) {
                return 48 <= F && F <= 57 || 97 <= F && F <= 102 || 65 <= F && F <= 70;
              }
              function y(F) {
                return F >= 48 && F <= 55;
              }
              a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
              function h(F) {
                return F === 32 || F === 9 || F === 11 || F === 12 || F === 160 || F >= 5760 && a.indexOf(F) >= 0;
              }
              function g(F) {
                return F === 10 || F === 13 || F === 8232 || F === 8233;
              }
              function p(F) {
                if (F <= 65535)
                  return String.fromCharCode(F);
                var A3 = String.fromCharCode(Math.floor((F - 65536) / 1024) + 55296), B = String.fromCharCode((F - 65536) % 1024 + 56320);
                return A3 + B;
              }
              for (r = new Array(128), i = 0; i < 128; ++i)
                r[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
              for (u = new Array(128), i = 0; i < 128; ++i)
                u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
              function D(F) {
                return F < 128 ? r[F] : s.NonAsciiIdentifierStart.test(p(F));
              }
              function v(F) {
                return F < 128 ? u[F] : s.NonAsciiIdentifierPart.test(p(F));
              }
              function w(F) {
                return F < 128 ? r[F] : t.NonAsciiIdentifierStart.test(p(F));
              }
              function T(F) {
                return F < 128 ? u[F] : t.NonAsciiIdentifierPart.test(p(F));
              }
              n.exports = { isDecimalDigit: l, isHexDigit: c, isOctalDigit: y, isWhiteSpace: h, isLineTerminator: g, isIdentifierStartES5: D, isIdentifierPartES5: v, isIdentifierStartES6: w, isIdentifierPartES6: T };
            }();
          } }), Fm = ee({ "node_modules/esutils/lib/keyword.js"(e, n) {
            re(), function() {
              "use strict";
              var t = qa();
              function s(D) {
                switch (D) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "let":
                    return true;
                  default:
                    return false;
                }
              }
              function a(D, v) {
                return !v && D === "yield" ? false : r(D, v);
              }
              function r(D, v) {
                if (v && s(D))
                  return true;
                switch (D.length) {
                  case 2:
                    return D === "if" || D === "in" || D === "do";
                  case 3:
                    return D === "var" || D === "for" || D === "new" || D === "try";
                  case 4:
                    return D === "this" || D === "else" || D === "case" || D === "void" || D === "with" || D === "enum";
                  case 5:
                    return D === "while" || D === "break" || D === "catch" || D === "throw" || D === "const" || D === "yield" || D === "class" || D === "super";
                  case 6:
                    return D === "return" || D === "typeof" || D === "delete" || D === "switch" || D === "export" || D === "import";
                  case 7:
                    return D === "default" || D === "finally" || D === "extends";
                  case 8:
                    return D === "function" || D === "continue" || D === "debugger";
                  case 10:
                    return D === "instanceof";
                  default:
                    return false;
                }
              }
              function u(D, v) {
                return D === "null" || D === "true" || D === "false" || a(D, v);
              }
              function i(D, v) {
                return D === "null" || D === "true" || D === "false" || r(D, v);
              }
              function l(D) {
                return D === "eval" || D === "arguments";
              }
              function c(D) {
                var v, w, T;
                if (D.length === 0 || (T = D.charCodeAt(0), !t.isIdentifierStartES5(T)))
                  return false;
                for (v = 1, w = D.length; v < w; ++v)
                  if (T = D.charCodeAt(v), !t.isIdentifierPartES5(T))
                    return false;
                return true;
              }
              function y(D, v) {
                return (D - 55296) * 1024 + (v - 56320) + 65536;
              }
              function h(D) {
                var v, w, T, F, A3;
                if (D.length === 0)
                  return false;
                for (A3 = t.isIdentifierStartES6, v = 0, w = D.length; v < w; ++v) {
                  if (T = D.charCodeAt(v), 55296 <= T && T <= 56319) {
                    if (++v, v >= w || (F = D.charCodeAt(v), !(56320 <= F && F <= 57343)))
                      return false;
                    T = y(T, F);
                  }
                  if (!A3(T))
                    return false;
                  A3 = t.isIdentifierPartES6;
                }
                return true;
              }
              function g(D, v) {
                return c(D) && !u(D, v);
              }
              function p(D, v) {
                return h(D) && !i(D, v);
              }
              n.exports = { isKeywordES5: a, isKeywordES6: r, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: l, isIdentifierNameES5: c, isIdentifierNameES6: h, isIdentifierES5: g, isIdentifierES6: p };
            }();
          } }), Am = ee({ "node_modules/esutils/lib/utils.js"(e) {
            re(), function() {
              "use strict";
              e.ast = Em(), e.code = qa(), e.keyword = Fm();
            }();
          } }), Lt = ee({ "src/language-js/utils/is-block-comment.js"(e, n) {
            "use strict";
            re();
            var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s = (a) => t.has(a == null ? void 0 : a.type);
            n.exports = s;
          } }), Sm = ee({ "src/language-js/utils/is-node-matches.js"(e, n) {
            "use strict";
            re();
            function t(a, r) {
              let u = r.split(".");
              for (let i = u.length - 1; i >= 0; i--) {
                let l = u[i];
                if (i === 0)
                  return a.type === "Identifier" && a.name === l;
                if (a.type !== "MemberExpression" || a.optional || a.computed || a.property.type !== "Identifier" || a.property.name !== l)
                  return false;
                a = a.object;
              }
            }
            function s(a, r) {
              return r.some((u) => t(a, u));
            }
            n.exports = s;
          } }), Ke = ee({ "src/language-js/utils/index.js"(e, n) {
            "use strict";
            re();
            var t = Am().keyword.isIdentifierNameES5, { getLast: s, hasNewline: a, skipWhitespace: r, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: l } = Ge(), { locStart: c, locEnd: y, hasSameLocStart: h } = it(), g = Lt(), p = Sm(), D = "(?:(?=.)\\s)", v = new RegExp(`^${D}*:`), w = new RegExp(`^${D}*::`);
            function T(j) {
              var me, Ie;
              return ((me = j.extra) === null || me === void 0 ? void 0 : me.parenthesized) && g((Ie = j.trailingComments) === null || Ie === void 0 ? void 0 : Ie[0]) && v.test(j.trailingComments[0].value);
            }
            function F(j) {
              let me = j == null ? void 0 : j[0];
              return g(me) && w.test(me.value);
            }
            function A3(j, me) {
              if (!j || typeof j != "object")
                return false;
              if (Array.isArray(j))
                return j.some((je) => A3(je, me));
              let Ie = me(j);
              return typeof Ie == "boolean" ? Ie : Object.values(j).some((je) => A3(je, me));
            }
            function B(j) {
              return j.type === "AssignmentExpression" || j.type === "BinaryExpression" || j.type === "LogicalExpression" || j.type === "NGPipeExpression" || j.type === "ConditionalExpression" || oe(j) || ae(j) || j.type === "SequenceExpression" || j.type === "TaggedTemplateExpression" || j.type === "BindExpression" || j.type === "UpdateExpression" && !j.prefix || nt(j) || j.type === "TSNonNullExpression";
            }
            function I(j) {
              var me, Ie, je, Ye, ut, ze;
              return j.expressions ? j.expressions[0] : (me = (Ie = (je = (Ye = (ut = (ze = j.left) !== null && ze !== void 0 ? ze : j.test) !== null && ut !== void 0 ? ut : j.callee) !== null && Ye !== void 0 ? Ye : j.object) !== null && je !== void 0 ? je : j.tag) !== null && Ie !== void 0 ? Ie : j.argument) !== null && me !== void 0 ? me : j.expression;
            }
            function P2(j, me) {
              if (me.expressions)
                return ["expressions", 0];
              if (me.left)
                return ["left"];
              if (me.test)
                return ["test"];
              if (me.object)
                return ["object"];
              if (me.callee)
                return ["callee"];
              if (me.tag)
                return ["tag"];
              if (me.argument)
                return ["argument"];
              if (me.expression)
                return ["expression"];
              throw new Error("Unexpected node has no left side.");
            }
            function R(j) {
              return j = new Set(j), (me) => j.has(me == null ? void 0 : me.type);
            }
            var f = R(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), x = R(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
            function m(j) {
              let me = j.getParentNode();
              return j.getName() === "declaration" && x(me) ? me : null;
            }
            var E = R(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
            function o(j) {
              return j.type === "NumericLiteral" || j.type === "Literal" && typeof j.value == "number";
            }
            function d(j) {
              return j.type === "UnaryExpression" && (j.operator === "+" || j.operator === "-") && o(j.argument);
            }
            function C(j) {
              return j.type === "StringLiteral" || j.type === "Literal" && typeof j.value == "string";
            }
            var _ = R(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b = R(["FunctionExpression", "ArrowFunctionExpression"]);
            function N(j) {
              return j.type === "FunctionExpression" || j.type === "ArrowFunctionExpression" && j.body.type === "BlockStatement";
            }
            function k(j) {
              return oe(j) && j.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(j.callee.name);
            }
            var $ = R(["JSXElement", "JSXFragment"]);
            function M(j, me) {
              if (j.parentParser !== "markdown" && j.parentParser !== "mdx")
                return false;
              let Ie = me.getNode();
              if (!Ie.expression || !$(Ie.expression))
                return false;
              let je = me.getParentNode();
              return je.type === "Program" && je.body.length === 1;
            }
            function q(j) {
              return j.kind === "get" || j.kind === "set";
            }
            function J(j) {
              return q(j) || h(j, j.value);
            }
            function L(j) {
              return (j.type === "ObjectTypeProperty" || j.type === "ObjectTypeInternalSlot") && j.value.type === "FunctionTypeAnnotation" && !j.static && !J(j);
            }
            function Y(j) {
              return (j.type === "TypeAnnotation" || j.type === "TSTypeAnnotation") && j.typeAnnotation.type === "FunctionTypeAnnotation" && !j.static && !h(j, j.typeAnnotation);
            }
            var V = R(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
            function O(j) {
              return ae(j) || j.type === "BindExpression" && Boolean(j.object);
            }
            var K = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
            function se(j) {
              return j ? !!((j.type === "GenericTypeAnnotation" || j.type === "TSTypeReference") && !j.typeParameters || K.has(j.type)) : false;
            }
            function Q(j) {
              let me = /^(?:before|after)(?:Each|All)$/;
              return j.callee.type === "Identifier" && me.test(j.callee.name) && j.arguments.length === 1;
            }
            var le = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
            function W(j) {
              return p(j, le);
            }
            function X(j, me) {
              if (j.type !== "CallExpression")
                return false;
              if (j.arguments.length === 1) {
                if (k(j) && me && X(me))
                  return b(j.arguments[0]);
                if (Q(j))
                  return k(j.arguments[0]);
              } else if ((j.arguments.length === 2 || j.arguments.length === 3) && (j.arguments[0].type === "TemplateLiteral" || C(j.arguments[0])) && W(j.callee))
                return j.arguments[2] && !o(j.arguments[2]) ? false : (j.arguments.length === 2 ? b(j.arguments[1]) : N(j.arguments[1]) && Fe(j.arguments[1]).length <= 1) || k(j.arguments[1]);
              return false;
            }
            var oe = R(["CallExpression", "OptionalCallExpression"]), ae = R(["MemberExpression", "OptionalMemberExpression"]);
            function Ae(j) {
              let me = "expressions";
              j.type === "TSTemplateLiteralType" && (me = "types");
              let Ie = j[me];
              return Ie.length === 0 ? false : Ie.every((je) => {
                if (ue(je))
                  return false;
                if (je.type === "Identifier" || je.type === "ThisExpression")
                  return true;
                if (ae(je)) {
                  let Ye = je;
                  for (; ae(Ye); )
                    if (Ye.property.type !== "Identifier" && Ye.property.type !== "Literal" && Ye.property.type !== "StringLiteral" && Ye.property.type !== "NumericLiteral" || (Ye = Ye.object, ue(Ye)))
                      return false;
                  return Ye.type === "Identifier" || Ye.type === "ThisExpression";
                }
                return false;
              });
            }
            function z(j, me) {
              return j === "+" || j === "-" ? j + me : me;
            }
            function H(j, me) {
              let Ie = c(me), je = r(j, y(me));
              return je !== false && j.slice(Ie, Ie + 2) === "/*" && j.slice(je, je + 2) === "*/";
            }
            function Z(j, me) {
              return $(me) ? Ve(me) : ue(me, ke.Leading, (Ie) => a(j, y(Ie)));
            }
            function ne(j, me) {
              return me.parser !== "json" && C(j.key) && ce(j.key).slice(1, -1) === j.key.value && (t(j.key.value) && !(me.parser === "babel-ts" && j.type === "ClassProperty" || me.parser === "typescript" && j.type === "PropertyDefinition") || fe(j.key.value) && String(Number(j.key.value)) === j.key.value && (me.parser === "babel" || me.parser === "acorn" || me.parser === "espree" || me.parser === "meriyah" || me.parser === "__babel_estree"));
            }
            function fe(j) {
              return /^(?:\d+|\d+\.\d+)$/.test(j);
            }
            function ge(j, me) {
              let Ie = /^[fx]?(?:describe|it|test)$/;
              return me.type === "TaggedTemplateExpression" && me.quasi === j && me.tag.type === "MemberExpression" && me.tag.property.type === "Identifier" && me.tag.property.name === "each" && (me.tag.object.type === "Identifier" && Ie.test(me.tag.object.name) || me.tag.object.type === "MemberExpression" && me.tag.object.property.type === "Identifier" && (me.tag.object.property.name === "only" || me.tag.object.property.name === "skip") && me.tag.object.object.type === "Identifier" && Ie.test(me.tag.object.object.name));
            }
            function Ce(j) {
              return j.quasis.some((me) => me.value.raw.includes(`
`));
            }
            function _e(j, me) {
              return (j.type === "TemplateLiteral" && Ce(j) || j.type === "TaggedTemplateExpression" && Ce(j.quasi)) && !a(me, c(j), { backwards: true });
            }
            function Oe(j) {
              if (!ue(j))
                return false;
              let me = s(st(j, ke.Dangling));
              return me && !g(me);
            }
            function pe(j) {
              if (j.length <= 1)
                return false;
              let me = 0;
              for (let Ie of j)
                if (b(Ie)) {
                  if (me += 1, me > 1)
                    return true;
                } else if (oe(Ie)) {
                  for (let je of Ie.arguments)
                    if (b(je))
                      return true;
                }
              return false;
            }
            function ie(j) {
              let me = j.getValue(), Ie = j.getParentNode();
              return oe(me) && oe(Ie) && Ie.callee === me && me.arguments.length > Ie.arguments.length && Ie.arguments.length > 0;
            }
            function ve(j, me) {
              if (me >= 2)
                return false;
              let Ie = (ze) => ve(ze, me + 1), je = j.type === "Literal" && "regex" in j && j.regex.pattern || j.type === "RegExpLiteral" && j.pattern;
              if (je && l(je) > 5)
                return false;
              if (j.type === "Literal" || j.type === "BigIntLiteral" || j.type === "DecimalLiteral" || j.type === "BooleanLiteral" || j.type === "NullLiteral" || j.type === "NumericLiteral" || j.type === "RegExpLiteral" || j.type === "StringLiteral" || j.type === "Identifier" || j.type === "ThisExpression" || j.type === "Super" || j.type === "PrivateName" || j.type === "PrivateIdentifier" || j.type === "ArgumentPlaceholder" || j.type === "Import")
                return true;
              if (j.type === "TemplateLiteral")
                return j.quasis.every((ze) => !ze.value.raw.includes(`
`)) && j.expressions.every(Ie);
              if (j.type === "ObjectExpression")
                return j.properties.every((ze) => !ze.computed && (ze.shorthand || ze.value && Ie(ze.value)));
              if (j.type === "ArrayExpression")
                return j.elements.every((ze) => ze === null || Ie(ze));
              if (He(j))
                return (j.type === "ImportExpression" || ve(j.callee, me)) && Je(j).every(Ie);
              if (ae(j))
                return ve(j.object, me) && ve(j.property, me);
              let Ye = { "!": true, "-": true, "+": true, "~": true };
              if (j.type === "UnaryExpression" && Ye[j.operator])
                return ve(j.argument, me);
              let ut = { "++": true, "--": true };
              return j.type === "UpdateExpression" && ut[j.operator] ? ve(j.argument, me) : j.type === "TSNonNullExpression" ? ve(j.expression, me) : false;
            }
            function ce(j) {
              var me, Ie;
              return (me = (Ie = j.extra) === null || Ie === void 0 ? void 0 : Ie.raw) !== null && me !== void 0 ? me : j.raw;
            }
            function U(j) {
              return j;
            }
            function de(j) {
              return j.filepath && /\.tsx$/i.test(j.filepath);
            }
            function De(j) {
              let me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
              return j.trailingComma === "es5" && me === "es5" || j.trailingComma === "all" && (me === "all" || me === "es5");
            }
            function he(j, me) {
              switch (j = Ee(j), j.type) {
                case "FunctionExpression":
                case "ClassExpression":
                case "DoExpression":
                  return me;
                case "ObjectExpression":
                  return true;
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return he(j.object, me);
                case "TaggedTemplateExpression":
                  return j.tag.type === "FunctionExpression" ? false : he(j.tag, me);
                case "CallExpression":
                case "OptionalCallExpression":
                  return j.callee.type === "FunctionExpression" ? false : he(j.callee, me);
                case "ConditionalExpression":
                  return he(j.test, me);
                case "UpdateExpression":
                  return !j.prefix && he(j.argument, me);
                case "BindExpression":
                  return j.object && he(j.object, me);
                case "SequenceExpression":
                  return he(j.expressions[0], me);
                case "TSSatisfiesExpression":
                case "TSAsExpression":
                case "TSNonNullExpression":
                  return he(j.expression, me);
                default:
                  return false;
              }
            }
            var Be = { "==": true, "!=": true, "===": true, "!==": true }, Se = { "*": true, "/": true, "%": true }, ye = { ">>": true, ">>>": true, "<<": true };
            function S(j, me) {
              return !(te(me) !== te(j) || j === "**" || Be[j] && Be[me] || me === "%" && Se[j] || j === "%" && Se[me] || me !== j && Se[me] && Se[j] || ye[j] && ye[me]);
            }
            var G = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((j, me) => j.map((Ie) => [Ie, me])));
            function te(j) {
              return G.get(j);
            }
            function Ee(j) {
              for (; j.left; )
                j = j.left;
              return j;
            }
            function Re(j) {
              return Boolean(ye[j]) || j === "|" || j === "^" || j === "&";
            }
            function Te(j) {
              var me;
              if (j.rest)
                return true;
              let Ie = Fe(j);
              return ((me = s(Ie)) === null || me === void 0 ? void 0 : me.type) === "RestElement";
            }
            var Pe = /* @__PURE__ */ new WeakMap();
            function Fe(j) {
              if (Pe.has(j))
                return Pe.get(j);
              let me = [];
              return j.this && me.push(j.this), Array.isArray(j.parameters) ? me.push(...j.parameters) : Array.isArray(j.params) && me.push(...j.params), j.rest && me.push(j.rest), Pe.set(j, me), me;
            }
            function Ze(j, me) {
              let Ie = j.getValue(), je = 0, Ye = (ut) => me(ut, je++);
              Ie.this && j.call(Ye, "this"), Array.isArray(Ie.parameters) ? j.each(Ye, "parameters") : Array.isArray(Ie.params) && j.each(Ye, "params"), Ie.rest && j.call(Ye, "rest");
            }
            var xe = /* @__PURE__ */ new WeakMap();
            function Je(j) {
              if (xe.has(j))
                return xe.get(j);
              let me = j.arguments;
              return j.type === "ImportExpression" && (me = [j.source], j.attributes && me.push(j.attributes)), xe.set(j, me), me;
            }
            function we(j, me) {
              let Ie = j.getValue();
              Ie.type === "ImportExpression" ? (j.call((je) => me(je, 0), "source"), Ie.attributes && j.call((je) => me(je, 1), "attributes")) : j.each(me, "arguments");
            }
            function Le(j) {
              return j.value.trim() === "prettier-ignore" && !j.unignore;
            }
            function Ve(j) {
              return j && (j.prettierIgnore || ue(j, ke.PrettierIgnore));
            }
            function be(j) {
              let me = j.getValue();
              return Ve(me);
            }
            var ke = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, Me = (j, me) => {
              if (typeof j == "function" && (me = j, j = 0), j || me)
                return (Ie, je, Ye) => !(j & ke.Leading && !Ie.leading || j & ke.Trailing && !Ie.trailing || j & ke.Dangling && (Ie.leading || Ie.trailing) || j & ke.Block && !g(Ie) || j & ke.Line && !f(Ie) || j & ke.First && je !== 0 || j & ke.Last && je !== Ye.length - 1 || j & ke.PrettierIgnore && !Le(Ie) || me && !me(Ie));
            };
            function ue(j, me, Ie) {
              if (!u(j == null ? void 0 : j.comments))
                return false;
              let je = Me(me, Ie);
              return je ? j.comments.some(je) : true;
            }
            function st(j, me, Ie) {
              if (!Array.isArray(j == null ? void 0 : j.comments))
                return [];
              let je = Me(me, Ie);
              return je ? j.comments.filter(je) : j.comments;
            }
            var rt = (j, me) => {
              let { originalText: Ie } = me;
              return i(Ie, y(j));
            };
            function He(j) {
              return oe(j) || j.type === "NewExpression" || j.type === "ImportExpression";
            }
            function Ue(j) {
              return j && (j.type === "ObjectProperty" || j.type === "Property" && !j.method && j.kind === "init");
            }
            function Xe(j) {
              return Boolean(j.__isUsingHackPipeline);
            }
            var at = Symbol("ifWithoutBlockAndSameLineComment");
            function nt(j) {
              return j.type === "TSAsExpression" || j.type === "TSSatisfiesExpression";
            }
            n.exports = { getFunctionParameters: Fe, iterateFunctionParametersPath: Ze, getCallArguments: Je, iterateCallArgumentsPath: we, hasRestParameter: Te, getLeftSide: I, getLeftSidePathName: P2, getParentExportDeclaration: m, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: F, hasFlowShorthandAnnotationComment: T, hasLeadingOwnLineComment: Z, hasNakedLeftSide: B, hasNode: A3, hasIgnoreComment: be, hasNodeIgnoreComment: Ve, identity: U, isBinaryish: V, isCallLikeExpression: He, isEnabledHackPipeline: Xe, isLineComment: f, isPrettierIgnoreComment: Le, isCallExpression: oe, isMemberExpression: ae, isExportDeclaration: x, isFlowAnnotationComment: H, isFunctionCompositionArgs: pe, isFunctionNotation: J, isFunctionOrArrowExpression: b, isGetterOrSetter: q, isJestEachTemplateLiteral: ge, isJsxNode: $, isLiteral: E, isLongCurriedCallExpression: ie, isSimpleCallArgument: ve, isMemberish: O, isNumericLiteral: o, isSignedNumericLiteral: d, isObjectProperty: Ue, isObjectType: _, isObjectTypePropertyAFunction: L, isSimpleType: se, isSimpleNumber: fe, isSimpleTemplateLiteral: Ae, isStringLiteral: C, isStringPropSafeToUnquote: ne, isTemplateOnItsOwnLine: _e, isTestCall: X, isTheOnlyJsxElementInMarkdown: M, isTSXFile: de, isTypeAnnotationAFunction: Y, isNextLineEmpty: rt, needsHardlineAfterDanglingComment: Oe, rawText: ce, shouldPrintComma: De, isBitwiseOperator: Re, shouldFlatten: S, startsWithNoLookaheadToken: he, getPrecedence: te, hasComment: ue, getComments: st, CommentCheckFlags: ke, markerForIfWithoutBlockAndSameLineComment: at, isTSTypeExpression: nt };
          } }), jt = ee({ "src/language-js/print/template-literal.js"(e, n) {
            "use strict";
            re();
            var t = lt(), { getStringWidth: s, getIndentSize: a } = Ge(), { builders: { join: r, hardline: u, softline: i, group: l, indent: c, align: y, lineSuffixBoundary: h, addAlignmentToDoc: g }, printer: { printDocToString: p }, utils: { mapDoc: D } } = qe(), { isBinaryish: v, isJestEachTemplateLiteral: w, isSimpleTemplateLiteral: T, hasComment: F, isMemberExpression: A3, isTSTypeExpression: B } = Ke();
            function I(E, o, d) {
              let C = E.getValue();
              if (C.type === "TemplateLiteral" && w(C, E.getParentNode())) {
                let M = P2(E, d, o);
                if (M)
                  return M;
              }
              let b = "expressions";
              C.type === "TSTemplateLiteralType" && (b = "types");
              let N = [], k = E.map(o, b), $ = T(C);
              return $ && (k = k.map((M) => p(M, Object.assign(Object.assign({}, d), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), N.push(h, "`"), E.each((M) => {
                let q = M.getName();
                if (N.push(o()), q < k.length) {
                  let { tabWidth: J } = d, L = M.getValue(), Y = a(L.value.raw, J), V = k[q];
                  if (!$) {
                    let K = C[b][q];
                    (F(K) || A3(K) || K.type === "ConditionalExpression" || K.type === "SequenceExpression" || B(K) || v(K)) && (V = [c([i, V]), i]);
                  }
                  let O = Y === 0 && L.value.raw.endsWith(`
`) ? y(Number.NEGATIVE_INFINITY, V) : g(V, Y, J);
                  N.push(l(["${", O, h, "}"]));
                }
              }, "quasis"), N.push("`"), N;
            }
            function P2(E, o, d) {
              let C = E.getNode(), _ = C.quasis[0].value.raw.trim().split(/\s*\|\s*/);
              if (_.length > 1 || _.some((b) => b.length > 0)) {
                o.__inJestEach = true;
                let b = E.map(d, "expressions");
                o.__inJestEach = false;
                let N = [], k = b.map((L) => "${" + p(L, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), $ = [{ hasLineBreak: false, cells: [] }];
                for (let L = 1; L < C.quasis.length; L++) {
                  let Y = t($), V = k[L - 1];
                  Y.cells.push(V), V.includes(`
`) && (Y.hasLineBreak = true), C.quasis[L].value.raw.includes(`
`) && $.push({ hasLineBreak: false, cells: [] });
                }
                let M = Math.max(_.length, ...$.map((L) => L.cells.length)), q = Array.from({ length: M }).fill(0), J = [{ cells: _ }, ...$.filter((L) => L.cells.length > 0)];
                for (let { cells: L } of J.filter((Y) => !Y.hasLineBreak))
                  for (let [Y, V] of L.entries())
                    q[Y] = Math.max(q[Y], s(V));
                return N.push(h, "`", c([u, r(u, J.map((L) => r(" | ", L.cells.map((Y, V) => L.hasLineBreak ? Y : Y + " ".repeat(q[V] - s(Y))))))]), u, "`"), N;
              }
            }
            function R(E, o) {
              let d = E.getValue(), C = o();
              return F(d) && (C = l([c([i, C]), i])), ["${", C, h, "}"];
            }
            function f(E, o) {
              return E.map((d) => R(d, o), "expressions");
            }
            function x(E, o) {
              return D(E, (d) => typeof d == "string" ? o ? d.replace(/(\\*)`/g, "$1$1\\`") : m(d) : d);
            }
            function m(E) {
              return E.replace(/([\\`]|\${)/g, "\\$1");
            }
            n.exports = { printTemplateLiteral: I, printTemplateExpressions: f, escapeTemplateCharacters: x, uncookTemplateElementValue: m };
          } }), xm = ee({ "src/language-js/embed/markdown.js"(e, n) {
            "use strict";
            re();
            var { builders: { indent: t, softline: s, literalline: a, dedentToRoot: r } } = qe(), { escapeTemplateCharacters: u } = jt();
            function i(c, y, h) {
              let p = c.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (T, F) => "\\".repeat(F.length / 2) + "`"), D = l(p), v = D !== "";
              v && (p = p.replace(new RegExp(`^${D}`, "gm"), ""));
              let w = u(h(p, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
              return ["`", v ? t([s, w]) : [a, r(w)], s, "`"];
            }
            function l(c) {
              let y = c.match(/^([^\S\n]*)\S/m);
              return y === null ? "" : y[1];
            }
            n.exports = i;
          } }), bm = ee({ "src/language-js/embed/css.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t } = Ge(), { builders: { indent: s, hardline: a, softline: r }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: l } } = qe(), { printTemplateExpressions: c } = jt();
            function y(p, D, v) {
              let w = p.getValue(), T = w.quasis.map((P2) => P2.value.raw), F = 0, A3 = T.reduce((P2, R, f) => f === 0 ? R : P2 + "@prettier-placeholder-" + F++ + "-id" + R, ""), B = v(A3, { parser: "scss" }, { stripTrailingHardline: true }), I = c(p, D);
              return h(B, w, I);
            }
            function h(p, D, v) {
              if (D.quasis.length === 1 && !D.quasis[0].value.raw.trim())
                return "``";
              let T = g(p, v);
              if (!T)
                throw new Error("Couldn't insert all the expressions");
              return ["`", s([a, T]), r, "`"];
            }
            function g(p, D) {
              if (!t(D))
                return p;
              let v = 0, w = u(l(p), (T) => typeof T != "string" || !T.includes("@prettier-placeholder") ? T : T.split(/@prettier-placeholder-(\d+)-id/).map((F, A3) => A3 % 2 === 0 ? i(F) : (v++, D[F])));
              return D.length === v ? w : null;
            }
            n.exports = y;
          } }), Tm = ee({ "src/language-js/embed/graphql.js"(e, n) {
            "use strict";
            re();
            var { builders: { indent: t, join: s, hardline: a } } = qe(), { escapeTemplateCharacters: r, printTemplateExpressions: u } = jt();
            function i(c, y, h) {
              let g = c.getValue(), p = g.quasis.length;
              if (p === 1 && g.quasis[0].value.raw.trim() === "")
                return "``";
              let D = u(c, y), v = [];
              for (let w = 0; w < p; w++) {
                let T = g.quasis[w], F = w === 0, A3 = w === p - 1, B = T.value.cooked, I = B.split(`
`), P2 = I.length, R = D[w], f = P2 > 2 && I[0].trim() === "" && I[1].trim() === "", x = P2 > 2 && I[P2 - 1].trim() === "" && I[P2 - 2].trim() === "", m = I.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
                if (!A3 && /#[^\n\r]*$/.test(I[P2 - 1]))
                  return null;
                let E = null;
                m ? E = l(I) : E = h(B, { parser: "graphql" }, { stripTrailingHardline: true }), E ? (E = r(E, false), !F && f && v.push(""), v.push(E), !A3 && x && v.push("")) : !F && !A3 && f && v.push(""), R && v.push(R);
              }
              return ["`", t([a, s(a, v)]), a, "`"];
            }
            function l(c) {
              let y = [], h = false, g = c.map((p) => p.trim());
              for (let [p, D] of g.entries())
                D !== "" && (g[p - 1] === "" && h ? y.push([a, D]) : y.push(D), h = true);
              return y.length === 0 ? null : s(a, y);
            }
            n.exports = i;
          } }), Bm = ee({ "src/language-js/embed/html.js"(e, n) {
            "use strict";
            re();
            var { builders: { indent: t, line: s, hardline: a, group: r }, utils: { mapDoc: u } } = qe(), { printTemplateExpressions: i, uncookTemplateElementValue: l } = jt(), c = 0;
            function y(h, g, p, D, v) {
              let { parser: w } = v, T = h.getValue(), F = c;
              c = c + 1 >>> 0;
              let A3 = (d) => `PRETTIER_HTML_PLACEHOLDER_${d}_${F}_IN_JS`, B = T.quasis.map((d, C, _) => C === _.length - 1 ? d.value.cooked : d.value.cooked + A3(C)).join(""), I = i(h, g);
              if (I.length === 0 && B.trim().length === 0)
                return "``";
              let P2 = new RegExp(A3("(\\d+)"), "g"), R = 0, f = p(B, { parser: w, __onHtmlRoot(d) {
                R = d.children.length;
              } }, { stripTrailingHardline: true }), x = u(f, (d) => {
                if (typeof d != "string")
                  return d;
                let C = [], _ = d.split(P2);
                for (let b = 0; b < _.length; b++) {
                  let N = _[b];
                  if (b % 2 === 0) {
                    N && (N = l(N), D.__embeddedInHtml && (N = N.replace(/<\/(script)\b/gi, "<\\/$1")), C.push(N));
                    continue;
                  }
                  let k = Number(N);
                  C.push(I[k]);
                }
                return C;
              }), m = /^\s/.test(B) ? " " : "", E = /\s$/.test(B) ? " " : "", o = D.htmlWhitespaceSensitivity === "ignore" ? a : m && E ? s : null;
              return r(o ? ["`", t([o, r(x)]), o, "`"] : ["`", m, R > 1 ? t(r(x)) : r(x), E, "`"]);
            }
            n.exports = y;
          } }), Nm = ee({ "src/language-js/embed.js"(e, n) {
            "use strict";
            re();
            var { hasComment: t, CommentCheckFlags: s, isObjectProperty: a } = Ke(), r = xm(), u = bm(), i = Tm(), l = Bm();
            function c(f) {
              if (g(f) || w(f) || T(f) || p(f))
                return "css";
              if (B(f))
                return "graphql";
              if (P2(f))
                return "html";
              if (D(f))
                return "angular";
              if (h(f))
                return "markdown";
            }
            function y(f, x, m, E) {
              let o = f.getValue();
              if (o.type !== "TemplateLiteral" || R(o))
                return;
              let d = c(f);
              if (d) {
                if (d === "markdown")
                  return r(f, x, m);
                if (d === "css")
                  return u(f, x, m);
                if (d === "graphql")
                  return i(f, x, m);
                if (d === "html" || d === "angular")
                  return l(f, x, m, E, { parser: d });
              }
            }
            function h(f) {
              let x = f.getValue(), m = f.getParentNode();
              return m && m.type === "TaggedTemplateExpression" && x.quasis.length === 1 && m.tag.type === "Identifier" && (m.tag.name === "md" || m.tag.name === "markdown");
            }
            function g(f) {
              let x = f.getValue(), m = f.getParentNode(), E = f.getParentNode(1);
              return E && x.quasis && m.type === "JSXExpressionContainer" && E.type === "JSXElement" && E.openingElement.name.name === "style" && E.openingElement.attributes.some((o) => o.name.name === "jsx") || m && m.type === "TaggedTemplateExpression" && m.tag.type === "Identifier" && m.tag.name === "css" || m && m.type === "TaggedTemplateExpression" && m.tag.type === "MemberExpression" && m.tag.object.name === "css" && (m.tag.property.name === "global" || m.tag.property.name === "resolve");
            }
            function p(f) {
              return f.match((x) => x.type === "TemplateLiteral", (x, m) => x.type === "ArrayExpression" && m === "elements", (x, m) => a(x) && x.key.type === "Identifier" && x.key.name === "styles" && m === "value", ...v);
            }
            function D(f) {
              return f.match((x) => x.type === "TemplateLiteral", (x, m) => a(x) && x.key.type === "Identifier" && x.key.name === "template" && m === "value", ...v);
            }
            var v = [(f, x) => f.type === "ObjectExpression" && x === "properties", (f, x) => f.type === "CallExpression" && f.callee.type === "Identifier" && f.callee.name === "Component" && x === "arguments", (f, x) => f.type === "Decorator" && x === "expression"];
            function w(f) {
              let x = f.getParentNode();
              if (!x || x.type !== "TaggedTemplateExpression")
                return false;
              let m = x.tag.type === "ParenthesizedExpression" ? x.tag.expression : x.tag;
              switch (m.type) {
                case "MemberExpression":
                  return F(m.object) || A3(m);
                case "CallExpression":
                  return F(m.callee) || m.callee.type === "MemberExpression" && (m.callee.object.type === "MemberExpression" && (F(m.callee.object.object) || A3(m.callee.object)) || m.callee.object.type === "CallExpression" && F(m.callee.object.callee));
                case "Identifier":
                  return m.name === "css";
                default:
                  return false;
              }
            }
            function T(f) {
              let x = f.getParentNode(), m = f.getParentNode(1);
              return m && x.type === "JSXExpressionContainer" && m.type === "JSXAttribute" && m.name.type === "JSXIdentifier" && m.name.name === "css";
            }
            function F(f) {
              return f.type === "Identifier" && f.name === "styled";
            }
            function A3(f) {
              return /^[A-Z]/.test(f.object.name) && f.property.name === "extend";
            }
            function B(f) {
              let x = f.getValue(), m = f.getParentNode();
              return I(x, "GraphQL") || m && (m.type === "TaggedTemplateExpression" && (m.tag.type === "MemberExpression" && m.tag.object.name === "graphql" && m.tag.property.name === "experimental" || m.tag.type === "Identifier" && (m.tag.name === "gql" || m.tag.name === "graphql")) || m.type === "CallExpression" && m.callee.type === "Identifier" && m.callee.name === "graphql");
            }
            function I(f, x) {
              return t(f, s.Block | s.Leading, (m) => {
                let { value: E } = m;
                return E === ` ${x} `;
              });
            }
            function P2(f) {
              return I(f.getValue(), "HTML") || f.match((x) => x.type === "TemplateLiteral", (x, m) => x.type === "TaggedTemplateExpression" && x.tag.type === "Identifier" && x.tag.name === "html" && m === "quasi");
            }
            function R(f) {
              let { quasis: x } = f;
              return x.some((m) => {
                let { value: { cooked: E } } = m;
                return E === null;
              });
            }
            n.exports = y;
          } }), wm = ee({ "src/language-js/clean.js"(e, n) {
            "use strict";
            re();
            var t = Lt(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a = (u) => {
              for (let i of u.quasis)
                delete i.value;
            };
            function r(u, i, l) {
              if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
                return null;
              if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((h) => h.name.name === "jsx"))
                for (let { type: h, expression: g } of i.children)
                  h === "JSXExpressionContainer" && g.type === "TemplateLiteral" && a(g);
              u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
              let c = u.expression || u.callee;
              if (u.type === "Decorator" && c.type === "CallExpression" && c.callee.name === "Component" && c.arguments.length === 1) {
                let h = u.expression.arguments[0].properties;
                for (let [g, p] of i.expression.arguments[0].properties.entries())
                  switch (h[g].key.name) {
                    case "styles":
                      p.value.type === "ArrayExpression" && a(p.value.elements[0]);
                      break;
                    case "template":
                      p.value.type === "TemplateLiteral" && a(p.value);
                      break;
                  }
              }
              if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a(i.quasi), u.type === "TemplateLiteral") {
                var y;
                (((y = u.leadingComments) === null || y === void 0 ? void 0 : y.some((g) => t(g) && ["GraphQL", "HTML"].some((p) => g.value === ` ${p} `))) || l.type === "CallExpression" && l.callee.name === "graphql" || !u.leadingComments) && a(i);
              }
              if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
                return i.types[0];
            }
            r.ignoredProperties = s, n.exports = r;
          } }), Ma = {};
          zt(Ma, { EOL: () => kn, arch: () => _m, cpus: () => Ua, default: () => Ya, endianness: () => Ra, freemem: () => Ha, getNetworkInterfaces: () => Ka, hostname: () => $a, loadavg: () => Va, networkInterfaces: () => Xa, platform: () => Pm, release: () => za, tmpDir: () => Pn, tmpdir: () => In, totalmem: () => Ga, type: () => Ja, uptime: () => Wa });
          function Ra() {
            if (typeof br > "u") {
              var e = new ArrayBuffer(2), n = new Uint8Array(e), t = new Uint16Array(e);
              if (n[0] = 1, n[1] = 2, t[0] === 258)
                br = "BE";
              else if (t[0] === 513)
                br = "LE";
              else
                throw new Error("unable to figure out endianess");
            }
            return br;
          }
          function $a() {
            return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
          }
          function Va() {
            return [];
          }
          function Wa() {
            return 0;
          }
          function Ha() {
            return Number.MAX_VALUE;
          }
          function Ga() {
            return Number.MAX_VALUE;
          }
          function Ua() {
            return [];
          }
          function Ja() {
            return "Browser";
          }
          function za() {
            return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
          }
          function Xa() {
          }
          function Ka() {
          }
          function _m() {
            return "javascript";
          }
          function Pm() {
            return "browser";
          }
          function Pn() {
            return "/tmp";
          }
          var br, In, kn, Ya, Im = gt({ "node-modules-polyfills:os"() {
            re(), In = Pn, kn = `
`, Ya = { EOL: kn, tmpdir: In, tmpDir: Pn, networkInterfaces: Xa, getNetworkInterfaces: Ka, release: za, type: Ja, cpus: Ua, totalmem: Ga, freemem: Ha, uptime: Wa, loadavg: Va, hostname: $a, endianness: Ra };
          } }), km = ee({ "node-modules-polyfills-commonjs:os"(e, n) {
            re();
            var t = (Im(), ft(Ma));
            if (t && t.default) {
              n.exports = t.default;
              for (let s in t)
                n.exports[s] = t[s];
            } else
              t && (n.exports = t);
          } }), Lm = ee({ "node_modules/detect-newline/index.js"(e, n) {
            "use strict";
            re();
            var t = (s) => {
              if (typeof s != "string")
                throw new TypeError("Expected a string");
              let a = s.match(/(?:\r?\n)/g) || [];
              if (a.length === 0)
                return;
              let r = a.filter((i) => i === `\r
`).length, u = a.length - r;
              return r > u ? `\r
` : `
`;
            };
            n.exports = t, n.exports.graceful = (s) => typeof s == "string" && t(s) || `
`;
          } }), jm = ee({ "node_modules/jest-docblock/build/index.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = p, e.parse = v, e.parseWithComments = w, e.print = T, e.strip = D;
            function n() {
              let A3 = km();
              return n = function() {
                return A3;
              }, A3;
            }
            function t() {
              let A3 = s(Lm());
              return t = function() {
                return A3;
              }, A3;
            }
            function s(A3) {
              return A3 && A3.__esModule ? A3 : { default: A3 };
            }
            var a = /\*\/$/, r = /^\/\*\*?/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, l = /^(\r?\n)+/, c = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, y = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, h = /(\r?\n|^) *\* ?/g, g = [];
            function p(A3) {
              let B = A3.match(u);
              return B ? B[0].trimLeft() : "";
            }
            function D(A3) {
              let B = A3.match(u);
              return B && B[0] ? A3.substring(B[0].length) : A3;
            }
            function v(A3) {
              return w(A3).pragmas;
            }
            function w(A3) {
              let B = (0, t().default)(A3) || n().EOL;
              A3 = A3.replace(r, "").replace(a, "").replace(h, "$1");
              let I = "";
              for (; I !== A3; )
                I = A3, A3 = A3.replace(c, `${B}$1 $2${B}`);
              A3 = A3.replace(l, "").trimRight();
              let P2 = /* @__PURE__ */ Object.create(null), R = A3.replace(y, "").replace(l, "").trimRight(), f;
              for (; f = y.exec(A3); ) {
                let x = f[2].replace(i, "");
                typeof P2[f[1]] == "string" || Array.isArray(P2[f[1]]) ? P2[f[1]] = g.concat(P2[f[1]], x) : P2[f[1]] = x;
              }
              return { comments: R, pragmas: P2 };
            }
            function T(A3) {
              let { comments: B = "", pragmas: I = {} } = A3, P2 = (0, t().default)(B) || n().EOL, R = "/**", f = " *", x = " */", m = Object.keys(I), E = m.map((d) => F(d, I[d])).reduce((d, C) => d.concat(C), []).map((d) => `${f} ${d}${P2}`).join("");
              if (!B) {
                if (m.length === 0)
                  return "";
                if (m.length === 1 && !Array.isArray(I[m[0]])) {
                  let d = I[m[0]];
                  return `${R} ${F(m[0], d)[0]}${x}`;
                }
              }
              let o = B.split(P2).map((d) => `${f} ${d}`).join(P2) + P2;
              return R + P2 + (B ? o : "") + (B && m.length ? f + P2 : "") + E + x;
            }
            function F(A3, B) {
              return g.concat(B).map((I) => `@${A3} ${I}`.trim());
            }
          } }), Om = ee({ "src/language-js/utils/get-shebang.js"(e, n) {
            "use strict";
            re();
            function t(s) {
              if (!s.startsWith("#!"))
                return "";
              let a = s.indexOf(`
`);
              return a === -1 ? s : s.slice(0, a);
            }
            n.exports = t;
          } }), Qa = ee({ "src/language-js/pragma.js"(e, n) {
            "use strict";
            re();
            var { parseWithComments: t, strip: s, extract: a, print: r } = jm(), { normalizeEndOfLine: u } = qn(), i = Om();
            function l(h) {
              let g = i(h);
              g && (h = h.slice(g.length + 1));
              let p = a(h), { pragmas: D, comments: v } = t(p);
              return { shebang: g, text: h, pragmas: D, comments: v };
            }
            function c(h) {
              let g = Object.keys(l(h).pragmas);
              return g.includes("prettier") || g.includes("format");
            }
            function y(h) {
              let { shebang: g, text: p, pragmas: D, comments: v } = l(h), w = s(p), T = r({ pragmas: Object.assign({ format: "" }, D), comments: v.trimStart() });
              return (g ? `${g}
` : "") + u(T) + (w.startsWith(`
`) ? `
` : `

`) + w;
            }
            n.exports = { hasPragma: c, insertPragma: y };
          } }), Za = ee({ "src/language-js/comments.js"(e, n) {
            "use strict";
            re();
            var { getLast: t, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a, getNextNonSpaceNonCommentCharacter: r, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: l, addDanglingComment: c, getNextNonSpaceNonCommentCharacterIndex: y, isNonEmptyArray: h } = Ge(), { getFunctionParameters: g, isPrettierIgnoreComment: p, isJsxNode: D, hasFlowShorthandAnnotationComment: v, hasFlowAnnotationComment: w, hasIgnoreComment: T, isCallLikeExpression: F, getCallArguments: A3, isCallExpression: B, isMemberExpression: I, isObjectProperty: P2, isLineComment: R, getComments: f, CommentCheckFlags: x, markerForIfWithoutBlockAndSameLineComment: m } = Ke(), { locStart: E, locEnd: o } = it(), d = Lt();
            function C(ye) {
              return [ce, ae, L, M, q, J, K, ge, Z, fe, Ce, _e, Q, Ae, z].some((S) => S(ye));
            }
            function _(ye) {
              return [$, ae, Y, Ce, M, q, J, K, Ae, H, ne, fe, ie, z, de].some((S) => S(ye));
            }
            function b(ye) {
              return [ce, M, q, V, oe, Q, fe, X, W, U, z, ve].some((S) => S(ye));
            }
            function N(ye, S) {
              let G = (ye.body || ye.properties).find((te) => {
                let { type: Ee } = te;
                return Ee !== "EmptyStatement";
              });
              G ? i(G, S) : c(ye, S);
            }
            function k(ye, S) {
              ye.type === "BlockStatement" ? N(ye, S) : i(ye, S);
            }
            function $(ye) {
              let { comment: S, followingNode: G } = ye;
              return G && Be(S) ? (i(G, S), true) : false;
            }
            function M(ye) {
              let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee, text: Re } = ye;
              if ((te == null ? void 0 : te.type) !== "IfStatement" || !Ee)
                return false;
              if (r(Re, S, o) === ")")
                return l(G, S), true;
              if (G === te.consequent && Ee === te.alternate) {
                if (G.type === "BlockStatement")
                  l(G, S);
                else {
                  let Pe = S.type === "SingleLine" || S.loc.start.line === S.loc.end.line, Fe = S.loc.start.line === G.loc.start.line;
                  Pe && Fe ? c(G, S, m) : c(te, S);
                }
                return true;
              }
              return Ee.type === "BlockStatement" ? (N(Ee, S), true) : Ee.type === "IfStatement" ? (k(Ee.consequent, S), true) : te.consequent === Ee ? (i(Ee, S), true) : false;
            }
            function q(ye) {
              let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee, text: Re } = ye;
              return (te == null ? void 0 : te.type) !== "WhileStatement" || !Ee ? false : r(Re, S, o) === ")" ? (l(G, S), true) : Ee.type === "BlockStatement" ? (N(Ee, S), true) : te.body === Ee ? (i(Ee, S), true) : false;
            }
            function J(ye) {
              let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee } = ye;
              return (te == null ? void 0 : te.type) !== "TryStatement" && (te == null ? void 0 : te.type) !== "CatchClause" || !Ee ? false : te.type === "CatchClause" && G ? (l(G, S), true) : Ee.type === "BlockStatement" ? (N(Ee, S), true) : Ee.type === "TryStatement" ? (k(Ee.finalizer, S), true) : Ee.type === "CatchClause" ? (k(Ee.body, S), true) : false;
            }
            function L(ye) {
              let { comment: S, enclosingNode: G, followingNode: te } = ye;
              return I(G) && (te == null ? void 0 : te.type) === "Identifier" ? (i(G, S), true) : false;
            }
            function Y(ye) {
              let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee, text: Re } = ye, Te = G && !u(Re, o(G), E(S));
              return (!G || !Te) && ((te == null ? void 0 : te.type) === "ConditionalExpression" || (te == null ? void 0 : te.type) === "TSConditionalType") && Ee ? (i(Ee, S), true) : false;
            }
            function V(ye) {
              let { comment: S, precedingNode: G, enclosingNode: te } = ye;
              return P2(te) && te.shorthand && te.key === G && te.value.type === "AssignmentPattern" ? (l(te.value.left, S), true) : false;
            }
            var O = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
            function K(ye) {
              let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee } = ye;
              if (O.has(te == null ? void 0 : te.type)) {
                if (h(te.decorators) && !(Ee && Ee.type === "Decorator"))
                  return l(t(te.decorators), S), true;
                if (te.body && Ee === te.body)
                  return N(te.body, S), true;
                if (Ee) {
                  if (te.superClass && Ee === te.superClass && G && (G === te.id || G === te.typeParameters))
                    return l(G, S), true;
                  for (let Re of ["implements", "extends", "mixins"])
                    if (te[Re] && Ee === te[Re][0])
                      return G && (G === te.id || G === te.typeParameters || G === te.superClass) ? l(G, S) : c(te, S, Re), true;
                }
              }
              return false;
            }
            var se = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition"]);
            function Q(ye) {
              let { comment: S, precedingNode: G, enclosingNode: te, text: Ee } = ye;
              return te && G && r(Ee, S, o) === "(" && (te.type === "Property" || te.type === "TSDeclareMethod" || te.type === "TSAbstractMethodDefinition") && G.type === "Identifier" && te.key === G && r(Ee, G, o) !== ":" || (G == null ? void 0 : G.type) === "Decorator" && se.has(te == null ? void 0 : te.type) ? (l(G, S), true) : false;
            }
            var le = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
            function W(ye) {
              let { comment: S, precedingNode: G, enclosingNode: te, text: Ee } = ye;
              return r(Ee, S, o) !== "(" ? false : G && le.has(te == null ? void 0 : te.type) ? (l(G, S), true) : false;
            }
            function X(ye) {
              let { comment: S, enclosingNode: G, text: te } = ye;
              if ((G == null ? void 0 : G.type) !== "ArrowFunctionExpression")
                return false;
              let Ee = y(te, S, o);
              return Ee !== false && te.slice(Ee, Ee + 2) === "=>" ? (c(G, S), true) : false;
            }
            function oe(ye) {
              let { comment: S, enclosingNode: G, text: te } = ye;
              return r(te, S, o) !== ")" ? false : G && (De(G) && g(G).length === 0 || F(G) && A3(G).length === 0) ? (c(G, S), true) : ((G == null ? void 0 : G.type) === "MethodDefinition" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && g(G.value).length === 0 ? (c(G.value, S), true) : false;
            }
            function ae(ye) {
              let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee, text: Re } = ye;
              if ((G == null ? void 0 : G.type) === "FunctionTypeParam" && (te == null ? void 0 : te.type) === "FunctionTypeAnnotation" && (Ee == null ? void 0 : Ee.type) !== "FunctionTypeParam" || ((G == null ? void 0 : G.type) === "Identifier" || (G == null ? void 0 : G.type) === "AssignmentPattern") && te && De(te) && r(Re, S, o) === ")")
                return l(G, S), true;
              if ((te == null ? void 0 : te.type) === "FunctionDeclaration" && (Ee == null ? void 0 : Ee.type) === "BlockStatement") {
                let Te = (() => {
                  let Pe = g(te);
                  if (Pe.length > 0)
                    return a(Re, o(t(Pe)));
                  let Fe = a(Re, o(te.id));
                  return Fe !== false && a(Re, Fe + 1);
                })();
                if (E(S) > Te)
                  return N(Ee, S), true;
              }
              return false;
            }
            function Ae(ye) {
              let { comment: S, enclosingNode: G } = ye;
              return (G == null ? void 0 : G.type) === "LabeledStatement" ? (i(G, S), true) : false;
            }
            function z(ye) {
              let { comment: S, enclosingNode: G } = ye;
              return ((G == null ? void 0 : G.type) === "ContinueStatement" || (G == null ? void 0 : G.type) === "BreakStatement") && !G.label ? (l(G, S), true) : false;
            }
            function H(ye) {
              let { comment: S, precedingNode: G, enclosingNode: te } = ye;
              return B(te) && G && te.callee === G && te.arguments.length > 0 ? (i(te.arguments[0], S), true) : false;
            }
            function Z(ye) {
              let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee } = ye;
              return (te == null ? void 0 : te.type) === "UnionTypeAnnotation" || (te == null ? void 0 : te.type) === "TSUnionType" ? (p(S) && (Ee.prettierIgnore = true, S.unignore = true), G ? (l(G, S), true) : false) : (((Ee == null ? void 0 : Ee.type) === "UnionTypeAnnotation" || (Ee == null ? void 0 : Ee.type) === "TSUnionType") && p(S) && (Ee.types[0].prettierIgnore = true, S.unignore = true), false);
            }
            function ne(ye) {
              let { comment: S, enclosingNode: G } = ye;
              return P2(G) ? (i(G, S), true) : false;
            }
            function fe(ye) {
              let { comment: S, enclosingNode: G, followingNode: te, ast: Ee, isLastComment: Re } = ye;
              return Ee && Ee.body && Ee.body.length === 0 ? (Re ? c(Ee, S) : i(Ee, S), true) : (G == null ? void 0 : G.type) === "Program" && (G == null ? void 0 : G.body.length) === 0 && !h(G.directives) ? (Re ? c(G, S) : i(G, S), true) : (te == null ? void 0 : te.type) === "Program" && (te == null ? void 0 : te.body.length) === 0 && (G == null ? void 0 : G.type) === "ModuleExpression" ? (c(te, S), true) : false;
            }
            function ge(ye) {
              let { comment: S, enclosingNode: G } = ye;
              return (G == null ? void 0 : G.type) === "ForInStatement" || (G == null ? void 0 : G.type) === "ForOfStatement" ? (i(G, S), true) : false;
            }
            function Ce(ye) {
              let { comment: S, precedingNode: G, enclosingNode: te, text: Ee } = ye;
              if ((te == null ? void 0 : te.type) === "ImportSpecifier" || (te == null ? void 0 : te.type) === "ExportSpecifier")
                return i(te, S), true;
              let Re = (G == null ? void 0 : G.type) === "ImportSpecifier" && (te == null ? void 0 : te.type) === "ImportDeclaration", Te = (G == null ? void 0 : G.type) === "ExportSpecifier" && (te == null ? void 0 : te.type) === "ExportNamedDeclaration";
              return (Re || Te) && s(Ee, o(S)) ? (l(G, S), true) : false;
            }
            function _e(ye) {
              let { comment: S, enclosingNode: G } = ye;
              return (G == null ? void 0 : G.type) === "AssignmentPattern" ? (i(G, S), true) : false;
            }
            var Oe = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), pe = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
            function ie(ye) {
              let { comment: S, enclosingNode: G, followingNode: te } = ye;
              return Oe.has(G == null ? void 0 : G.type) && te && (pe.has(te.type) || d(S)) ? (i(te, S), true) : false;
            }
            function ve(ye) {
              let { comment: S, enclosingNode: G, followingNode: te, text: Ee } = ye;
              return !te && ((G == null ? void 0 : G.type) === "TSMethodSignature" || (G == null ? void 0 : G.type) === "TSDeclareFunction" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && r(Ee, S, o) === ";" ? (l(G, S), true) : false;
            }
            function ce(ye) {
              let { comment: S, enclosingNode: G, followingNode: te } = ye;
              if (p(S) && (G == null ? void 0 : G.type) === "TSMappedType" && (te == null ? void 0 : te.type) === "TSTypeParameter" && te.constraint)
                return G.prettierIgnore = true, S.unignore = true, true;
            }
            function U(ye) {
              let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee } = ye;
              return (te == null ? void 0 : te.type) !== "TSMappedType" ? false : (Ee == null ? void 0 : Ee.type) === "TSTypeParameter" && Ee.name ? (i(Ee.name, S), true) : (G == null ? void 0 : G.type) === "TSTypeParameter" && G.constraint ? (l(G.constraint, S), true) : false;
            }
            function de(ye) {
              let { comment: S, enclosingNode: G, followingNode: te } = ye;
              return !G || G.type !== "SwitchCase" || G.test ? false : (te.type === "BlockStatement" && R(S) ? N(te, S) : c(G, S), true);
            }
            function De(ye) {
              return ye.type === "ArrowFunctionExpression" || ye.type === "FunctionExpression" || ye.type === "FunctionDeclaration" || ye.type === "ObjectMethod" || ye.type === "ClassMethod" || ye.type === "TSDeclareFunction" || ye.type === "TSCallSignatureDeclaration" || ye.type === "TSConstructSignatureDeclaration" || ye.type === "TSMethodSignature" || ye.type === "TSConstructorType" || ye.type === "TSFunctionType" || ye.type === "TSDeclareMethod";
            }
            function he(ye, S) {
              if ((S.parser === "typescript" || S.parser === "flow" || S.parser === "acorn" || S.parser === "espree" || S.parser === "meriyah" || S.parser === "__babel_estree") && ye.type === "MethodDefinition" && ye.value && ye.value.type === "FunctionExpression" && g(ye.value).length === 0 && !ye.value.returnType && !h(ye.value.typeParameters) && ye.value.body)
                return [...ye.decorators || [], ye.key, ye.value.body];
            }
            function Be(ye) {
              return d(ye) && ye.value[0] === "*" && /@type\b/.test(ye.value);
            }
            function Se(ye) {
              let S = ye.getValue(), G = ye.getParentNode(), te = (Ee) => w(f(Ee, x.Leading)) || w(f(Ee, x.Trailing));
              return (S && (D(S) || v(S) || B(G) && te(S)) || G && (G.type === "JSXSpreadAttribute" || G.type === "JSXSpreadChild" || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType" || (G.type === "ClassDeclaration" || G.type === "ClassExpression") && G.superClass === S)) && (!T(ye) || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType");
            }
            n.exports = { handleOwnLineComment: C, handleEndOfLineComment: _, handleRemainingComment: b, isTypeCastComment: Be, getCommentChildNodes: he, willPrintOwnComments: Se };
          } }), Ot = ee({ "src/language-js/needs-parens.js"(e, n) {
            "use strict";
            re();
            var t = lt(), s = $n(), { getFunctionParameters: a, getLeftSidePathName: r, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: l, isBitwiseOperator: c, startsWithNoLookaheadToken: y, shouldFlatten: h, getPrecedence: g, isCallExpression: p, isMemberExpression: D, isObjectProperty: v, isTSTypeExpression: w } = Ke();
            function T(f, x) {
              let m = f.getParentNode();
              if (!m)
                return false;
              let E = f.getName(), o = f.getNode();
              if (x.__isInHtmlInterpolation && !x.bracketSpacing && I(o) && P2(f))
                return true;
              if (F(o))
                return false;
              if (x.parser !== "flow" && u(f.getValue()))
                return true;
              if (o.type === "Identifier")
                return !!(o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name) || E === "left" && o.name === "async" && m.type === "ForOfStatement" && !m.await);
              switch (m.type) {
                case "ParenthesizedExpression":
                  return false;
                case "ClassDeclaration":
                case "ClassExpression": {
                  if (E === "superClass" && (o.type === "ArrowFunctionExpression" || o.type === "AssignmentExpression" || o.type === "AwaitExpression" || o.type === "BinaryExpression" || o.type === "ConditionalExpression" || o.type === "LogicalExpression" || o.type === "NewExpression" || o.type === "ObjectExpression" || o.type === "SequenceExpression" || o.type === "TaggedTemplateExpression" || o.type === "UnaryExpression" || o.type === "UpdateExpression" || o.type === "YieldExpression" || o.type === "TSNonNullExpression"))
                    return true;
                  break;
                }
                case "ExportDefaultDeclaration":
                  return R(f, x) || o.type === "SequenceExpression";
                case "Decorator": {
                  if (E === "expression") {
                    let d = false, C = false, _ = o;
                    for (; _; )
                      switch (_.type) {
                        case "MemberExpression":
                          C = true, _ = _.object;
                          break;
                        case "CallExpression":
                          if (C || d)
                            return x.parser !== "typescript";
                          d = true, _ = _.callee;
                          break;
                        case "Identifier":
                          return false;
                        case "TaggedTemplateExpression":
                          return x.parser !== "typescript";
                        default:
                          return true;
                      }
                    return true;
                  }
                  break;
                }
                case "ExpressionStatement": {
                  if (y(o, true))
                    return true;
                  break;
                }
                case "ArrowFunctionExpression": {
                  if (E === "body" && o.type !== "SequenceExpression" && y(o, false))
                    return true;
                  break;
                }
              }
              switch (o.type) {
                case "UpdateExpression":
                  if (m.type === "UnaryExpression")
                    return o.prefix && (o.operator === "++" && m.operator === "+" || o.operator === "--" && m.operator === "-");
                case "UnaryExpression":
                  switch (m.type) {
                    case "UnaryExpression":
                      return o.operator === m.operator && (o.operator === "+" || o.operator === "-");
                    case "BindExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return E === "object";
                    case "TaggedTemplateExpression":
                      return true;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return E === "callee";
                    case "BinaryExpression":
                      return E === "left" && m.operator === "**";
                    case "TSNonNullExpression":
                      return true;
                    default:
                      return false;
                  }
                case "BinaryExpression": {
                  if (m.type === "UpdateExpression" || o.operator === "in" && A3(f))
                    return true;
                  if (o.operator === "|>" && o.extra && o.extra.parenthesized) {
                    let d = f.getParentNode(1);
                    if (d.type === "BinaryExpression" && d.operator === "|>")
                      return true;
                  }
                }
                case "TSTypeAssertion":
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "LogicalExpression":
                  switch (m.type) {
                    case "TSSatisfiesExpression":
                    case "TSAsExpression":
                      return !w(o);
                    case "ConditionalExpression":
                      return w(o);
                    case "CallExpression":
                    case "NewExpression":
                    case "OptionalCallExpression":
                      return E === "callee";
                    case "ClassExpression":
                    case "ClassDeclaration":
                      return E === "superClass";
                    case "TSTypeAssertion":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "JSXSpreadAttribute":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BindExpression":
                    case "AwaitExpression":
                    case "TSNonNullExpression":
                    case "UpdateExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return E === "object";
                    case "AssignmentExpression":
                    case "AssignmentPattern":
                      return E === "left" && (o.type === "TSTypeAssertion" || w(o));
                    case "LogicalExpression":
                      if (o.type === "LogicalExpression")
                        return m.operator !== o.operator;
                    case "BinaryExpression": {
                      let { operator: d, type: C } = o;
                      if (!d && C !== "TSTypeAssertion")
                        return true;
                      let _ = g(d), b = m.operator, N = g(b);
                      return N > _ || E === "right" && N === _ || N === _ && !h(b, d) ? true : N < _ && d === "%" ? b === "+" || b === "-" : !!c(b);
                    }
                    default:
                      return false;
                  }
                case "SequenceExpression":
                  switch (m.type) {
                    case "ReturnStatement":
                      return false;
                    case "ForStatement":
                      return false;
                    case "ExpressionStatement":
                      return E !== "expression";
                    case "ArrowFunctionExpression":
                      return E !== "body";
                    default:
                      return true;
                  }
                case "YieldExpression":
                  if (m.type === "UnaryExpression" || m.type === "AwaitExpression" || w(m) || m.type === "TSNonNullExpression")
                    return true;
                case "AwaitExpression":
                  switch (m.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return E === "object";
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return E === "callee";
                    case "ConditionalExpression":
                      return E === "test";
                    case "BinaryExpression":
                      return !(!o.argument && m.operator === "|>");
                    default:
                      return false;
                  }
                case "TSConditionalType":
                  if (E === "extendsType" && m.type === "TSConditionalType")
                    return true;
                case "TSFunctionType":
                case "TSConstructorType":
                  if (E === "extendsType" && m.type === "TSConditionalType") {
                    let d = (o.returnType || o.typeAnnotation).typeAnnotation;
                    if (d.type === "TSInferType" && d.typeParameter.constraint)
                      return true;
                  }
                  if (E === "checkType" && m.type === "TSConditionalType")
                    return true;
                case "TSUnionType":
                case "TSIntersectionType":
                  if ((m.type === "TSUnionType" || m.type === "TSIntersectionType") && m.types.length > 1 && (!o.types || o.types.length > 1))
                    return true;
                case "TSInferType":
                  if (o.type === "TSInferType" && m.type === "TSRestType")
                    return false;
                case "TSTypeOperator":
                  return m.type === "TSArrayType" || m.type === "TSOptionalType" || m.type === "TSRestType" || E === "objectType" && m.type === "TSIndexedAccessType" || m.type === "TSTypeOperator" || m.type === "TSTypeAnnotation" && f.getParentNode(1).type.startsWith("TSJSDoc");
                case "ArrayTypeAnnotation":
                  return m.type === "NullableTypeAnnotation";
                case "IntersectionTypeAnnotation":
                case "UnionTypeAnnotation":
                  return m.type === "ArrayTypeAnnotation" || m.type === "NullableTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "UnionTypeAnnotation" || E === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
                case "NullableTypeAnnotation":
                  return m.type === "ArrayTypeAnnotation" || E === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
                case "FunctionTypeAnnotation": {
                  let d = m.type === "NullableTypeAnnotation" ? f.getParentNode(1) : m;
                  return d.type === "UnionTypeAnnotation" || d.type === "IntersectionTypeAnnotation" || d.type === "ArrayTypeAnnotation" || E === "objectType" && (d.type === "IndexedAccessType" || d.type === "OptionalIndexedAccessType") || d.type === "NullableTypeAnnotation" || m.type === "FunctionTypeParam" && m.name === null && a(o).some((C) => C.typeAnnotation && C.typeAnnotation.type === "NullableTypeAnnotation");
                }
                case "OptionalIndexedAccessType":
                  return E === "objectType" && m.type === "IndexedAccessType";
                case "TypeofTypeAnnotation":
                  return E === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
                case "StringLiteral":
                case "NumericLiteral":
                case "Literal":
                  if (typeof o.value == "string" && m.type === "ExpressionStatement" && !m.directive) {
                    let d = f.getParentNode(1);
                    return d.type === "Program" || d.type === "BlockStatement";
                  }
                  return E === "object" && m.type === "MemberExpression" && typeof o.value == "number";
                case "AssignmentExpression": {
                  let d = f.getParentNode(1);
                  return E === "body" && m.type === "ArrowFunctionExpression" ? true : E === "key" && (m.type === "ClassProperty" || m.type === "PropertyDefinition") && m.computed || (E === "init" || E === "update") && m.type === "ForStatement" ? false : m.type === "ExpressionStatement" ? o.left.type === "ObjectPattern" : !(E === "key" && m.type === "TSPropertySignature" || m.type === "AssignmentExpression" || m.type === "SequenceExpression" && d && d.type === "ForStatement" && (d.init === m || d.update === m) || E === "value" && m.type === "Property" && d && d.type === "ObjectPattern" && d.properties.includes(m) || m.type === "NGChainedExpression");
                }
                case "ConditionalExpression":
                  switch (m.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "NGPipeExpression":
                    case "ExportDefaultDeclaration":
                    case "AwaitExpression":
                    case "JSXSpreadAttribute":
                    case "TSTypeAssertion":
                    case "TypeCastExpression":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSNonNullExpression":
                      return true;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return E === "callee";
                    case "ConditionalExpression":
                      return E === "test";
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return E === "object";
                    default:
                      return false;
                  }
                case "FunctionExpression":
                  switch (m.type) {
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return E === "callee";
                    case "TaggedTemplateExpression":
                      return true;
                    default:
                      return false;
                  }
                case "ArrowFunctionExpression":
                  switch (m.type) {
                    case "BinaryExpression":
                      return m.operator !== "|>" || o.extra && o.extra.parenthesized;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return E === "callee";
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return E === "object";
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "AwaitExpression":
                    case "TSTypeAssertion":
                      return true;
                    case "ConditionalExpression":
                      return E === "test";
                    default:
                      return false;
                  }
                case "ClassExpression":
                  if (s(o.decorators))
                    return true;
                  switch (m.type) {
                    case "NewExpression":
                      return E === "callee";
                    default:
                      return false;
                  }
                case "OptionalMemberExpression":
                case "OptionalCallExpression": {
                  let d = f.getParentNode(1);
                  if (E === "object" && m.type === "MemberExpression" || E === "callee" && (m.type === "CallExpression" || m.type === "NewExpression") || m.type === "TSNonNullExpression" && d.type === "MemberExpression" && d.object === m)
                    return true;
                }
                case "CallExpression":
                case "MemberExpression":
                case "TaggedTemplateExpression":
                case "TSNonNullExpression":
                  if (E === "callee" && (m.type === "BindExpression" || m.type === "NewExpression")) {
                    let d = o;
                    for (; d; )
                      switch (d.type) {
                        case "CallExpression":
                        case "OptionalCallExpression":
                          return true;
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                        case "BindExpression":
                          d = d.object;
                          break;
                        case "TaggedTemplateExpression":
                          d = d.tag;
                          break;
                        case "TSNonNullExpression":
                          d = d.expression;
                          break;
                        default:
                          return false;
                      }
                  }
                  return false;
                case "BindExpression":
                  return E === "callee" && (m.type === "BindExpression" || m.type === "NewExpression") || E === "object" && D(m);
                case "NGPipeExpression":
                  return !(m.type === "NGRoot" || m.type === "NGMicrosyntaxExpression" || m.type === "ObjectProperty" && !(o.extra && o.extra.parenthesized) || m.type === "ArrayExpression" || p(m) && m.arguments[E] === o || E === "right" && m.type === "NGPipeExpression" || E === "property" && m.type === "MemberExpression" || m.type === "AssignmentExpression");
                case "JSXFragment":
                case "JSXElement":
                  return E === "callee" || E === "left" && m.type === "BinaryExpression" && m.operator === "<" || m.type !== "ArrayExpression" && m.type !== "ArrowFunctionExpression" && m.type !== "AssignmentExpression" && m.type !== "AssignmentPattern" && m.type !== "BinaryExpression" && m.type !== "NewExpression" && m.type !== "ConditionalExpression" && m.type !== "ExpressionStatement" && m.type !== "JsExpressionRoot" && m.type !== "JSXAttribute" && m.type !== "JSXElement" && m.type !== "JSXExpressionContainer" && m.type !== "JSXFragment" && m.type !== "LogicalExpression" && !p(m) && !v(m) && m.type !== "ReturnStatement" && m.type !== "ThrowStatement" && m.type !== "TypeCastExpression" && m.type !== "VariableDeclarator" && m.type !== "YieldExpression";
                case "TypeAnnotation":
                  return E === "returnType" && m.type === "ArrowFunctionExpression" && B(o);
              }
              return false;
            }
            function F(f) {
              return f.type === "BlockStatement" || f.type === "BreakStatement" || f.type === "ClassBody" || f.type === "ClassDeclaration" || f.type === "ClassMethod" || f.type === "ClassProperty" || f.type === "PropertyDefinition" || f.type === "ClassPrivateProperty" || f.type === "ContinueStatement" || f.type === "DebuggerStatement" || f.type === "DeclareClass" || f.type === "DeclareExportAllDeclaration" || f.type === "DeclareExportDeclaration" || f.type === "DeclareFunction" || f.type === "DeclareInterface" || f.type === "DeclareModule" || f.type === "DeclareModuleExports" || f.type === "DeclareVariable" || f.type === "DoWhileStatement" || f.type === "EnumDeclaration" || f.type === "ExportAllDeclaration" || f.type === "ExportDefaultDeclaration" || f.type === "ExportNamedDeclaration" || f.type === "ExpressionStatement" || f.type === "ForInStatement" || f.type === "ForOfStatement" || f.type === "ForStatement" || f.type === "FunctionDeclaration" || f.type === "IfStatement" || f.type === "ImportDeclaration" || f.type === "InterfaceDeclaration" || f.type === "LabeledStatement" || f.type === "MethodDefinition" || f.type === "ReturnStatement" || f.type === "SwitchStatement" || f.type === "ThrowStatement" || f.type === "TryStatement" || f.type === "TSDeclareFunction" || f.type === "TSEnumDeclaration" || f.type === "TSImportEqualsDeclaration" || f.type === "TSInterfaceDeclaration" || f.type === "TSModuleDeclaration" || f.type === "TSNamespaceExportDeclaration" || f.type === "TypeAlias" || f.type === "VariableDeclaration" || f.type === "WhileStatement" || f.type === "WithStatement";
            }
            function A3(f) {
              let x = 0, m = f.getValue();
              for (; m; ) {
                let E = f.getParentNode(x++);
                if (E && E.type === "ForStatement" && E.init === m)
                  return true;
                m = E;
              }
              return false;
            }
            function B(f) {
              return l(f, (x) => x.type === "ObjectTypeAnnotation" && l(x, (m) => m.type === "FunctionTypeAnnotation" || void 0) || void 0);
            }
            function I(f) {
              switch (f.type) {
                case "ObjectExpression":
                  return true;
                default:
                  return false;
              }
            }
            function P2(f) {
              let x = f.getValue(), m = f.getParentNode(), E = f.getName();
              switch (m.type) {
                case "NGPipeExpression":
                  if (typeof E == "number" && m.arguments[E] === x && m.arguments.length - 1 === E)
                    return f.callParent(P2);
                  break;
                case "ObjectProperty":
                  if (E === "value") {
                    let o = f.getParentNode(1);
                    return t(o.properties) === m;
                  }
                  break;
                case "BinaryExpression":
                case "LogicalExpression":
                  if (E === "right")
                    return f.callParent(P2);
                  break;
                case "ConditionalExpression":
                  if (E === "alternate")
                    return f.callParent(P2);
                  break;
                case "UnaryExpression":
                  if (m.prefix)
                    return f.callParent(P2);
                  break;
              }
              return false;
            }
            function R(f, x) {
              let m = f.getValue(), E = f.getParentNode();
              return m.type === "FunctionExpression" || m.type === "ClassExpression" ? E.type === "ExportDefaultDeclaration" || !T(f, x) : !i(m) || E.type !== "ExportDefaultDeclaration" && T(f, x) ? false : f.call((o) => R(o, x), ...r(f, m));
            }
            n.exports = T;
          } }), eo = ee({ "src/language-js/print-preprocess.js"(e, n) {
            "use strict";
            re();
            function t(s, a) {
              switch (a.parser) {
                case "json":
                case "json5":
                case "json-stringify":
                case "__js_expression":
                case "__vue_expression":
                case "__vue_ts_expression":
                  return Object.assign(Object.assign({}, s), {}, { type: a.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: a.rootMarker });
                default:
                  return s;
              }
            }
            n.exports = t;
          } }), qm = ee({ "src/language-js/print/html-binding.js"(e, n) {
            "use strict";
            re();
            var { builders: { join: t, line: s, group: a, softline: r, indent: u } } = qe();
            function i(c, y, h) {
              let g = c.getValue();
              if (y.__onHtmlBindingRoot && c.getName() === null && y.__onHtmlBindingRoot(g, y), g.type === "File") {
                if (y.__isVueForBindingLeft)
                  return c.call((p) => {
                    let D = t([",", s], p.map(h, "params")), { params: v } = p.getValue();
                    return v.length === 1 ? D : ["(", u([r, a(D)]), r, ")"];
                  }, "program", "body", 0);
                if (y.__isVueBindings)
                  return c.call((p) => t([",", s], p.map(h, "params")), "program", "body", 0);
              }
            }
            function l(c) {
              switch (c.type) {
                case "MemberExpression":
                  switch (c.property.type) {
                    case "Identifier":
                    case "NumericLiteral":
                    case "StringLiteral":
                      return l(c.object);
                  }
                  return false;
                case "Identifier":
                  return true;
                default:
                  return false;
              }
            }
            n.exports = { isVueEventBindingExpression: l, printHtmlBinding: i };
          } }), Jn = ee({ "src/language-js/print/binaryish.js"(e, n) {
            "use strict";
            re();
            var { printComments: t } = et(), { getLast: s } = Ge(), { builders: { join: a, line: r, softline: u, group: i, indent: l, align: c, indentIfBreak: y }, utils: { cleanDoc: h, getDocParts: g, isConcat: p } } = qe(), { hasLeadingOwnLineComment: D, isBinaryish: v, isJsxNode: w, shouldFlatten: T, hasComment: F, CommentCheckFlags: A3, isCallExpression: B, isMemberExpression: I, isObjectProperty: P2, isEnabledHackPipeline: R } = Ke(), f = 0;
            function x(o, d, C) {
              let _ = o.getValue(), b = o.getParentNode(), N = o.getParentNode(1), k = _ !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), $ = R(d) && _.operator === "|>", M = m(o, C, d, false, k);
              if (k)
                return M;
              if ($)
                return i(M);
              if (B(b) && b.callee === _ || b.type === "UnaryExpression" || I(b) && !b.computed)
                return i([l([u, ...M]), u]);
              let q = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && N.type === "JSXAttribute" || _.operator !== "|" && b.type === "JsExpressionRoot" || _.type !== "NGPipeExpression" && (b.type === "NGRoot" && d.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && N.type === "NGMicrosyntax" && N.body.length === 1) || _ === b.body && b.type === "ArrowFunctionExpression" || _ !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && N.type !== "ReturnStatement" && N.type !== "ThrowStatement" && !B(N) || b.type === "TemplateLiteral", J = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P2(b), L = v(_.left) && T(_.operator, _.left.operator);
              if (q || E(_) && !L || !E(_) && J)
                return i(M);
              if (M.length === 0)
                return "";
              let Y = w(_.right), V = M.findIndex((W) => typeof W != "string" && !Array.isArray(W) && W.type === "group"), O = M.slice(0, V === -1 ? 1 : V + 1), K = M.slice(O.length, Y ? -1 : void 0), se = Symbol("logicalChain-" + ++f), Q = i([...O, l(K)], { id: se });
              if (!Y)
                return Q;
              let le = s(M);
              return i([Q, y(le, { groupId: se })]);
            }
            function m(o, d, C, _, b) {
              let N = o.getValue();
              if (!v(N))
                return [i(d())];
              let k = [];
              T(N.operator, N.left.operator) ? k = o.call((K) => m(K, d, C, true, b), "left") : k.push(i(d("left")));
              let $ = E(N), M = (N.operator === "|>" || N.type === "NGPipeExpression" || N.operator === "|" && C.parser === "__vue_expression") && !D(C.originalText, N.right), q = N.type === "NGPipeExpression" ? "|" : N.operator, J = N.type === "NGPipeExpression" && N.arguments.length > 0 ? i(l([r, ": ", a([r, ": "], o.map(d, "arguments").map((K) => c(2, i(K))))])) : "", L;
              if ($)
                L = [q, " ", d("right"), J];
              else {
                let se = R(C) && q === "|>" ? o.call((Q) => m(Q, d, C, true, b), "right") : d("right");
                L = [M ? r : "", q, M ? " " : r, se, J];
              }
              let Y = o.getParentNode(), V = F(N.left, A3.Trailing | A3.Line), O = V || !(b && N.type === "LogicalExpression") && Y.type !== N.type && N.left.type !== N.type && N.right.type !== N.type;
              if (k.push(M ? "" : " ", O ? i(L, { shouldBreak: V }) : L), _ && F(N)) {
                let K = h(t(o, k, C));
                return p(K) || K.type === "fill" ? g(K) : [K];
              }
              return k;
            }
            function E(o) {
              return o.type !== "LogicalExpression" ? false : !!(o.right.type === "ObjectExpression" && o.right.properties.length > 0 || o.right.type === "ArrayExpression" && o.right.elements.length > 0 || w(o.right));
            }
            n.exports = { printBinaryishExpression: x, shouldInlineLogicalExpression: E };
          } }), Mm = ee({ "src/language-js/print/angular.js"(e, n) {
            "use strict";
            re();
            var { builders: { join: t, line: s, group: a } } = qe(), { hasNode: r, hasComment: u, getComments: i } = Ke(), { printBinaryishExpression: l } = Jn();
            function c(g, p, D) {
              let v = g.getValue();
              if (v.type.startsWith("NG"))
                switch (v.type) {
                  case "NGRoot":
                    return [D("node"), u(v.node) ? " //" + i(v.node)[0].value.trimEnd() : ""];
                  case "NGPipeExpression":
                    return l(g, p, D);
                  case "NGChainedExpression":
                    return a(t([";", s], g.map((w) => h(w) ? D() : ["(", D(), ")"], "expressions")));
                  case "NGEmptyExpression":
                    return "";
                  case "NGQuotedExpression":
                    return [v.prefix, ": ", v.value.trim()];
                  case "NGMicrosyntax":
                    return g.map((w, T) => [T === 0 ? "" : y(w.getValue(), T, v) ? " " : [";", s], D()], "body");
                  case "NGMicrosyntaxKey":
                    return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(v.name) ? v.name : JSON.stringify(v.name);
                  case "NGMicrosyntaxExpression":
                    return [D("expression"), v.alias === null ? "" : [" as ", D("alias")]];
                  case "NGMicrosyntaxKeyedExpression": {
                    let w = g.getName(), T = g.getParentNode(), F = y(v, w, T) || (w === 1 && (v.key.name === "then" || v.key.name === "else") || w === 2 && v.key.name === "else" && T.body[w - 1].type === "NGMicrosyntaxKeyedExpression" && T.body[w - 1].key.name === "then") && T.body[0].type === "NGMicrosyntaxExpression";
                    return [D("key"), F ? " " : ": ", D("expression")];
                  }
                  case "NGMicrosyntaxLet":
                    return ["let ", D("key"), v.value === null ? "" : [" = ", D("value")]];
                  case "NGMicrosyntaxAs":
                    return [D("key"), " as ", D("alias")];
                  default:
                    throw new Error(`Unknown Angular node type: ${JSON.stringify(v.type)}.`);
                }
            }
            function y(g, p, D) {
              return g.type === "NGMicrosyntaxKeyedExpression" && g.key.name === "of" && p === 1 && D.body[0].type === "NGMicrosyntaxLet" && D.body[0].value === null;
            }
            function h(g) {
              return r(g.getValue(), (p) => {
                switch (p.type) {
                  case void 0:
                    return false;
                  case "CallExpression":
                  case "OptionalCallExpression":
                  case "AssignmentExpression":
                    return true;
                }
              });
            }
            n.exports = { printAngular: c };
          } }), Rm = ee({ "src/language-js/print/jsx.js"(e, n) {
            "use strict";
            re();
            var { printComments: t, printDanglingComments: s } = et(), { builders: { line: a, hardline: r, softline: u, group: i, indent: l, conditionalGroup: c, fill: y, ifBreak: h, lineSuffixBoundary: g, join: p }, utils: { willBreak: D } } = qe(), { getLast: v, getPreferredQuote: w } = Ge(), { isJsxNode: T, rawText: F, isLiteral: A3, isCallExpression: B, isStringLiteral: I, isBinaryish: P2, hasComment: R, CommentCheckFlags: f, hasNodeIgnoreComment: x } = Ke(), m = Ot(), { willPrintOwnComments: E } = Za(), o = (H) => H === "" || H === a || H === r || H === u;
            function d(H, Z, ne) {
              let fe = H.getValue();
              if (fe.type === "JSXElement" && oe(fe))
                return [ne("openingElement"), ne("closingElement")];
              let ge = fe.type === "JSXElement" ? ne("openingElement") : ne("openingFragment"), Ce = fe.type === "JSXElement" ? ne("closingElement") : ne("closingFragment");
              if (fe.children.length === 1 && fe.children[0].type === "JSXExpressionContainer" && (fe.children[0].expression.type === "TemplateLiteral" || fe.children[0].expression.type === "TaggedTemplateExpression"))
                return [ge, ...H.map(ne, "children"), Ce];
              fe.children = fe.children.map((S) => Ae(S) ? { type: "JSXText", value: " ", raw: " " } : S);
              let _e = fe.children.some(T), Oe = fe.children.filter((S) => S.type === "JSXExpressionContainer").length > 1, pe = fe.type === "JSXElement" && fe.openingElement.attributes.length > 1, ie = D(ge) || _e || pe || Oe, ve = H.getParentNode().rootMarker === "mdx", ce = Z.singleQuote ? "{' '}" : '{" "}', U = ve ? " " : h([ce, u], " "), de = fe.openingElement && fe.openingElement.name && fe.openingElement.name.name === "fbt", De = C(H, Z, ne, U, de), he = fe.children.some((S) => ae(S));
              for (let S = De.length - 2; S >= 0; S--) {
                let G = De[S] === "" && De[S + 1] === "", te = De[S] === r && De[S + 1] === "" && De[S + 2] === r, Ee = (De[S] === u || De[S] === r) && De[S + 1] === "" && De[S + 2] === U, Re = De[S] === U && De[S + 1] === "" && (De[S + 2] === u || De[S + 2] === r), Te = De[S] === U && De[S + 1] === "" && De[S + 2] === U, Pe = De[S] === u && De[S + 1] === "" && De[S + 2] === r || De[S] === r && De[S + 1] === "" && De[S + 2] === u;
                te && he || G || Ee || Te || Pe ? De.splice(S, 2) : Re && De.splice(S + 1, 2);
              }
              for (; De.length > 0 && o(v(De)); )
                De.pop();
              for (; De.length > 1 && o(De[0]) && o(De[1]); )
                De.shift(), De.shift();
              let Be = [];
              for (let [S, G] of De.entries()) {
                if (G === U) {
                  if (S === 1 && De[S - 1] === "") {
                    if (De.length === 2) {
                      Be.push(ce);
                      continue;
                    }
                    Be.push([ce, r]);
                    continue;
                  } else if (S === De.length - 1) {
                    Be.push(ce);
                    continue;
                  } else if (De[S - 1] === "" && De[S - 2] === r) {
                    Be.push(ce);
                    continue;
                  }
                }
                Be.push(G), D(G) && (ie = true);
              }
              let Se = he ? y(Be) : i(Be, { shouldBreak: true });
              if (ve)
                return Se;
              let ye = i([ge, l([r, Se]), r, Ce]);
              return ie ? ye : c([i([ge, ...De, Ce]), ye]);
            }
            function C(H, Z, ne, fe, ge) {
              let Ce = [];
              return H.each((_e, Oe, pe) => {
                let ie = _e.getValue();
                if (A3(ie)) {
                  let ve = F(ie);
                  if (ae(ie)) {
                    let ce = ve.split(le);
                    if (ce[0] === "") {
                      if (Ce.push(""), ce.shift(), /\n/.test(ce[0])) {
                        let de = pe[Oe + 1];
                        Ce.push(b(ge, ce[1], ie, de));
                      } else
                        Ce.push(fe);
                      ce.shift();
                    }
                    let U;
                    if (v(ce) === "" && (ce.pop(), U = ce.pop()), ce.length === 0)
                      return;
                    for (let [de, De] of ce.entries())
                      de % 2 === 1 ? Ce.push(a) : Ce.push(De);
                    if (U !== void 0)
                      if (/\n/.test(U)) {
                        let de = pe[Oe + 1];
                        Ce.push(b(ge, v(Ce), ie, de));
                      } else
                        Ce.push(fe);
                    else {
                      let de = pe[Oe + 1];
                      Ce.push(_(ge, v(Ce), ie, de));
                    }
                  } else
                    /\n/.test(ve) ? ve.match(/\n/g).length > 1 && Ce.push("", r) : Ce.push("", fe);
                } else {
                  let ve = ne();
                  Ce.push(ve);
                  let ce = pe[Oe + 1];
                  if (ce && ae(ce)) {
                    let de = X(F(ce)).split(le)[0];
                    Ce.push(_(ge, de, ie, ce));
                  } else
                    Ce.push(r);
                }
              }, "children"), Ce;
            }
            function _(H, Z, ne, fe) {
              return H ? "" : ne.type === "JSXElement" && !ne.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? Z.length === 1 ? u : r : u;
            }
            function b(H, Z, ne, fe) {
              return H ? r : Z.length === 1 ? ne.type === "JSXElement" && !ne.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? r : u : r;
            }
            function N(H, Z, ne) {
              let fe = H.getParentNode();
              if (!fe || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe.type])
                return Z;
              let Ce = H.match(void 0, (Oe) => Oe.type === "ArrowFunctionExpression", B, (Oe) => Oe.type === "JSXExpressionContainer"), _e = m(H, ne);
              return i([_e ? "" : h("("), l([u, Z]), u, _e ? "" : h(")")], { shouldBreak: Ce });
            }
            function k(H, Z, ne) {
              let fe = H.getValue(), ge = [];
              if (ge.push(ne("name")), fe.value) {
                let Ce;
                if (I(fe.value)) {
                  let Oe = F(fe.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: pe, quote: ie, regex: ve } = w(Oe, Z.jsxSingleQuote ? "'" : '"');
                  Oe = Oe.replace(ve, pe), Ce = [ie, Oe, ie];
                } else
                  Ce = ne("value");
                ge.push("=", Ce);
              }
              return ge;
            }
            function $(H, Z, ne) {
              let fe = H.getValue(), ge = (Ce, _e) => Ce.type === "JSXEmptyExpression" || !R(Ce) && (Ce.type === "ArrayExpression" || Ce.type === "ObjectExpression" || Ce.type === "ArrowFunctionExpression" || Ce.type === "AwaitExpression" && (ge(Ce.argument, Ce) || Ce.argument.type === "JSXElement") || B(Ce) || Ce.type === "FunctionExpression" || Ce.type === "TemplateLiteral" || Ce.type === "TaggedTemplateExpression" || Ce.type === "DoExpression" || T(_e) && (Ce.type === "ConditionalExpression" || P2(Ce)));
              return ge(fe.expression, H.getParentNode(0)) ? i(["{", ne("expression"), g, "}"]) : i(["{", l([u, ne("expression")]), u, g, "}"]);
            }
            function M(H, Z, ne) {
              let fe = H.getValue(), ge = fe.name && R(fe.name) || fe.typeParameters && R(fe.typeParameters);
              if (fe.selfClosing && fe.attributes.length === 0 && !ge)
                return ["<", ne("name"), ne("typeParameters"), " />"];
              if (fe.attributes && fe.attributes.length === 1 && fe.attributes[0].value && I(fe.attributes[0].value) && !fe.attributes[0].value.value.includes(`
`) && !ge && !R(fe.attributes[0]))
                return i(["<", ne("name"), ne("typeParameters"), " ", ...H.map(ne, "attributes"), fe.selfClosing ? " />" : ">"]);
              let Ce = fe.attributes && fe.attributes.some((Oe) => Oe.value && I(Oe.value) && Oe.value.value.includes(`
`)), _e = Z.singleAttributePerLine && fe.attributes.length > 1 ? r : a;
              return i(["<", ne("name"), ne("typeParameters"), l(H.map(() => [_e, ne()], "attributes")), ...q(fe, Z, ge)], { shouldBreak: Ce });
            }
            function q(H, Z, ne) {
              return H.selfClosing ? [a, "/>"] : J(H, Z, ne) ? [">"] : [u, ">"];
            }
            function J(H, Z, ne) {
              let fe = H.attributes.length > 0 && R(v(H.attributes), f.Trailing);
              return H.attributes.length === 0 && !ne || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!ne || H.attributes.length > 0) && !fe;
            }
            function L(H, Z, ne) {
              let fe = H.getValue(), ge = [];
              ge.push("</");
              let Ce = ne("name");
              return R(fe.name, f.Leading | f.Line) ? ge.push(l([r, Ce]), r) : R(fe.name, f.Leading | f.Block) ? ge.push(" ", Ce) : ge.push(Ce), ge.push(">"), ge;
            }
            function Y(H, Z) {
              let ne = H.getValue(), fe = R(ne), ge = R(ne, f.Line), Ce = ne.type === "JSXOpeningFragment";
              return [Ce ? "<" : "</", l([ge ? r : fe && !Ce ? " " : "", s(H, Z, true)]), ge ? r : "", ">"];
            }
            function V(H, Z, ne) {
              let fe = t(H, d(H, Z, ne), Z);
              return N(H, fe, Z);
            }
            function O(H, Z) {
              let ne = H.getValue(), fe = R(ne, f.Line);
              return [s(H, Z, !fe), fe ? r : ""];
            }
            function K(H, Z, ne) {
              let fe = H.getValue();
              return ["{", H.call((ge) => {
                let Ce = ["...", ne()], _e = ge.getValue();
                return !R(_e) || !E(ge) ? Ce : [l([u, t(ge, Ce, Z)]), u];
              }, fe.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
            }
            function se(H, Z, ne) {
              let fe = H.getValue();
              if (fe.type.startsWith("JSX"))
                switch (fe.type) {
                  case "JSXAttribute":
                    return k(H, Z, ne);
                  case "JSXIdentifier":
                    return String(fe.name);
                  case "JSXNamespacedName":
                    return p(":", [ne("namespace"), ne("name")]);
                  case "JSXMemberExpression":
                    return p(".", [ne("object"), ne("property")]);
                  case "JSXSpreadAttribute":
                    return K(H, Z, ne);
                  case "JSXSpreadChild":
                    return K(H, Z, ne);
                  case "JSXExpressionContainer":
                    return $(H, Z, ne);
                  case "JSXFragment":
                  case "JSXElement":
                    return V(H, Z, ne);
                  case "JSXOpeningElement":
                    return M(H, Z, ne);
                  case "JSXClosingElement":
                    return L(H, Z, ne);
                  case "JSXOpeningFragment":
                  case "JSXClosingFragment":
                    return Y(H, Z);
                  case "JSXEmptyExpression":
                    return O(H, Z);
                  case "JSXText":
                    throw new Error("JSXTest should be handled by JSXElement");
                  default:
                    throw new Error(`Unknown JSX node type: ${JSON.stringify(fe.type)}.`);
                }
            }
            var Q = ` 
\r	`, le = new RegExp("([" + Q + "]+)"), W = new RegExp("[^" + Q + "]"), X = (H) => H.replace(new RegExp("(?:^" + le.source + "|" + le.source + "$)"), "");
            function oe(H) {
              if (H.children.length === 0)
                return true;
              if (H.children.length > 1)
                return false;
              let Z = H.children[0];
              return A3(Z) && !ae(Z);
            }
            function ae(H) {
              return A3(H) && (W.test(F(H)) || !/\n/.test(F(H)));
            }
            function Ae(H) {
              return H.type === "JSXExpressionContainer" && A3(H.expression) && H.expression.value === " " && !R(H.expression);
            }
            function z(H) {
              let Z = H.getValue(), ne = H.getParentNode();
              if (!ne || !Z || !T(Z) || !T(ne))
                return false;
              let fe = ne.children.indexOf(Z), ge = null;
              for (let Ce = fe; Ce > 0; Ce--) {
                let _e = ne.children[Ce - 1];
                if (!(_e.type === "JSXText" && !ae(_e))) {
                  ge = _e;
                  break;
                }
              }
              return ge && ge.type === "JSXExpressionContainer" && ge.expression.type === "JSXEmptyExpression" && x(ge.expression);
            }
            n.exports = { hasJsxIgnoreComment: z, printJsx: se };
          } }), Dt = ee({ "src/language-js/print/misc.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t } = Ge(), { builders: { indent: s, join: a, line: r } } = qe(), { isFlowAnnotationComment: u } = Ke();
            function i(v) {
              let w = v.getValue();
              return !w.optional || w.type === "Identifier" && w === v.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
            }
            function l(v) {
              return v.getValue().definite || v.match(void 0, (w, T) => T === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
            }
            function c(v, w, T) {
              let F = v.getValue();
              return F.typeArguments ? T("typeArguments") : F.typeParameters ? T("typeParameters") : "";
            }
            function y(v, w, T) {
              let F = v.getValue();
              if (!F.typeAnnotation)
                return "";
              let A3 = v.getParentNode(), B = A3.type === "DeclareFunction" && A3.id === F;
              return u(w.originalText, F.typeAnnotation) ? [" /*: ", T("typeAnnotation"), " */"] : [B ? "" : ": ", T("typeAnnotation")];
            }
            function h(v, w, T) {
              return ["::", T("callee")];
            }
            function g(v, w, T) {
              let F = v.getValue();
              return t(F.modifiers) ? [a(" ", v.map(T, "modifiers")), " "] : "";
            }
            function p(v, w, T) {
              return v.type === "EmptyStatement" ? ";" : v.type === "BlockStatement" || T ? [" ", w] : s([r, w]);
            }
            function D(v, w, T) {
              return ["...", T("argument"), y(v, w, T)];
            }
            n.exports = { printOptionalToken: i, printDefiniteToken: l, printFunctionTypeParameters: c, printBindExpressionCallee: h, printTypeScriptModifiers: g, printTypeAnnotation: y, printRestSpread: D, adjustClause: p };
          } }), Qt = ee({ "src/language-js/print/array.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, hardline: r, group: u, indent: i, ifBreak: l, fill: c } } = qe(), { getLast: y, hasNewline: h } = Ge(), { shouldPrintComma: g, hasComment: p, CommentCheckFlags: D, isNextLineEmpty: v, isNumericLiteral: w, isSignedNumericLiteral: T } = Ke(), { locStart: F } = it(), { printOptionalToken: A3, printTypeAnnotation: B } = Dt();
            function I(x, m, E) {
              let o = x.getValue(), d = [], C = o.type === "TupleExpression" ? "#[" : "[", _ = "]";
              if (o.elements.length === 0)
                p(o, D.Dangling) ? d.push(u([C, t(x, m), a, _])) : d.push(C, _);
              else {
                let b = y(o.elements), N = !(b && b.type === "RestElement"), k = b === null, $ = Symbol("array"), M = !m.__inJestEach && o.elements.length > 1 && o.elements.every((L, Y, V) => {
                  let O = L && L.type;
                  if (O !== "ArrayExpression" && O !== "ObjectExpression")
                    return false;
                  let K = V[Y + 1];
                  if (K && O !== K.type)
                    return false;
                  let se = O === "ArrayExpression" ? "elements" : "properties";
                  return L[se] && L[se].length > 1;
                }), q = P2(o, m), J = N ? k ? "," : g(m) ? q ? l(",", "", { groupId: $ }) : l(",") : "" : "";
                d.push(u([C, i([a, q ? f(x, m, E, J) : [R(x, m, "elements", E), J], t(x, m, true)]), a, _], { shouldBreak: M, id: $ }));
              }
              return d.push(A3(x), B(x, m, E)), d;
            }
            function P2(x, m) {
              return x.elements.length > 1 && x.elements.every((E) => E && (w(E) || T(E) && !p(E.argument)) && !p(E, D.Trailing | D.Line, (o) => !h(m.originalText, F(o), { backwards: true })));
            }
            function R(x, m, E, o) {
              let d = [], C = [];
              return x.each((_) => {
                d.push(C, u(o())), C = [",", s], _.getValue() && v(_.getValue(), m) && C.push(a);
              }, E), d;
            }
            function f(x, m, E, o) {
              let d = [];
              return x.each((C, _, b) => {
                let N = _ === b.length - 1;
                d.push([E(), N ? o : ","]), N || d.push(v(C.getValue(), m) ? [r, r] : p(b[_ + 1], D.Leading | D.Line) ? r : s);
              }, "elements"), c(d);
            }
            n.exports = { printArray: I, printArrayItems: R, isConciselyPrintedArray: P2 };
          } }), to = ee({ "src/language-js/print/call-arguments.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { getLast: s, getPenultimate: a } = Ge(), { getFunctionParameters: r, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: l, isJsxNode: c, isLongCurriedCallExpression: y, shouldPrintComma: h, getCallArguments: g, iterateCallArgumentsPath: p, isNextLineEmpty: D, isCallExpression: v, isStringLiteral: w, isObjectProperty: T, isTSTypeExpression: F } = Ke(), { builders: { line: A3, hardline: B, softline: I, group: P2, indent: R, conditionalGroup: f, ifBreak: x, breakParent: m }, utils: { willBreak: E } } = qe(), { ArgExpansionBailout: o } = Kt(), { isConciselyPrintedArray: d } = Qt();
            function C(q, J, L) {
              let Y = q.getValue(), V = Y.type === "ImportExpression", O = g(Y);
              if (O.length === 0)
                return ["(", t(q, J, true), ")"];
              if (k(O))
                return ["(", L(["arguments", 0]), ", ", L(["arguments", 1]), ")"];
              let K = false, se = false, Q = O.length - 1, le = [];
              p(q, (z, H) => {
                let Z = z.getNode(), ne = [L()];
                H === Q || (D(Z, J) ? (H === 0 && (se = true), K = true, ne.push(",", B, B)) : ne.push(",", A3)), le.push(ne);
              });
              let W = !(V || Y.callee && Y.callee.type === "Import") && h(J, "all") ? "," : "";
              function X() {
                return P2(["(", R([A3, ...le]), W, A3, ")"], { shouldBreak: true });
              }
              if (K || q.getParentNode().type !== "Decorator" && l(O))
                return X();
              let oe = N(O), ae = b(O, J);
              if (oe || ae) {
                if (oe ? le.slice(1).some(E) : le.slice(0, -1).some(E))
                  return X();
                let z = [];
                try {
                  q.try(() => {
                    p(q, (H, Z) => {
                      oe && Z === 0 && (z = [[L([], { expandFirstArg: true }), le.length > 1 ? "," : "", se ? B : A3, se ? B : ""], ...le.slice(1)]), ae && Z === Q && (z = [...le.slice(0, -1), L([], { expandLastArg: true })]);
                    });
                  });
                } catch (H) {
                  if (H instanceof o)
                    return X();
                  throw H;
                }
                return [le.some(E) ? m : "", f([["(", ...z, ")"], oe ? ["(", P2(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...le.slice(0, -1), P2(s(z), { shouldBreak: true }), ")"], X()])];
              }
              let Ae = ["(", R([I, ...le]), x(W), I, ")"];
              return y(q) ? Ae : P2(Ae, { shouldBreak: le.some(E) || K });
            }
            function _(q) {
              let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              return q.type === "ObjectExpression" && (q.properties.length > 0 || u(q)) || q.type === "ArrayExpression" && (q.elements.length > 0 || u(q)) || q.type === "TSTypeAssertion" && _(q.expression) || F(q) && _(q.expression) || q.type === "FunctionExpression" || q.type === "ArrowFunctionExpression" && (!q.returnType || !q.returnType.typeAnnotation || q.returnType.typeAnnotation.type !== "TSTypeReference" || $(q.body)) && (q.body.type === "BlockStatement" || q.body.type === "ArrowFunctionExpression" && _(q.body, true) || q.body.type === "ObjectExpression" || q.body.type === "ArrayExpression" || !J && (v(q.body) || q.body.type === "ConditionalExpression") || c(q.body)) || q.type === "DoExpression" || q.type === "ModuleExpression";
            }
            function b(q, J) {
              let L = s(q), Y = a(q);
              return !u(L, i.Leading) && !u(L, i.Trailing) && _(L) && (!Y || Y.type !== L.type) && (q.length !== 2 || Y.type !== "ArrowFunctionExpression" || L.type !== "ArrayExpression") && !(q.length > 1 && L.type === "ArrayExpression" && d(L, J));
            }
            function N(q) {
              if (q.length !== 2)
                return false;
              let [J, L] = q;
              return J.type === "ModuleExpression" && M(L) ? true : !u(J) && (J.type === "FunctionExpression" || J.type === "ArrowFunctionExpression" && J.body.type === "BlockStatement") && L.type !== "FunctionExpression" && L.type !== "ArrowFunctionExpression" && L.type !== "ConditionalExpression" && !_(L);
            }
            function k(q) {
              return q.length === 2 && q[0].type === "ArrowFunctionExpression" && r(q[0]).length === 0 && q[0].body.type === "BlockStatement" && q[1].type === "ArrayExpression" && !q.some((J) => u(J));
            }
            function $(q) {
              return q.type === "BlockStatement" && (q.body.some((J) => J.type !== "EmptyStatement") || u(q, i.Dangling));
            }
            function M(q) {
              return q.type === "ObjectExpression" && q.properties.length === 1 && T(q.properties[0]) && q.properties[0].key.type === "Identifier" && q.properties[0].key.name === "type" && w(q.properties[0].value) && q.properties[0].value.value === "module";
            }
            n.exports = C;
          } }), ro = ee({ "src/language-js/print/member.js"(e, n) {
            "use strict";
            re();
            var { builders: { softline: t, group: s, indent: a, label: r } } = qe(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: l } = Ke(), { printOptionalToken: c } = Dt();
            function y(g, p, D) {
              let v = g.getValue(), w = g.getParentNode(), T, F = 0;
              do
                T = g.getParentNode(F), F++;
              while (T && (i(T) || T.type === "TSNonNullExpression"));
              let A3 = D("object"), B = h(g, p, D), I = T && (T.type === "NewExpression" || T.type === "BindExpression" || T.type === "AssignmentExpression" && T.left.type !== "Identifier") || v.computed || v.object.type === "Identifier" && v.property.type === "Identifier" && !i(w) || (w.type === "AssignmentExpression" || w.type === "VariableDeclarator") && (l(v.object) && v.object.arguments.length > 0 || v.object.type === "TSNonNullExpression" && l(v.object.expression) && v.object.expression.arguments.length > 0 || A3.label === "member-chain");
              return r(A3.label === "member-chain" ? "member-chain" : "member", [A3, I ? B : s(a([t, B]))]);
            }
            function h(g, p, D) {
              let v = D("property"), w = g.getValue(), T = c(g);
              return w.computed ? !w.property || u(w.property) ? [T, "[", v, "]"] : s([T, "[", a([t, v]), t, "]"]) : [T, ".", v];
            }
            n.exports = { printMemberExpression: y, printMemberLookup: h };
          } }), $m = ee({ "src/language-js/print/member-chain.js"(e, n) {
            "use strict";
            re();
            var { printComments: t } = et(), { getLast: s, isNextLineEmptyAfterIndex: a, getNextNonSpaceNonCommentCharacterIndex: r } = Ge(), u = Ot(), { isCallExpression: i, isMemberExpression: l, isFunctionOrArrowExpression: c, isLongCurriedCallExpression: y, isMemberish: h, isNumericLiteral: g, isSimpleCallArgument: p, hasComment: D, CommentCheckFlags: v, isNextLineEmpty: w } = Ke(), { locEnd: T } = it(), { builders: { join: F, hardline: A3, group: B, indent: I, conditionalGroup: P2, breakParent: R, label: f }, utils: { willBreak: x } } = qe(), m = to(), { printMemberLookup: E } = ro(), { printOptionalToken: o, printFunctionTypeParameters: d, printBindExpressionCallee: C } = Dt();
            function _(b, N, k) {
              let $ = b.getParentNode(), M = !$ || $.type === "ExpressionStatement", q = [];
              function J(ie) {
                let { originalText: ve } = N, ce = r(ve, ie, T);
                return ve.charAt(ce) === ")" ? ce !== false && a(ve, ce + 1) : w(ie, N);
              }
              function L(ie) {
                let ve = ie.getValue();
                i(ve) && (h(ve.callee) || i(ve.callee)) ? (q.unshift({ node: ve, printed: [t(ie, [o(ie), d(ie, N, k), m(ie, N, k)], N), J(ve) ? A3 : ""] }), ie.call((ce) => L(ce), "callee")) : h(ve) ? (q.unshift({ node: ve, needsParens: u(ie, N), printed: t(ie, l(ve) ? E(ie, N, k) : C(ie, N, k), N) }), ie.call((ce) => L(ce), "object")) : ve.type === "TSNonNullExpression" ? (q.unshift({ node: ve, printed: t(ie, "!", N) }), ie.call((ce) => L(ce), "expression")) : q.unshift({ node: ve, printed: k() });
              }
              let Y = b.getValue();
              q.unshift({ node: Y, printed: [o(b), d(b, N, k), m(b, N, k)] }), Y.callee && b.call((ie) => L(ie), "callee");
              let V = [], O = [q[0]], K = 1;
              for (; K < q.length && (q[K].node.type === "TSNonNullExpression" || i(q[K].node) || l(q[K].node) && q[K].node.computed && g(q[K].node.property)); ++K)
                O.push(q[K]);
              if (!i(q[0].node))
                for (; K + 1 < q.length && h(q[K].node) && h(q[K + 1].node); ++K)
                  O.push(q[K]);
              V.push(O), O = [];
              let se = false;
              for (; K < q.length; ++K) {
                if (se && h(q[K].node)) {
                  if (q[K].node.computed && g(q[K].node.property)) {
                    O.push(q[K]);
                    continue;
                  }
                  V.push(O), O = [], se = false;
                }
                (i(q[K].node) || q[K].node.type === "ImportExpression") && (se = true), O.push(q[K]), D(q[K].node, v.Trailing) && (V.push(O), O = [], se = false);
              }
              O.length > 0 && V.push(O);
              function Q(ie) {
                return /^[A-Z]|^[$_]+$/.test(ie);
              }
              function le(ie) {
                return ie.length <= N.tabWidth;
              }
              function W(ie) {
                let ve = ie[1].length > 0 && ie[1][0].node.computed;
                if (ie[0].length === 1) {
                  let U = ie[0][0].node;
                  return U.type === "ThisExpression" || U.type === "Identifier" && (Q(U.name) || M && le(U.name) || ve);
                }
                let ce = s(ie[0]).node;
                return l(ce) && ce.property.type === "Identifier" && (Q(ce.property.name) || ve);
              }
              let X = V.length >= 2 && !D(V[1][0].node) && W(V);
              function oe(ie) {
                let ve = ie.map((ce) => ce.printed);
                return ie.length > 0 && s(ie).needsParens ? ["(", ...ve, ")"] : ve;
              }
              function ae(ie) {
                return ie.length === 0 ? "" : I(B([A3, F(A3, ie.map(oe))]));
              }
              let Ae = V.map(oe), z = Ae, H = X ? 3 : 2, Z = V.flat(), ne = Z.slice(1, -1).some((ie) => D(ie.node, v.Leading)) || Z.slice(0, -1).some((ie) => D(ie.node, v.Trailing)) || V[H] && D(V[H][0].node, v.Leading);
              if (V.length <= H && !ne)
                return y(b) ? z : B(z);
              let fe = s(V[X ? 1 : 0]).node, ge = !i(fe) && J(fe), Ce = [oe(V[0]), X ? V.slice(1, 2).map(oe) : "", ge ? A3 : "", ae(V.slice(X ? 2 : 1))], _e = q.map((ie) => {
                let { node: ve } = ie;
                return ve;
              }).filter(i);
              function Oe() {
                let ie = s(s(V)).node, ve = s(Ae);
                return i(ie) && x(ve) && _e.slice(0, -1).some((ce) => ce.arguments.some(c));
              }
              let pe;
              return ne || _e.length > 2 && _e.some((ie) => !ie.arguments.every((ve) => p(ve, 0))) || Ae.slice(0, -1).some(x) || Oe() ? pe = B(Ce) : pe = [x(z) || ge ? R : "", P2([z, Ce])], f("member-chain", pe);
            }
            n.exports = _;
          } }), no = ee({ "src/language-js/print/call-expression.js"(e, n) {
            "use strict";
            re();
            var { builders: { join: t, group: s } } = qe(), a = Ot(), { getCallArguments: r, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: l, isStringLiteral: c, isTemplateOnItsOwnLine: y, isTestCall: h, iterateCallArgumentsPath: g } = Ke(), p = $m(), D = to(), { printOptionalToken: v, printFunctionTypeParameters: w } = Dt();
            function T(A3, B, I) {
              let P2 = A3.getValue(), R = A3.getParentNode(), f = P2.type === "NewExpression", x = P2.type === "ImportExpression", m = v(A3), E = r(P2);
              if (E.length > 0 && (!x && !f && F(P2, R) || E.length === 1 && y(E[0], B.originalText) || !f && h(P2, R))) {
                let C = [];
                return g(A3, () => {
                  C.push(I());
                }), [f ? "new " : "", I("callee"), m, w(A3, B, I), "(", t(", ", C), ")"];
              }
              let o = (B.parser === "babel" || B.parser === "babel-flow") && P2.callee && P2.callee.type === "Identifier" && u(P2.callee.trailingComments);
              if (o && (P2.callee.trailingComments[0].printed = true), !x && !f && l(P2.callee) && !A3.call((C) => a(C, B), "callee"))
                return p(A3, B, I);
              let d = [f ? "new " : "", x ? "import" : I("callee"), m, o ? `/*:: ${P2.callee.trailingComments[0].value.slice(2).trim()} */` : "", w(A3, B, I), D(A3, B, I)];
              return x || i(P2.callee) ? s(d) : d;
            }
            function F(A3, B) {
              if (A3.callee.type !== "Identifier")
                return false;
              if (A3.callee.name === "require")
                return true;
              if (A3.callee.name === "define") {
                let I = r(A3);
                return B.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && c(I[0]) && I[1].type === "ArrayExpression");
              }
              return false;
            }
            n.exports = { printCallExpression: T };
          } }), Zt = ee({ "src/language-js/print/assignment.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t, getStringWidth: s } = Ge(), { builders: { line: a, group: r, indent: u, indentIfBreak: i, lineSuffixBoundary: l }, utils: { cleanDoc: c, willBreak: y, canBreak: h } } = qe(), { hasLeadingOwnLineComment: g, isBinaryish: p, isStringLiteral: D, isLiteral: v, isNumericLiteral: w, isCallExpression: T, isMemberExpression: F, getCallArguments: A3, rawText: B, hasComment: I, isSignedNumericLiteral: P2, isObjectProperty: R } = Ke(), { shouldInlineLogicalExpression: f } = Jn(), { printCallExpression: x } = no();
            function m(W, X, oe, ae, Ae, z) {
              let H = d(W, X, oe, ae, z), Z = oe(z, { assignmentLayout: H });
              switch (H) {
                case "break-after-operator":
                  return r([r(ae), Ae, r(u([a, Z]))]);
                case "never-break-after-operator":
                  return r([r(ae), Ae, " ", Z]);
                case "fluid": {
                  let ne = Symbol("assignment");
                  return r([r(ae), Ae, r(u(a), { id: ne }), l, i(Z, { groupId: ne })]);
                }
                case "break-lhs":
                  return r([ae, Ae, " ", r(Z)]);
                case "chain":
                  return [r(ae), Ae, a, Z];
                case "chain-tail":
                  return [r(ae), Ae, u([a, Z])];
                case "chain-tail-arrow-chain":
                  return [r(ae), Ae, Z];
                case "only-left":
                  return ae;
              }
            }
            function E(W, X, oe) {
              let ae = W.getValue();
              return m(W, X, oe, oe("left"), [" ", ae.operator], "right");
            }
            function o(W, X, oe) {
              return m(W, X, oe, oe("id"), " =", "init");
            }
            function d(W, X, oe, ae, Ae) {
              let z = W.getValue(), H = z[Ae];
              if (!H)
                return "only-left";
              let Z = !b(H);
              if (W.match(b, N, (Ce) => !Z || Ce.type !== "ExpressionStatement" && Ce.type !== "VariableDeclaration"))
                return Z ? H.type === "ArrowFunctionExpression" && H.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
              if (!Z && b(H.right) || g(X.originalText, H))
                return "break-after-operator";
              if (H.type === "CallExpression" && H.callee.name === "require" || X.parser === "json5" || X.parser === "json")
                return "never-break-after-operator";
              if (_(z) || k(z) || q(z) || J(z) && h(ae))
                return "break-lhs";
              let ge = se(z, ae, X);
              return W.call(() => C(W, X, oe, ge), Ae) ? "break-after-operator" : ge || H.type === "TemplateLiteral" || H.type === "TaggedTemplateExpression" || H.type === "BooleanLiteral" || w(H) || H.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
            }
            function C(W, X, oe, ae) {
              let Ae = W.getValue();
              if (p(Ae) && !f(Ae))
                return true;
              switch (Ae.type) {
                case "StringLiteralTypeAnnotation":
                case "SequenceExpression":
                  return true;
                case "ConditionalExpression": {
                  let { test: Z } = Ae;
                  return p(Z) && !f(Z);
                }
                case "ClassExpression":
                  return t(Ae.decorators);
              }
              if (ae)
                return false;
              let z = Ae, H = [];
              for (; ; )
                if (z.type === "UnaryExpression")
                  z = z.argument, H.push("argument");
                else if (z.type === "TSNonNullExpression")
                  z = z.expression, H.push("expression");
                else
                  break;
              return !!(D(z) || W.call(() => V(W, X, oe), ...H));
            }
            function _(W) {
              if (N(W)) {
                let X = W.left || W.id;
                return X.type === "ObjectPattern" && X.properties.length > 2 && X.properties.some((oe) => R(oe) && (!oe.shorthand || oe.value && oe.value.type === "AssignmentPattern"));
              }
              return false;
            }
            function b(W) {
              return W.type === "AssignmentExpression";
            }
            function N(W) {
              return b(W) || W.type === "VariableDeclarator";
            }
            function k(W) {
              let X = $(W);
              if (t(X)) {
                let oe = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
                if (X.length > 1 && X.some((ae) => ae[oe] || ae.default))
                  return true;
              }
              return false;
            }
            function $(W) {
              return M(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
            }
            function M(W) {
              return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
            }
            function q(W) {
              if (W.type !== "VariableDeclarator")
                return false;
              let { typeAnnotation: X } = W.id;
              if (!X || !X.typeAnnotation)
                return false;
              let oe = L(X.typeAnnotation);
              return t(oe) && oe.length > 1 && oe.some((ae) => t(L(ae)) || ae.type === "TSConditionalType");
            }
            function J(W) {
              return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
            }
            function L(W) {
              return Y(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
            }
            function Y(W) {
              return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
            }
            function V(W, X, oe) {
              let ae = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Ae = W.getValue(), z = () => V(W, X, oe, true);
              if (Ae.type === "TSNonNullExpression")
                return W.call(z, "expression");
              if (T(Ae)) {
                if (x(W, X, oe).label === "member-chain")
                  return false;
                let Z = A3(Ae);
                return !(Z.length === 0 || Z.length === 1 && K(Z[0], X)) || Q(Ae, oe) ? false : W.call(z, "callee");
              }
              return F(Ae) ? W.call(z, "object") : ae && (Ae.type === "Identifier" || Ae.type === "ThisExpression");
            }
            var O = 0.25;
            function K(W, X) {
              let { printWidth: oe } = X;
              if (I(W))
                return false;
              let ae = oe * O;
              if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= ae || P2(W) && !I(W.argument))
                return true;
              let Ae = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
              return Ae ? Ae.length <= ae : D(W) ? B(W).length <= ae : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ae && !W.quasis[0].value.raw.includes(`
`) : v(W);
            }
            function se(W, X, oe) {
              if (!R(W))
                return false;
              X = c(X);
              let ae = 3;
              return typeof X == "string" && s(X) < oe.tabWidth + ae;
            }
            function Q(W, X) {
              let oe = le(W);
              if (t(oe)) {
                if (oe.length > 1)
                  return true;
                if (oe.length === 1) {
                  let Ae = oe[0];
                  if (Ae.type === "TSUnionType" || Ae.type === "UnionTypeAnnotation" || Ae.type === "TSIntersectionType" || Ae.type === "IntersectionTypeAnnotation" || Ae.type === "TSTypeLiteral" || Ae.type === "ObjectTypeAnnotation")
                    return true;
                }
                let ae = W.typeParameters ? "typeParameters" : "typeArguments";
                if (y(X(ae)))
                  return true;
              }
              return false;
            }
            function le(W) {
              return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
            }
            n.exports = { printVariableDeclarator: o, printAssignmentExpression: E, printAssignment: m, isArrowFunctionVariableDeclarator: J };
          } }), kr = ee({ "src/language-js/print/function-parameters.js"(e, n) {
            "use strict";
            re();
            var { getNextNonSpaceNonCommentCharacter: t } = Ge(), { printDanglingComments: s } = et(), { builders: { line: a, hardline: r, softline: u, group: i, indent: l, ifBreak: c }, utils: { removeLines: y, willBreak: h } } = qe(), { getFunctionParameters: g, iterateFunctionParametersPath: p, isSimpleType: D, isTestCall: v, isTypeAnnotationAFunction: w, isObjectType: T, isObjectTypePropertyAFunction: F, hasRestParameter: A3, shouldPrintComma: B, hasComment: I, isNextLineEmpty: P2 } = Ke(), { locEnd: R } = it(), { ArgExpansionBailout: f } = Kt(), { printFunctionTypeParameters: x } = Dt();
            function m(C, _, b, N, k) {
              let $ = C.getValue(), M = g($), q = k ? x(C, b, _) : "";
              if (M.length === 0)
                return [q, "(", s(C, b, true, (se) => t(b.originalText, se, R) === ")"), ")"];
              let J = C.getParentNode(), L = v(J), Y = E($), V = [];
              if (p(C, (se, Q) => {
                let le = Q === M.length - 1;
                le && $.rest && V.push("..."), V.push(_()), !le && (V.push(","), L || Y ? V.push(" ") : P2(M[Q], b) ? V.push(r, r) : V.push(a));
              }), N) {
                if (h(q) || h(V))
                  throw new f();
                return i([y(q), "(", y(V), ")"]);
              }
              let O = M.every((se) => !se.decorators);
              return Y && O ? [q, "(", ...V, ")"] : L ? [q, "(", ...V, ")"] : (F(J) || w(J) || J.type === "TypeAlias" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || J.type === "IntersectionTypeAnnotation" || J.type === "FunctionTypeAnnotation" && J.returnType === $) && M.length === 1 && M[0].name === null && $.this !== M[0] && M[0].typeAnnotation && $.typeParameters === null && D(M[0].typeAnnotation) && !$.rest ? b.arrowParens === "always" ? ["(", ...V, ")"] : V : [q, "(", l([u, ...V]), c(!A3($) && B(b, "all") ? "," : ""), u, ")"];
            }
            function E(C) {
              if (!C)
                return false;
              let _ = g(C);
              if (_.length !== 1)
                return false;
              let [b] = _;
              return !I(b) && (b.type === "ObjectPattern" || b.type === "ArrayPattern" || b.type === "Identifier" && b.typeAnnotation && (b.typeAnnotation.type === "TypeAnnotation" || b.typeAnnotation.type === "TSTypeAnnotation") && T(b.typeAnnotation.typeAnnotation) || b.type === "FunctionTypeParam" && T(b.typeAnnotation) || b.type === "AssignmentPattern" && (b.left.type === "ObjectPattern" || b.left.type === "ArrayPattern") && (b.right.type === "Identifier" || b.right.type === "ObjectExpression" && b.right.properties.length === 0 || b.right.type === "ArrayExpression" && b.right.elements.length === 0));
            }
            function o(C) {
              let _;
              return C.returnType ? (_ = C.returnType, _.typeAnnotation && (_ = _.typeAnnotation)) : C.typeAnnotation && (_ = C.typeAnnotation), _;
            }
            function d(C, _) {
              let b = o(C);
              if (!b)
                return false;
              let N = C.typeParameters && C.typeParameters.params;
              if (N) {
                if (N.length > 1)
                  return false;
                if (N.length === 1) {
                  let k = N[0];
                  if (k.constraint || k.default)
                    return false;
                }
              }
              return g(C).length === 1 && (T(b) || h(_));
            }
            n.exports = { printFunctionParameters: m, shouldHugFunctionParameters: E, shouldGroupFunctionParameters: d };
          } }), Lr = ee({ "src/language-js/print/type-annotation.js"(e, n) {
            "use strict";
            re();
            var { printComments: t, printDanglingComments: s } = et(), { isNonEmptyArray: a } = Ge(), { builders: { group: r, join: u, line: i, softline: l, indent: c, align: y, ifBreak: h } } = qe(), g = Ot(), { locStart: p } = it(), { isSimpleType: D, isObjectType: v, hasLeadingOwnLineComment: w, isObjectTypePropertyAFunction: T, shouldPrintComma: F } = Ke(), { printAssignment: A3 } = Zt(), { printFunctionParameters: B, shouldGroupFunctionParameters: I } = kr(), { printArrayItems: P2 } = Qt();
            function R(b) {
              if (D(b) || v(b))
                return true;
              if (b.type === "UnionTypeAnnotation" || b.type === "TSUnionType") {
                let N = b.types.filter(($) => $.type === "VoidTypeAnnotation" || $.type === "TSVoidKeyword" || $.type === "NullLiteralTypeAnnotation" || $.type === "TSNullKeyword").length, k = b.types.some(($) => $.type === "ObjectTypeAnnotation" || $.type === "TSTypeLiteral" || $.type === "GenericTypeAnnotation" || $.type === "TSTypeReference");
                if (b.types.length - 1 === N && k)
                  return true;
              }
              return false;
            }
            function f(b, N, k) {
              let $ = N.semi ? ";" : "", M = b.getValue(), q = [];
              return q.push("opaque type ", k("id"), k("typeParameters")), M.supertype && q.push(": ", k("supertype")), M.impltype && q.push(" = ", k("impltype")), q.push($), q;
            }
            function x(b, N, k) {
              let $ = N.semi ? ";" : "", M = b.getValue(), q = [];
              M.declare && q.push("declare "), q.push("type ", k("id"), k("typeParameters"));
              let J = M.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
              return [A3(b, N, k, q, " =", J), $];
            }
            function m(b, N, k) {
              let $ = b.getValue(), M = b.map(k, "types"), q = [], J = false;
              for (let L = 0; L < M.length; ++L)
                L === 0 ? q.push(M[L]) : v($.types[L - 1]) && v($.types[L]) ? q.push([" & ", J ? c(M[L]) : M[L]]) : !v($.types[L - 1]) && !v($.types[L]) ? q.push(c([" &", i, M[L]])) : (L > 1 && (J = true), q.push(" & ", L > 1 ? c(M[L]) : M[L]));
              return r(q);
            }
            function E(b, N, k) {
              let $ = b.getValue(), M = b.getParentNode(), q = M.type !== "TypeParameterInstantiation" && M.type !== "TSTypeParameterInstantiation" && M.type !== "GenericTypeAnnotation" && M.type !== "TSTypeReference" && M.type !== "TSTypeAssertion" && M.type !== "TupleTypeAnnotation" && M.type !== "TSTupleType" && !(M.type === "FunctionTypeParam" && !M.name && b.getParentNode(1).this !== M) && !((M.type === "TypeAlias" || M.type === "VariableDeclarator" || M.type === "TSTypeAliasDeclaration") && w(N.originalText, $)), J = R($), L = b.map((O) => {
                let K = k();
                return J || (K = y(2, K)), t(O, K, N);
              }, "types");
              if (J)
                return u(" | ", L);
              let Y = q && !w(N.originalText, $), V = [h([Y ? i : "", "| "]), u([i, "| "], L)];
              return g(b, N) ? r([c(V), l]) : M.type === "TupleTypeAnnotation" && M.types.length > 1 || M.type === "TSTupleType" && M.elementTypes.length > 1 ? r([c([h(["(", l]), V]), l, h(")")]) : r(q ? c(V) : V);
            }
            function o(b, N, k) {
              let $ = b.getValue(), M = [], q = b.getParentNode(0), J = b.getParentNode(1), L = b.getParentNode(2), Y = $.type === "TSFunctionType" || !((q.type === "ObjectTypeProperty" || q.type === "ObjectTypeInternalSlot") && !q.variance && !q.optional && p(q) === p($) || q.type === "ObjectTypeCallProperty" || L && L.type === "DeclareFunction"), V = Y && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation"), O = V && Y && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation") && J.type === "ArrowFunctionExpression";
              T(q) && (Y = true, V = true), O && M.push("(");
              let K = B(b, k, N, false, true), se = $.returnType || $.predicate || $.typeAnnotation ? [Y ? " => " : ": ", k("returnType"), k("predicate"), k("typeAnnotation")] : "", Q = I($, se);
              return M.push(Q ? r(K) : K), se && M.push(se), O && M.push(")"), r(M);
            }
            function d(b, N, k) {
              let $ = b.getValue(), M = $.type === "TSTupleType" ? "elementTypes" : "types", q = $[M], J = a(q), L = J ? l : "";
              return r(["[", c([L, P2(b, N, M, k)]), h(J && F(N, "all") ? "," : ""), s(b, N, true), L, "]"]);
            }
            function C(b, N, k) {
              let $ = b.getValue(), M = $.type === "OptionalIndexedAccessType" && $.optional ? "?.[" : "[";
              return [k("objectType"), M, k("indexType"), "]"];
            }
            function _(b, N, k) {
              let $ = b.getValue();
              return [$.postfix ? "" : k, N("typeAnnotation"), $.postfix ? k : ""];
            }
            n.exports = { printOpaqueType: f, printTypeAlias: x, printIntersectionType: m, printUnionType: E, printFunctionType: o, printTupleType: d, printIndexedAccessType: C, shouldHugType: R, printJSDocType: _ };
          } }), jr = ee({ "src/language-js/print/type-parameters.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { builders: { join: s, line: a, hardline: r, softline: u, group: i, indent: l, ifBreak: c } } = qe(), { isTestCall: y, hasComment: h, CommentCheckFlags: g, isTSXFile: p, shouldPrintComma: D, getFunctionParameters: v, isObjectType: w } = Ke(), { createGroupIdMapper: T } = Ge(), { shouldHugType: F } = Lr(), { isArrowFunctionVariableDeclarator: A3 } = Zt(), B = T("typeParameters");
            function I(f, x, m, E) {
              let o = f.getValue();
              if (!o[E])
                return "";
              if (!Array.isArray(o[E]))
                return m(E);
              let d = f.getNode(2), C = d && y(d);
              if (!f.match((k) => !(k[E].length === 1 && w(k[E][0])), void 0, (k, $) => $ === "typeAnnotation", (k) => k.type === "Identifier", A3) && (C || o[E].length === 0 || o[E].length === 1 && (o[E][0].type === "NullableTypeAnnotation" || F(o[E][0]))))
                return ["<", s(", ", f.map(m, E)), P2(f, x), ">"];
              let N = o.type === "TSTypeParameterInstantiation" ? "" : v(o).length === 1 && p(x) && !o[E][0].constraint && f.getParentNode().type === "ArrowFunctionExpression" ? "," : D(x, "all") ? c(",") : "";
              return i(["<", l([u, s([",", a], f.map(m, E))]), N, u, ">"], { id: B(o) });
            }
            function P2(f, x) {
              let m = f.getValue();
              if (!h(m, g.Dangling))
                return "";
              let E = !h(m, g.Line), o = t(f, x, E);
              return E ? o : [o, r];
            }
            function R(f, x, m) {
              let E = f.getValue(), o = [], d = f.getParentNode();
              return d.type === "TSMappedType" ? (o.push("[", m("name")), E.constraint && o.push(" in ", m("constraint")), d.nameType && o.push(" as ", f.callParent(() => m("nameType"))), o.push("]"), o) : (E.variance && o.push(m("variance")), E.in && o.push("in "), E.out && o.push("out "), o.push(m("name")), E.bound && o.push(": ", m("bound")), E.constraint && o.push(" extends ", m("constraint")), E.default && o.push(" = ", m("default")), o);
            }
            n.exports = { printTypeParameter: R, printTypeParameters: I, getTypeParametersGroupId: B };
          } }), er = ee({ "src/language-js/print/property.js"(e, n) {
            "use strict";
            re();
            var { printComments: t } = et(), { printString: s, printNumber: a } = Ge(), { isNumericLiteral: r, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: l, rawText: c } = Ke(), { printAssignment: y } = Zt(), h = /* @__PURE__ */ new WeakMap();
            function g(D, v, w) {
              let T = D.getNode();
              if (T.computed)
                return ["[", w("key"), "]"];
              let F = D.getParentNode(), { key: A3 } = T;
              if (T.type === "ClassPrivateProperty" && A3.type === "Identifier")
                return ["#", w("key")];
              if (v.quoteProps === "consistent" && !h.has(F)) {
                let B = (F.properties || F.body || F.members).some((I) => !I.computed && I.key && i(I.key) && !l(I, v));
                h.set(F, B);
              }
              if ((A3.type === "Identifier" || r(A3) && u(a(c(A3))) && String(A3.value) === a(c(A3)) && !(v.parser === "typescript" || v.parser === "babel-ts")) && (v.parser === "json" || v.quoteProps === "consistent" && h.get(F))) {
                let B = s(JSON.stringify(A3.type === "Identifier" ? A3.name : A3.value.toString()), v);
                return D.call((I) => t(I, B, v), "key");
              }
              return l(T, v) && (v.quoteProps === "as-needed" || v.quoteProps === "consistent" && !h.get(F)) ? D.call((B) => t(B, /^\d/.test(A3.value) ? a(A3.value) : A3.value, v), "key") : w("key");
            }
            function p(D, v, w) {
              return D.getValue().shorthand ? w("value") : y(D, v, w, g(D, v, w), ":", "value");
            }
            n.exports = { printProperty: p, printPropertyKey: g };
          } }), Or = ee({ "src/language-js/print/function.js"(e, n) {
            "use strict";
            re();
            var t = Yt(), { printDanglingComments: s, printCommentsSeparately: a } = et(), r = lt(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ge(), { builders: { line: i, softline: l, group: c, indent: y, ifBreak: h, hardline: g, join: p, indentIfBreak: D }, utils: { removeLines: v, willBreak: w } } = qe(), { ArgExpansionBailout: T } = Kt(), { getFunctionParameters: F, hasLeadingOwnLineComment: A3, isFlowAnnotationComment: B, isJsxNode: I, isTemplateOnItsOwnLine: P2, shouldPrintComma: R, startsWithNoLookaheadToken: f, isBinaryish: x, isLineComment: m, hasComment: E, getComments: o, CommentCheckFlags: d, isCallLikeExpression: C, isCallExpression: _, getCallArguments: b, hasNakedLeftSide: N, getLeftSide: k } = Ke(), { locEnd: $ } = it(), { printFunctionParameters: M, shouldGroupFunctionParameters: q } = kr(), { printPropertyKey: J } = er(), { printFunctionTypeParameters: L } = Dt();
            function Y(H, Z, ne, fe) {
              let ge = H.getValue(), Ce = false;
              if ((ge.type === "FunctionDeclaration" || ge.type === "FunctionExpression") && fe && fe.expandLastArg) {
                let ve = H.getParentNode();
                _(ve) && b(ve).length > 1 && (Ce = true);
              }
              let _e = [];
              ge.type === "TSDeclareFunction" && ge.declare && _e.push("declare "), ge.async && _e.push("async "), ge.generator ? _e.push("function* ") : _e.push("function "), ge.id && _e.push(Z("id"));
              let Oe = M(H, Z, ne, Ce), pe = X(H, Z, ne), ie = q(ge, pe);
              return _e.push(L(H, ne, Z), c([ie ? c(Oe) : Oe, pe]), ge.body ? " " : "", Z("body")), ne.semi && (ge.declare || !ge.body) && _e.push(";"), _e;
            }
            function V(H, Z, ne) {
              let fe = H.getNode(), { kind: ge } = fe, Ce = fe.value || fe, _e = [];
              return !ge || ge === "init" || ge === "method" || ge === "constructor" ? Ce.async && _e.push("async ") : (t.ok(ge === "get" || ge === "set"), _e.push(ge, " ")), Ce.generator && _e.push("*"), _e.push(J(H, Z, ne), fe.optional || fe.key.optional ? "?" : ""), fe === Ce ? _e.push(O(H, Z, ne)) : Ce.type === "FunctionExpression" ? _e.push(H.call((Oe) => O(Oe, Z, ne), "value")) : _e.push(ne("value")), _e;
            }
            function O(H, Z, ne) {
              let fe = H.getNode(), ge = M(H, ne, Z), Ce = X(H, ne, Z), _e = q(fe, Ce), Oe = [L(H, Z, ne), c([_e ? c(ge) : ge, Ce])];
              return fe.body ? Oe.push(" ", ne("body")) : Oe.push(Z.semi ? ";" : ""), Oe;
            }
            function K(H, Z, ne, fe) {
              let ge = H.getValue(), Ce = [];
              if (ge.async && Ce.push("async "), W(H, Z))
                Ce.push(ne(["params", 0]));
              else {
                let Oe = fe && (fe.expandLastArg || fe.expandFirstArg), pe = X(H, ne, Z);
                if (Oe) {
                  if (w(pe))
                    throw new T();
                  pe = c(v(pe));
                }
                Ce.push(c([M(H, ne, Z, Oe, true), pe]));
              }
              let _e = s(H, Z, true, (Oe) => {
                let pe = u(Z.originalText, Oe, $);
                return pe !== false && Z.originalText.slice(pe, pe + 2) === "=>";
              });
              return _e && Ce.push(" ", _e), Ce;
            }
            function se(H, Z, ne, fe, ge, Ce) {
              let _e = H.getName(), Oe = H.getParentNode(), pe = C(Oe) && _e === "callee", ie = Boolean(Z && Z.assignmentLayout), ve = Ce.body.type !== "BlockStatement" && Ce.body.type !== "ObjectExpression" && Ce.body.type !== "SequenceExpression", ce = pe && ve || Z && Z.assignmentLayout === "chain-tail-arrow-chain", U = Symbol("arrow-chain");
              return Ce.body.type === "SequenceExpression" && (ge = c(["(", y([l, ge]), l, ")"])), c([c(y([pe || ie ? l : "", c(p([" =>", i], ne), { shouldBreak: fe })]), { id: U, shouldBreak: ce }), " =>", D(ve ? y([i, ge]) : [" ", ge], { groupId: U }), pe ? h(l, "", { groupId: U }) : ""]);
            }
            function Q(H, Z, ne, fe) {
              let ge = H.getValue(), Ce = [], _e = [], Oe = false;
              if (function U() {
                let de = K(H, Z, ne, fe);
                if (Ce.length === 0)
                  Ce.push(de);
                else {
                  let { leading: De, trailing: he } = a(H, Z);
                  Ce.push([De, de]), _e.unshift(he);
                }
                Oe = Oe || ge.returnType && F(ge).length > 0 || ge.typeParameters || F(ge).some((De) => De.type !== "Identifier"), ge.body.type !== "ArrowFunctionExpression" || fe && fe.expandLastArg ? _e.unshift(ne("body", fe)) : (ge = ge.body, H.call(U, "body"));
              }(), Ce.length > 1)
                return se(H, fe, Ce, Oe, _e, ge);
              let pe = Ce;
              if (pe.push(" =>"), !A3(Z.originalText, ge.body) && (ge.body.type === "ArrayExpression" || ge.body.type === "ObjectExpression" || ge.body.type === "BlockStatement" || I(ge.body) || P2(ge.body, Z.originalText) || ge.body.type === "ArrowFunctionExpression" || ge.body.type === "DoExpression"))
                return c([...pe, " ", _e]);
              if (ge.body.type === "SequenceExpression")
                return c([...pe, c([" (", y([l, _e]), l, ")"])]);
              let ie = (fe && fe.expandLastArg || H.getParentNode().type === "JSXExpressionContainer") && !E(ge), ve = fe && fe.expandLastArg && R(Z, "all"), ce = ge.body.type === "ConditionalExpression" && !f(ge.body, false);
              return c([...pe, c([y([i, ce ? h("", "(") : "", _e, ce ? h("", ")") : ""]), ie ? [h(ve ? "," : ""), l] : ""])]);
            }
            function le(H) {
              let Z = F(H);
              return Z.length === 1 && !H.typeParameters && !E(H, d.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !E(Z[0]) && !Z[0].optional && !H.predicate && !H.returnType;
            }
            function W(H, Z) {
              if (Z.arrowParens === "always")
                return false;
              if (Z.arrowParens === "avoid") {
                let ne = H.getValue();
                return le(ne);
              }
              return false;
            }
            function X(H, Z, ne) {
              let fe = H.getValue(), ge = Z("returnType");
              if (fe.returnType && B(ne.originalText, fe.returnType))
                return [" /*: ", ge, " */"];
              let Ce = [ge];
              return fe.returnType && fe.returnType.typeAnnotation && Ce.unshift(": "), fe.predicate && Ce.push(fe.returnType ? " " : ": ", Z("predicate")), Ce;
            }
            function oe(H, Z, ne) {
              let fe = H.getValue(), ge = Z.semi ? ";" : "", Ce = [];
              fe.argument && (z(Z, fe.argument) ? Ce.push([" (", y([g, ne("argument")]), g, ")"]) : x(fe.argument) || fe.argument.type === "SequenceExpression" ? Ce.push(c([h(" (", " "), y([l, ne("argument")]), l, h(")")])) : Ce.push(" ", ne("argument")));
              let _e = o(fe), Oe = r(_e), pe = Oe && m(Oe);
              return pe && Ce.push(ge), E(fe, d.Dangling) && Ce.push(" ", s(H, Z, true)), pe || Ce.push(ge), Ce;
            }
            function ae(H, Z, ne) {
              return ["return", oe(H, Z, ne)];
            }
            function Ae(H, Z, ne) {
              return ["throw", oe(H, Z, ne)];
            }
            function z(H, Z) {
              if (A3(H.originalText, Z))
                return true;
              if (N(Z)) {
                let ne = Z, fe;
                for (; fe = k(ne); )
                  if (ne = fe, A3(H.originalText, ne))
                    return true;
              }
              return false;
            }
            n.exports = { printFunction: Y, printArrowFunction: Q, printMethod: V, printReturnStatement: ae, printThrowStatement: Ae, printMethodInternal: O, shouldPrintParamsWithoutParens: W };
          } }), zn = ee({ "src/language-js/print/decorators.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t, hasNewline: s } = Ge(), { builders: { line: a, hardline: r, join: u, breakParent: i, group: l } } = qe(), { locStart: c, locEnd: y } = it(), { getParentExportDeclaration: h } = Ke();
            function g(T, F, A3) {
              let B = T.getValue();
              return l([u(a, T.map(A3, "decorators")), v(B, F) ? r : a]);
            }
            function p(T, F, A3) {
              return [u(r, T.map(A3, "declaration", "decorators")), r];
            }
            function D(T, F, A3) {
              let B = T.getValue(), { decorators: I } = B;
              if (!t(I) || w(T.getParentNode()))
                return;
              let P2 = B.type === "ClassExpression" || B.type === "ClassDeclaration" || v(B, F);
              return [h(T) ? r : P2 ? i : "", u(a, T.map(A3, "decorators")), a];
            }
            function v(T, F) {
              return T.decorators.some((A3) => s(F.originalText, y(A3)));
            }
            function w(T) {
              if (T.type !== "ExportDefaultDeclaration" && T.type !== "ExportNamedDeclaration" && T.type !== "DeclareExportDeclaration")
                return false;
              let F = T.declaration && T.declaration.decorators;
              return t(F) && c(T) === c(F[0]);
            }
            n.exports = { printDecorators: D, printClassMemberDecorators: g, printDecoratorsBeforeExport: p, hasDecoratorsBeforeExport: w };
          } }), tr = ee({ "src/language-js/print/class.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t, createGroupIdMapper: s } = Ge(), { printComments: a, printDanglingComments: r } = et(), { builders: { join: u, line: i, hardline: l, softline: c, group: y, indent: h, ifBreak: g } } = qe(), { hasComment: p, CommentCheckFlags: D } = Ke(), { getTypeParametersGroupId: v } = jr(), { printMethod: w } = Or(), { printOptionalToken: T, printTypeAnnotation: F, printDefiniteToken: A3 } = Dt(), { printPropertyKey: B } = er(), { printAssignment: I } = Zt(), { printClassMemberDecorators: P2 } = zn();
            function R(b, N, k) {
              let $ = b.getValue(), M = [];
              $.declare && M.push("declare "), $.abstract && M.push("abstract "), M.push("class");
              let q = $.id && p($.id, D.Trailing) || $.typeParameters && p($.typeParameters, D.Trailing) || $.superClass && p($.superClass) || t($.extends) || t($.mixins) || t($.implements), J = [], L = [];
              if ($.id && J.push(" ", k("id")), J.push(k("typeParameters")), $.superClass) {
                let Y = [d(b, N, k), k("superTypeParameters")], V = b.call((O) => ["extends ", a(O, Y, N)], "superClass");
                q ? L.push(i, y(V)) : L.push(" ", V);
              } else
                L.push(o(b, N, k, "extends"));
              if (L.push(o(b, N, k, "mixins"), o(b, N, k, "implements")), q) {
                let Y;
                E($) ? Y = [...J, h(L)] : Y = h([...J, L]), M.push(y(Y, { id: f($) }));
              } else
                M.push(...J, ...L);
              return M.push(" ", k("body")), M;
            }
            var f = s("heritageGroup");
            function x(b) {
              return g(l, "", { groupId: f(b) });
            }
            function m(b) {
              return ["superClass", "extends", "mixins", "implements"].filter((N) => Boolean(b[N])).length > 1;
            }
            function E(b) {
              return b.typeParameters && !p(b.typeParameters, D.Trailing | D.Line) && !m(b);
            }
            function o(b, N, k, $) {
              let M = b.getValue();
              if (!t(M[$]))
                return "";
              let q = r(b, N, true, (J) => {
                let { marker: L } = J;
                return L === $;
              });
              return [E(M) ? g(" ", i, { groupId: v(M.typeParameters) }) : i, q, q && l, $, y(h([i, u([",", i], b.map(k, $))]))];
            }
            function d(b, N, k) {
              let $ = k("superClass");
              return b.getParentNode().type === "AssignmentExpression" ? y(g(["(", h([c, $]), c, ")"], $)) : $;
            }
            function C(b, N, k) {
              let $ = b.getValue(), M = [];
              return t($.decorators) && M.push(P2(b, N, k)), $.accessibility && M.push($.accessibility + " "), $.readonly && M.push("readonly "), $.declare && M.push("declare "), $.static && M.push("static "), ($.type === "TSAbstractMethodDefinition" || $.abstract) && M.push("abstract "), $.override && M.push("override "), M.push(w(b, N, k)), M;
            }
            function _(b, N, k) {
              let $ = b.getValue(), M = [], q = N.semi ? ";" : "";
              return t($.decorators) && M.push(P2(b, N, k)), $.accessibility && M.push($.accessibility + " "), $.declare && M.push("declare "), $.static && M.push("static "), ($.type === "TSAbstractPropertyDefinition" || $.abstract) && M.push("abstract "), $.override && M.push("override "), $.readonly && M.push("readonly "), $.variance && M.push(k("variance")), $.type === "ClassAccessorProperty" && M.push("accessor "), M.push(B(b, N, k), T(b), A3(b), F(b, N, k)), [I(b, N, k, M, " =", "value"), q];
            }
            n.exports = { printClass: R, printClassMethod: C, printClassProperty: _, printHardlineAfterHeritage: x };
          } }), uo = ee({ "src/language-js/print/interface.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t } = Ge(), { builders: { join: s, line: a, group: r, indent: u, ifBreak: i } } = qe(), { hasComment: l, identity: c, CommentCheckFlags: y } = Ke(), { getTypeParametersGroupId: h } = jr(), { printTypeScriptModifiers: g } = Dt();
            function p(D, v, w) {
              let T = D.getValue(), F = [];
              T.declare && F.push("declare "), T.type === "TSInterfaceDeclaration" && F.push(T.abstract ? "abstract " : "", g(D, v, w)), F.push("interface");
              let A3 = [], B = [];
              T.type !== "InterfaceTypeAnnotation" && A3.push(" ", w("id"), w("typeParameters"));
              let I = T.typeParameters && !l(T.typeParameters, y.Trailing | y.Line);
              return t(T.extends) && B.push(I ? i(" ", a, { groupId: h(T.typeParameters) }) : a, "extends ", (T.extends.length === 1 ? c : u)(s([",", a], D.map(w, "extends")))), T.id && l(T.id, y.Trailing) || t(T.extends) ? I ? F.push(r([...A3, u(B)])) : F.push(r(u([...A3, ...B]))) : F.push(...A3, ...B), F.push(" ", w("body")), r(F);
            }
            n.exports = { printInterface: p };
          } }), so = ee({ "src/language-js/print/module.js"(e, n) {
            "use strict";
            re();
            var { isNonEmptyArray: t } = Ge(), { builders: { softline: s, group: a, indent: r, join: u, line: i, ifBreak: l, hardline: c } } = qe(), { printDanglingComments: y } = et(), { hasComment: h, CommentCheckFlags: g, shouldPrintComma: p, needsHardlineAfterDanglingComment: D, isStringLiteral: v, rawText: w } = Ke(), { locStart: T, hasSameLoc: F } = it(), { hasDecoratorsBeforeExport: A3, printDecoratorsBeforeExport: B } = zn();
            function I(_, b, N) {
              let k = _.getValue(), $ = b.semi ? ";" : "", M = [], { importKind: q } = k;
              return M.push("import"), q && q !== "value" && M.push(" ", q), M.push(m(_, b, N), x(_, b, N), o(_, b, N), $), M;
            }
            function P2(_, b, N) {
              let k = _.getValue(), $ = [];
              A3(k) && $.push(B(_, b, N));
              let { type: M, exportKind: q, declaration: J } = k;
              return $.push("export"), (k.default || M === "ExportDefaultDeclaration") && $.push(" default"), h(k, g.Dangling) && ($.push(" ", y(_, b, true)), D(k) && $.push(c)), J ? $.push(" ", N("declaration")) : $.push(q === "type" ? " type" : "", m(_, b, N), x(_, b, N), o(_, b, N)), f(k, b) && $.push(";"), $;
            }
            function R(_, b, N) {
              let k = _.getValue(), $ = b.semi ? ";" : "", M = [], { exportKind: q, exported: J } = k;
              return M.push("export"), q === "type" && M.push(" type"), M.push(" *"), J && M.push(" as ", N("exported")), M.push(x(_, b, N), o(_, b, N), $), M;
            }
            function f(_, b) {
              if (!b.semi)
                return false;
              let { type: N, declaration: k } = _, $ = _.default || N === "ExportDefaultDeclaration";
              if (!k)
                return true;
              let { type: M } = k;
              return !!($ && M !== "ClassDeclaration" && M !== "FunctionDeclaration" && M !== "TSInterfaceDeclaration" && M !== "DeclareClass" && M !== "DeclareFunction" && M !== "TSDeclareFunction" && M !== "EnumDeclaration");
            }
            function x(_, b, N) {
              let k = _.getValue();
              if (!k.source)
                return "";
              let $ = [];
              return E(k, b) || $.push(" from"), $.push(" ", N("source")), $;
            }
            function m(_, b, N) {
              let k = _.getValue();
              if (E(k, b))
                return "";
              let $ = [" "];
              if (t(k.specifiers)) {
                let M = [], q = [];
                _.each(() => {
                  let J = _.getValue().type;
                  if (J === "ExportNamespaceSpecifier" || J === "ExportDefaultSpecifier" || J === "ImportNamespaceSpecifier" || J === "ImportDefaultSpecifier")
                    M.push(N());
                  else if (J === "ExportSpecifier" || J === "ImportSpecifier")
                    q.push(N());
                  else
                    throw new Error(`Unknown specifier type ${JSON.stringify(J)}`);
                }, "specifiers"), $.push(u(", ", M)), q.length > 0 && (M.length > 0 && $.push(", "), q.length > 1 || M.length > 0 || k.specifiers.some((L) => h(L)) ? $.push(a(["{", r([b.bracketSpacing ? i : s, u([",", i], q)]), l(p(b) ? "," : ""), b.bracketSpacing ? i : s, "}"])) : $.push(["{", b.bracketSpacing ? " " : "", ...q, b.bracketSpacing ? " " : "", "}"]));
              } else
                $.push("{}");
              return $;
            }
            function E(_, b) {
              let { type: N, importKind: k, source: $, specifiers: M } = _;
              return N !== "ImportDeclaration" || t(M) || k === "type" ? false : !/{\s*}/.test(b.originalText.slice(T(_), T($)));
            }
            function o(_, b, N) {
              let k = _.getNode();
              return t(k.assertions) ? [" assert {", b.bracketSpacing ? " " : "", u(", ", _.map(N, "assertions")), b.bracketSpacing ? " " : "", "}"] : "";
            }
            function d(_, b, N) {
              let k = _.getNode(), { type: $ } = k, M = [], q = $ === "ImportSpecifier" ? k.importKind : k.exportKind;
              q && q !== "value" && M.push(q, " ");
              let J = $.startsWith("Import"), L = J ? "imported" : "local", Y = J ? "local" : "exported", V = k[L], O = k[Y], K = "", se = "";
              return $ === "ExportNamespaceSpecifier" || $ === "ImportNamespaceSpecifier" ? K = "*" : V && (K = N(L)), O && !C(k) && (se = N(Y)), M.push(K, K && se ? " as " : "", se), M;
            }
            function C(_) {
              if (_.type !== "ImportSpecifier" && _.type !== "ExportSpecifier")
                return false;
              let { local: b, [_.type === "ImportSpecifier" ? "imported" : "exported"]: N } = _;
              if (b.type !== N.type || !F(b, N))
                return false;
              if (v(b))
                return b.value === N.value && w(b) === w(N);
              switch (b.type) {
                case "Identifier":
                  return b.name === N.name;
                default:
                  return false;
              }
            }
            n.exports = { printImportDeclaration: I, printExportDeclaration: P2, printExportAllDeclaration: R, printModuleSpecifier: d };
          } }), Xn = ee({ "src/language-js/print/object.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, group: r, indent: u, ifBreak: i, hardline: l } } = qe(), { getLast: c, hasNewlineInRange: y, hasNewline: h, isNonEmptyArray: g } = Ge(), { shouldPrintComma: p, hasComment: D, getComments: v, CommentCheckFlags: w, isNextLineEmpty: T } = Ke(), { locStart: F, locEnd: A3 } = it(), { printOptionalToken: B, printTypeAnnotation: I } = Dt(), { shouldHugFunctionParameters: P2 } = kr(), { shouldHugType: R } = Lr(), { printHardlineAfterHeritage: f } = tr();
            function x(m, E, o) {
              let d = E.semi ? ";" : "", C = m.getValue(), _;
              C.type === "TSTypeLiteral" ? _ = "members" : C.type === "TSInterfaceBody" ? _ = "body" : _ = "properties";
              let b = C.type === "ObjectTypeAnnotation", N = [_];
              b && N.push("indexers", "callProperties", "internalSlots");
              let k = N.map((W) => C[W][0]).sort((W, X) => F(W) - F(X))[0], $ = m.getParentNode(0), M = b && $ && ($.type === "InterfaceDeclaration" || $.type === "DeclareInterface" || $.type === "DeclareClass") && m.getName() === "body", q = C.type === "TSInterfaceBody" || M || C.type === "ObjectPattern" && $.type !== "FunctionDeclaration" && $.type !== "FunctionExpression" && $.type !== "ArrowFunctionExpression" && $.type !== "ObjectMethod" && $.type !== "ClassMethod" && $.type !== "ClassPrivateMethod" && $.type !== "AssignmentPattern" && $.type !== "CatchClause" && C.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || C.type !== "ObjectPattern" && k && y(E.originalText, F(C), F(k)), J = M ? ";" : C.type === "TSInterfaceBody" || C.type === "TSTypeLiteral" ? i(d, ";") : ",", L = C.type === "RecordExpression" ? "#{" : C.exact ? "{|" : "{", Y = C.exact ? "|}" : "}", V = [];
              for (let W of N)
                m.each((X) => {
                  let oe = X.getValue();
                  V.push({ node: oe, printed: o(), loc: F(oe) });
                }, W);
              N.length > 1 && V.sort((W, X) => W.loc - X.loc);
              let O = [], K = V.map((W) => {
                let X = [...O, r(W.printed)];
                return O = [J, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && D(W.node, w.PrettierIgnore) && O.shift(), T(W.node, E) && O.push(l), X;
              });
              if (C.inexact) {
                let W;
                if (D(C, w.Dangling)) {
                  let X = D(C, w.Line);
                  W = [t(m, E, true), X || h(E.originalText, A3(c(v(C)))) ? l : s, "..."];
                } else
                  W = ["..."];
                K.push([...O, ...W]);
              }
              let se = c(C[_]), Q = !(C.inexact || se && se.type === "RestElement" || se && (se.type === "TSPropertySignature" || se.type === "TSCallSignatureDeclaration" || se.type === "TSMethodSignature" || se.type === "TSConstructSignatureDeclaration") && D(se, w.PrettierIgnore)), le;
              if (K.length === 0) {
                if (!D(C, w.Dangling))
                  return [L, Y, I(m, E, o)];
                le = r([L, t(m, E), a, Y, B(m), I(m, E, o)]);
              } else
                le = [M && g(C.properties) ? f($) : "", L, u([E.bracketSpacing ? s : a, ...K]), i(Q && (J !== "," || p(E)) ? J : ""), E.bracketSpacing ? s : a, Y, B(m), I(m, E, o)];
              return m.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, X, oe) => P2(W) && (X === "params" || X === "parameters" || X === "this" || X === "rest") && oe === 0) || m.match(R, (W, X) => X === "typeAnnotation", (W, X) => X === "typeAnnotation", (W, X, oe) => P2(W) && (X === "params" || X === "parameters" || X === "this" || X === "rest") && oe === 0) || !q && m.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? le : r(le, { shouldBreak: q });
            }
            n.exports = { printObject: x };
          } }), Vm = ee({ "src/language-js/print/flow.js"(e, n) {
            "use strict";
            re();
            var t = Yt(), { printDanglingComments: s } = et(), { printString: a, printNumber: r } = Ge(), { builders: { hardline: u, softline: i, group: l, indent: c } } = qe(), { getParentExportDeclaration: y, isFunctionNotation: h, isGetterOrSetter: g, rawText: p, shouldPrintComma: D } = Ke(), { locStart: v, locEnd: w } = it(), { replaceTextEndOfLine: T } = Xt(), { printClass: F } = tr(), { printOpaqueType: A3, printTypeAlias: B, printIntersectionType: I, printUnionType: P2, printFunctionType: R, printTupleType: f, printIndexedAccessType: x } = Lr(), { printInterface: m } = uo(), { printTypeParameter: E, printTypeParameters: o } = jr(), { printExportDeclaration: d, printExportAllDeclaration: C } = so(), { printArrayItems: _ } = Qt(), { printObject: b } = Xn(), { printPropertyKey: N } = er(), { printOptionalToken: k, printTypeAnnotation: $, printRestSpread: M } = Dt();
            function q(L, Y, V) {
              let O = L.getValue(), K = Y.semi ? ";" : "", se = [];
              switch (O.type) {
                case "DeclareClass":
                  return J(L, F(L, Y, V));
                case "DeclareFunction":
                  return J(L, ["function ", V("id"), O.predicate ? " " : "", V("predicate"), K]);
                case "DeclareModule":
                  return J(L, ["module ", V("id"), " ", V("body")]);
                case "DeclareModuleExports":
                  return J(L, ["module.exports", ": ", V("typeAnnotation"), K]);
                case "DeclareVariable":
                  return J(L, ["var ", V("id"), K]);
                case "DeclareOpaqueType":
                  return J(L, A3(L, Y, V));
                case "DeclareInterface":
                  return J(L, m(L, Y, V));
                case "DeclareTypeAlias":
                  return J(L, B(L, Y, V));
                case "DeclareExportDeclaration":
                  return J(L, d(L, Y, V));
                case "DeclareExportAllDeclaration":
                  return J(L, C(L, Y, V));
                case "OpaqueType":
                  return A3(L, Y, V);
                case "TypeAlias":
                  return B(L, Y, V);
                case "IntersectionTypeAnnotation":
                  return I(L, Y, V);
                case "UnionTypeAnnotation":
                  return P2(L, Y, V);
                case "FunctionTypeAnnotation":
                  return R(L, Y, V);
                case "TupleTypeAnnotation":
                  return f(L, Y, V);
                case "GenericTypeAnnotation":
                  return [V("id"), o(L, Y, V, "typeParameters")];
                case "IndexedAccessType":
                case "OptionalIndexedAccessType":
                  return x(L, Y, V);
                case "TypeAnnotation":
                  return V("typeAnnotation");
                case "TypeParameter":
                  return E(L, Y, V);
                case "TypeofTypeAnnotation":
                  return ["typeof ", V("argument")];
                case "ExistsTypeAnnotation":
                  return "*";
                case "EmptyTypeAnnotation":
                  return "empty";
                case "MixedTypeAnnotation":
                  return "mixed";
                case "ArrayTypeAnnotation":
                  return [V("elementType"), "[]"];
                case "BooleanLiteralTypeAnnotation":
                  return String(O.value);
                case "EnumDeclaration":
                  return ["enum ", V("id"), " ", V("body")];
                case "EnumBooleanBody":
                case "EnumNumberBody":
                case "EnumStringBody":
                case "EnumSymbolBody": {
                  if (O.type === "EnumSymbolBody" || O.explicitType) {
                    let Q = null;
                    switch (O.type) {
                      case "EnumBooleanBody":
                        Q = "boolean";
                        break;
                      case "EnumNumberBody":
                        Q = "number";
                        break;
                      case "EnumStringBody":
                        Q = "string";
                        break;
                      case "EnumSymbolBody":
                        Q = "symbol";
                        break;
                    }
                    se.push("of ", Q, " ");
                  }
                  if (O.members.length === 0 && !O.hasUnknownMembers)
                    se.push(l(["{", s(L, Y), i, "}"]));
                  else {
                    let Q = O.members.length > 0 ? [u, _(L, Y, "members", V), O.hasUnknownMembers || D(Y) ? "," : ""] : [];
                    se.push(l(["{", c([...Q, ...O.hasUnknownMembers ? [u, "..."] : []]), s(L, Y, true), u, "}"]));
                  }
                  return se;
                }
                case "EnumBooleanMember":
                case "EnumNumberMember":
                case "EnumStringMember":
                  return [V("id"), " = ", typeof O.init == "object" ? V("init") : String(O.init)];
                case "EnumDefaultedMember":
                  return V("id");
                case "FunctionTypeParam": {
                  let Q = O.name ? V("name") : L.getParentNode().this === O ? "this" : "";
                  return [Q, k(L), Q ? ": " : "", V("typeAnnotation")];
                }
                case "InterfaceDeclaration":
                case "InterfaceTypeAnnotation":
                  return m(L, Y, V);
                case "ClassImplements":
                case "InterfaceExtends":
                  return [V("id"), V("typeParameters")];
                case "NullableTypeAnnotation":
                  return ["?", V("typeAnnotation")];
                case "Variance": {
                  let { kind: Q } = O;
                  return t.ok(Q === "plus" || Q === "minus"), Q === "plus" ? "+" : "-";
                }
                case "ObjectTypeCallProperty":
                  return O.static && se.push("static "), se.push(V("value")), se;
                case "ObjectTypeIndexer":
                  return [O.static ? "static " : "", O.variance ? V("variance") : "", "[", V("id"), O.id ? ": " : "", V("key"), "]: ", V("value")];
                case "ObjectTypeProperty": {
                  let Q = "";
                  return O.proto ? Q = "proto " : O.static && (Q = "static "), [Q, g(O) ? O.kind + " " : "", O.variance ? V("variance") : "", N(L, Y, V), k(L), h(O) ? "" : ": ", V("value")];
                }
                case "ObjectTypeAnnotation":
                  return b(L, Y, V);
                case "ObjectTypeInternalSlot":
                  return [O.static ? "static " : "", "[[", V("id"), "]]", k(L), O.method ? "" : ": ", V("value")];
                case "ObjectTypeSpreadProperty":
                  return M(L, Y, V);
                case "QualifiedTypeofIdentifier":
                case "QualifiedTypeIdentifier":
                  return [V("qualification"), ".", V("id")];
                case "StringLiteralTypeAnnotation":
                  return T(a(p(O), Y));
                case "NumberLiteralTypeAnnotation":
                  t.strictEqual(typeof O.value, "number");
                case "BigIntLiteralTypeAnnotation":
                  return O.extra ? r(O.extra.raw) : r(O.raw);
                case "TypeCastExpression":
                  return ["(", V("expression"), $(L, Y, V), ")"];
                case "TypeParameterDeclaration":
                case "TypeParameterInstantiation": {
                  let Q = o(L, Y, V, "params");
                  if (Y.parser === "flow") {
                    let le = v(O), W = w(O), X = Y.originalText.lastIndexOf("/*", le), oe = Y.originalText.indexOf("*/", W);
                    if (X !== -1 && oe !== -1) {
                      let ae = Y.originalText.slice(X + 2, oe).trim();
                      if (ae.startsWith("::") && !ae.includes("/*") && !ae.includes("*/"))
                        return ["/*:: ", Q, " */"];
                    }
                  }
                  return Q;
                }
                case "InferredPredicate":
                  return "%checks";
                case "DeclaredPredicate":
                  return ["%checks(", V("value"), ")"];
                case "AnyTypeAnnotation":
                  return "any";
                case "BooleanTypeAnnotation":
                  return "boolean";
                case "BigIntTypeAnnotation":
                  return "bigint";
                case "NullLiteralTypeAnnotation":
                  return "null";
                case "NumberTypeAnnotation":
                  return "number";
                case "SymbolTypeAnnotation":
                  return "symbol";
                case "StringTypeAnnotation":
                  return "string";
                case "VoidTypeAnnotation":
                  return "void";
                case "ThisTypeAnnotation":
                  return "this";
                case "Node":
                case "Printable":
                case "SourceLocation":
                case "Position":
                case "Statement":
                case "Function":
                case "Pattern":
                case "Expression":
                case "Declaration":
                case "Specifier":
                case "NamedSpecifier":
                case "Comment":
                case "MemberTypeAnnotation":
                case "Type":
                  throw new Error("unprintable type: " + JSON.stringify(O.type));
              }
            }
            function J(L, Y) {
              let V = y(L);
              return V ? (t.strictEqual(V.type, "DeclareExportDeclaration"), Y) : ["declare ", Y];
            }
            n.exports = { printFlow: q };
          } }), Wm = ee({ "src/language-js/utils/is-ts-keyword-type.js"(e, n) {
            "use strict";
            re();
            function t(s) {
              let { type: a } = s;
              return a.startsWith("TS") && a.endsWith("Keyword");
            }
            n.exports = t;
          } }), io = ee({ "src/language-js/print/ternary.js"(e, n) {
            "use strict";
            re();
            var { hasNewlineInRange: t } = Ge(), { isJsxNode: s, getComments: a, isCallExpression: r, isMemberExpression: u, isTSTypeExpression: i } = Ke(), { locStart: l, locEnd: c } = it(), y = Lt(), { builders: { line: h, softline: g, group: p, indent: D, align: v, ifBreak: w, dedent: T, breakParent: F } } = qe();
            function A3(f) {
              let x = [f];
              for (let m = 0; m < x.length; m++) {
                let E = x[m];
                for (let o of ["test", "consequent", "alternate"]) {
                  let d = E[o];
                  if (s(d))
                    return true;
                  d.type === "ConditionalExpression" && x.push(d);
                }
              }
              return false;
            }
            function B(f, x, m) {
              let E = f.getValue(), o = E.type === "ConditionalExpression", d = o ? "alternate" : "falseType", C = f.getParentNode(), _ = o ? m("test") : [m("checkType"), " ", "extends", " ", m("extendsType")];
              return C.type === E.type && C[d] === E ? v(2, _) : _;
            }
            var I = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
            function P2(f) {
              let x = f.getValue();
              if (x.type !== "ConditionalExpression")
                return false;
              let m, E = x;
              for (let o = 0; !m; o++) {
                let d = f.getParentNode(o);
                if (r(d) && d.callee === E || u(d) && d.object === E || d.type === "TSNonNullExpression" && d.expression === E) {
                  E = d;
                  continue;
                }
                d.type === "NewExpression" && d.callee === E || i(d) && d.expression === E ? (m = f.getParentNode(o + 1), E = d) : m = d;
              }
              return E === x ? false : m[I.get(m.type)] === E;
            }
            function R(f, x, m) {
              let E = f.getValue(), o = E.type === "ConditionalExpression", d = o ? "consequent" : "trueType", C = o ? "alternate" : "falseType", _ = o ? ["test"] : ["checkType", "extendsType"], b = E[d], N = E[C], k = [], $ = false, M = f.getParentNode(), q = M.type === E.type && _.some((ae) => M[ae] === E), J = M.type === E.type && !q, L, Y, V = 0;
              do
                Y = L || E, L = f.getParentNode(V), V++;
              while (L && L.type === E.type && _.every((ae) => L[ae] !== Y));
              let O = L || M, K = Y;
              if (o && (s(E[_[0]]) || s(b) || s(N) || A3(K))) {
                $ = true, J = true;
                let ae = (z) => [w("("), D([g, z]), g, w(")")], Ae = (z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined";
                k.push(" ? ", Ae(b) ? m(d) : ae(m(d)), " : ", N.type === E.type || Ae(N) ? m(C) : ae(m(C)));
              } else {
                let ae = [h, "? ", b.type === E.type ? w("", "(") : "", v(2, m(d)), b.type === E.type ? w("", ")") : "", h, ": ", N.type === E.type ? m(C) : v(2, m(C))];
                k.push(M.type !== E.type || M[C] === E || q ? ae : x.useTabs ? T(D(ae)) : v(Math.max(0, x.tabWidth - 2), ae));
              }
              let Q = [..._.map((ae) => a(E[ae])), a(b), a(N)].flat().some((ae) => y(ae) && t(x.originalText, l(ae), c(ae))), le = (ae) => M === O ? p(ae, { shouldBreak: Q }) : Q ? [ae, F] : ae, W = !$ && (u(M) || M.type === "NGPipeExpression" && M.left === E) && !M.computed, X = P2(f), oe = le([B(f, x, m), J ? k : D(k), o && W && !X ? g : ""]);
              return q || X ? p([D([g, oe]), g]) : oe;
            }
            n.exports = { printTernary: R };
          } }), ao = ee({ "src/language-js/print/statement.js"(e, n) {
            "use strict";
            re();
            var { builders: { hardline: t } } = qe(), s = Ot(), { getLeftSidePathName: a, hasNakedLeftSide: r, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: l, CommentCheckFlags: c, isNextLineEmpty: y } = Ke(), { shouldPrintParamsWithoutParens: h } = Or();
            function g(B, I, P2, R) {
              let f = B.getValue(), x = [], m = f.type === "ClassBody", E = p(f[R]);
              return B.each((o, d, C) => {
                let _ = o.getValue();
                if (_.type === "EmptyStatement")
                  return;
                let b = P2();
                !I.semi && !m && !i(I, o) && D(o, I) ? l(_, c.Leading) ? x.push(P2([], { needsSemi: true })) : x.push(";", b) : x.push(b), !I.semi && m && F(_) && A3(_, C[d + 1]) && x.push(";"), _ !== E && (x.push(t), y(_, I) && x.push(t));
              }, R), x;
            }
            function p(B) {
              for (let I = B.length - 1; I >= 0; I--) {
                let P2 = B[I];
                if (P2.type !== "EmptyStatement")
                  return P2;
              }
            }
            function D(B, I) {
              return B.getNode().type !== "ExpressionStatement" ? false : B.call((R) => v(R, I), "expression");
            }
            function v(B, I) {
              let P2 = B.getValue();
              switch (P2.type) {
                case "ParenthesizedExpression":
                case "TypeCastExpression":
                case "ArrayExpression":
                case "ArrayPattern":
                case "TemplateLiteral":
                case "TemplateElement":
                case "RegExpLiteral":
                  return true;
                case "ArrowFunctionExpression": {
                  if (!h(B, I))
                    return true;
                  break;
                }
                case "UnaryExpression": {
                  let { prefix: R, operator: f } = P2;
                  if (R && (f === "+" || f === "-"))
                    return true;
                  break;
                }
                case "BindExpression": {
                  if (!P2.object)
                    return true;
                  break;
                }
                case "Literal": {
                  if (P2.regex)
                    return true;
                  break;
                }
                default:
                  if (u(P2))
                    return true;
              }
              return s(B, I) ? true : r(P2) ? B.call((R) => v(R, I), ...a(B, P2)) : false;
            }
            function w(B, I, P2) {
              return g(B, I, P2, "body");
            }
            function T(B, I, P2) {
              return g(B, I, P2, "consequent");
            }
            var F = (B) => {
              let { type: I } = B;
              return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty";
            };
            function A3(B, I) {
              let P2 = B.key && B.key.name;
              if ((P2 === "static" || P2 === "get" || P2 === "set") && !B.value && !B.typeAnnotation)
                return true;
              if (!I || I.static || I.accessibility)
                return false;
              if (!I.computed) {
                let R = I.key && I.key.name;
                if (R === "in" || R === "instanceof")
                  return true;
              }
              if (F(I) && I.variance && !I.static && !I.declare)
                return true;
              switch (I.type) {
                case "ClassProperty":
                case "PropertyDefinition":
                case "TSAbstractPropertyDefinition":
                  return I.computed;
                case "MethodDefinition":
                case "TSAbstractMethodDefinition":
                case "ClassMethod":
                case "ClassPrivateMethod": {
                  if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set")
                    return false;
                  let f = I.value ? I.value.generator : I.generator;
                  return !!(I.computed || f);
                }
                case "TSIndexSignature":
                  return true;
              }
              return false;
            }
            n.exports = { printBody: w, printSwitchCaseConsequent: T };
          } }), oo = ee({ "src/language-js/print/block.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { isNonEmptyArray: s } = Ge(), { builders: { hardline: a, indent: r } } = qe(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: l } = Ke(), { printHardlineAfterHeritage: c } = tr(), { printBody: y } = ao();
            function h(p, D, v) {
              let w = p.getValue(), T = [];
              if (w.type === "StaticBlock" && T.push("static "), w.type === "ClassBody" && s(w.body)) {
                let A3 = p.getParentNode();
                T.push(c(A3));
              }
              T.push("{");
              let F = g(p, D, v);
              if (F)
                T.push(r([a, F]), a);
              else {
                let A3 = p.getParentNode(), B = p.getParentNode(1);
                A3.type === "ArrowFunctionExpression" || A3.type === "FunctionExpression" || A3.type === "FunctionDeclaration" || A3.type === "ObjectMethod" || A3.type === "ClassMethod" || A3.type === "ClassPrivateMethod" || A3.type === "ForStatement" || A3.type === "WhileStatement" || A3.type === "DoWhileStatement" || A3.type === "DoExpression" || A3.type === "CatchClause" && !B.finalizer || A3.type === "TSModuleDeclaration" || A3.type === "TSDeclareFunction" || w.type === "StaticBlock" || w.type === "ClassBody" || T.push(a);
              }
              return T.push("}"), T;
            }
            function g(p, D, v) {
              let w = p.getValue(), T = s(w.directives), F = w.body.some((I) => I.type !== "EmptyStatement"), A3 = u(w, i.Dangling);
              if (!T && !F && !A3)
                return "";
              let B = [];
              if (T && p.each((I, P2, R) => {
                B.push(v()), (P2 < R.length - 1 || F || A3) && (B.push(a), l(I.getValue(), D) && B.push(a));
              }, "directives"), F && B.push(y(p, D, v)), A3 && B.push(t(p, D, true)), w.type === "Program") {
                let I = p.getParentNode();
                (!I || I.type !== "ModuleExpression") && B.push(a);
              }
              return B;
            }
            n.exports = { printBlock: h, printBlockBody: g };
          } }), Hm = ee({ "src/language-js/print/typescript.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { hasNewlineInRange: s } = Ge(), { builders: { join: a, line: r, hardline: u, softline: i, group: l, indent: c, conditionalGroup: y, ifBreak: h } } = qe(), { isLiteral: g, getTypeScriptMappedTypeModifier: p, shouldPrintComma: D, isCallExpression: v, isMemberExpression: w } = Ke(), T = Wm(), { locStart: F, locEnd: A3 } = it(), { printOptionalToken: B, printTypeScriptModifiers: I } = Dt(), { printTernary: P2 } = io(), { printFunctionParameters: R, shouldGroupFunctionParameters: f } = kr(), { printTemplateLiteral: x } = jt(), { printArrayItems: m } = Qt(), { printObject: E } = Xn(), { printClassProperty: o, printClassMethod: d } = tr(), { printTypeParameter: C, printTypeParameters: _ } = jr(), { printPropertyKey: b } = er(), { printFunction: N, printMethodInternal: k } = Or(), { printInterface: $ } = uo(), { printBlock: M } = oo(), { printTypeAlias: q, printIntersectionType: J, printUnionType: L, printFunctionType: Y, printTupleType: V, printIndexedAccessType: O, printJSDocType: K } = Lr();
            function se(Q, le, W) {
              let X = Q.getValue();
              if (!X.type.startsWith("TS"))
                return;
              if (T(X))
                return X.type.slice(2, -7).toLowerCase();
              let oe = le.semi ? ";" : "", ae = [];
              switch (X.type) {
                case "TSThisType":
                  return "this";
                case "TSTypeAssertion": {
                  let Ae = !(X.expression.type === "ArrayExpression" || X.expression.type === "ObjectExpression"), z = l(["<", c([i, W("typeAnnotation")]), i, ">"]), H = [h("("), c([i, W("expression")]), i, h(")")];
                  return Ae ? y([[z, W("expression")], [z, l(H, { shouldBreak: true })], [z, W("expression")]]) : l([z, W("expression")]);
                }
                case "TSDeclareFunction":
                  return N(Q, W, le);
                case "TSExportAssignment":
                  return ["export = ", W("expression"), oe];
                case "TSModuleBlock":
                  return M(Q, le, W);
                case "TSInterfaceBody":
                case "TSTypeLiteral":
                  return E(Q, le, W);
                case "TSTypeAliasDeclaration":
                  return q(Q, le, W);
                case "TSQualifiedName":
                  return a(".", [W("left"), W("right")]);
                case "TSAbstractMethodDefinition":
                case "TSDeclareMethod":
                  return d(Q, le, W);
                case "TSAbstractPropertyDefinition":
                  return o(Q, le, W);
                case "TSInterfaceHeritage":
                case "TSExpressionWithTypeArguments":
                  return ae.push(W("expression")), X.typeParameters && ae.push(W("typeParameters")), ae;
                case "TSTemplateLiteralType":
                  return x(Q, W, le);
                case "TSNamedTupleMember":
                  return [W("label"), X.optional ? "?" : "", ": ", W("elementType")];
                case "TSRestType":
                  return ["...", W("typeAnnotation")];
                case "TSOptionalType":
                  return [W("typeAnnotation"), "?"];
                case "TSInterfaceDeclaration":
                  return $(Q, le, W);
                case "TSClassImplements":
                  return [W("expression"), W("typeParameters")];
                case "TSTypeParameterDeclaration":
                case "TSTypeParameterInstantiation":
                  return _(Q, le, W, "params");
                case "TSTypeParameter":
                  return C(Q, le, W);
                case "TSSatisfiesExpression":
                case "TSAsExpression": {
                  let Ae = X.type === "TSAsExpression" ? "as" : "satisfies";
                  ae.push(W("expression"), ` ${Ae} `, W("typeAnnotation"));
                  let z = Q.getParentNode();
                  return v(z) && z.callee === X || w(z) && z.object === X ? l([c([i, ...ae]), i]) : ae;
                }
                case "TSArrayType":
                  return [W("elementType"), "[]"];
                case "TSPropertySignature":
                  return X.readonly && ae.push("readonly "), ae.push(b(Q, le, W), B(Q)), X.typeAnnotation && ae.push(": ", W("typeAnnotation")), X.initializer && ae.push(" = ", W("initializer")), ae;
                case "TSParameterProperty":
                  return X.accessibility && ae.push(X.accessibility + " "), X.export && ae.push("export "), X.static && ae.push("static "), X.override && ae.push("override "), X.readonly && ae.push("readonly "), ae.push(W("parameter")), ae;
                case "TSTypeQuery":
                  return ["typeof ", W("exprName"), W("typeParameters")];
                case "TSIndexSignature": {
                  let Ae = Q.getParentNode(), z = X.parameters.length > 1 ? h(D(le) ? "," : "") : "", H = l([c([i, a([", ", i], Q.map(W, "parameters"))]), z, i]);
                  return [X.export ? "export " : "", X.accessibility ? [X.accessibility, " "] : "", X.static ? "static " : "", X.readonly ? "readonly " : "", X.declare ? "declare " : "", "[", X.parameters ? H : "", X.typeAnnotation ? "]: " : "]", X.typeAnnotation ? W("typeAnnotation") : "", Ae.type === "ClassBody" ? oe : ""];
                }
                case "TSTypePredicate":
                  return [X.asserts ? "asserts " : "", W("parameterName"), X.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
                case "TSNonNullExpression":
                  return [W("expression"), "!"];
                case "TSImportType":
                  return [X.isTypeOf ? "typeof " : "", "import(", W(X.parameter ? "parameter" : "argument"), ")", X.qualifier ? [".", W("qualifier")] : "", _(Q, le, W, "typeParameters")];
                case "TSLiteralType":
                  return W("literal");
                case "TSIndexedAccessType":
                  return O(Q, le, W);
                case "TSConstructSignatureDeclaration":
                case "TSCallSignatureDeclaration":
                case "TSConstructorType": {
                  if (X.type === "TSConstructorType" && X.abstract && ae.push("abstract "), X.type !== "TSCallSignatureDeclaration" && ae.push("new "), ae.push(l(R(Q, W, le, false, true))), X.returnType || X.typeAnnotation) {
                    let Ae = X.type === "TSConstructorType";
                    ae.push(Ae ? " => " : ": ", W("returnType"), W("typeAnnotation"));
                  }
                  return ae;
                }
                case "TSTypeOperator":
                  return [X.operator, " ", W("typeAnnotation")];
                case "TSMappedType": {
                  let Ae = s(le.originalText, F(X), A3(X));
                  return l(["{", c([le.bracketSpacing ? r : i, X.readonly ? [p(X.readonly, "readonly"), " "] : "", I(Q, le, W), W("typeParameter"), X.optional ? p(X.optional, "?") : "", X.typeAnnotation ? ": " : "", W("typeAnnotation"), h(oe)]), t(Q, le, true), le.bracketSpacing ? r : i, "}"], { shouldBreak: Ae });
                }
                case "TSMethodSignature": {
                  let Ae = X.kind && X.kind !== "method" ? `${X.kind} ` : "";
                  ae.push(X.accessibility ? [X.accessibility, " "] : "", Ae, X.export ? "export " : "", X.static ? "static " : "", X.readonly ? "readonly " : "", X.abstract ? "abstract " : "", X.declare ? "declare " : "", X.computed ? "[" : "", W("key"), X.computed ? "]" : "", B(Q));
                  let z = R(Q, W, le, false, true), H = X.returnType ? "returnType" : "typeAnnotation", Z = X[H], ne = Z ? W(H) : "", fe = f(X, ne);
                  return ae.push(fe ? l(z) : z), Z && ae.push(": ", l(ne)), l(ae);
                }
                case "TSNamespaceExportDeclaration":
                  return ae.push("export as namespace ", W("id")), le.semi && ae.push(";"), l(ae);
                case "TSEnumDeclaration":
                  return X.declare && ae.push("declare "), X.modifiers && ae.push(I(Q, le, W)), X.const && ae.push("const "), ae.push("enum ", W("id"), " "), X.members.length === 0 ? ae.push(l(["{", t(Q, le), i, "}"])) : ae.push(l(["{", c([u, m(Q, le, "members", W), D(le, "es5") ? "," : ""]), t(Q, le, true), u, "}"])), ae;
                case "TSEnumMember":
                  return X.computed ? ae.push("[", W("id"), "]") : ae.push(W("id")), X.initializer && ae.push(" = ", W("initializer")), ae;
                case "TSImportEqualsDeclaration":
                  return X.isExport && ae.push("export "), ae.push("import "), X.importKind && X.importKind !== "value" && ae.push(X.importKind, " "), ae.push(W("id"), " = ", W("moduleReference")), le.semi && ae.push(";"), l(ae);
                case "TSExternalModuleReference":
                  return ["require(", W("expression"), ")"];
                case "TSModuleDeclaration": {
                  let Ae = Q.getParentNode(), z = g(X.id), H = Ae.type === "TSModuleDeclaration", Z = X.body && X.body.type === "TSModuleDeclaration";
                  if (H)
                    ae.push(".");
                  else {
                    X.declare && ae.push("declare "), ae.push(I(Q, le, W));
                    let ne = le.originalText.slice(F(X), F(X.id));
                    X.id.type === "Identifier" && X.id.name === "global" && !/namespace|module/.test(ne) || ae.push(z || /(?:^|\s)module(?:\s|$)/.test(ne) ? "module " : "namespace ");
                  }
                  return ae.push(W("id")), Z ? ae.push(W("body")) : X.body ? ae.push(" ", l(W("body"))) : ae.push(oe), ae;
                }
                case "TSConditionalType":
                  return P2(Q, le, W);
                case "TSInferType":
                  return ["infer", " ", W("typeParameter")];
                case "TSIntersectionType":
                  return J(Q, le, W);
                case "TSUnionType":
                  return L(Q, le, W);
                case "TSFunctionType":
                  return Y(Q, le, W);
                case "TSTupleType":
                  return V(Q, le, W);
                case "TSTypeReference":
                  return [W("typeName"), _(Q, le, W, "typeParameters")];
                case "TSTypeAnnotation":
                  return W("typeAnnotation");
                case "TSEmptyBodyFunctionExpression":
                  return k(Q, le, W);
                case "TSJSDocAllType":
                  return "*";
                case "TSJSDocUnknownType":
                  return "?";
                case "TSJSDocNullableType":
                  return K(Q, W, "?");
                case "TSJSDocNonNullableType":
                  return K(Q, W, "!");
                case "TSInstantiationExpression":
                  return [W("expression"), W("typeParameters")];
                default:
                  throw new Error(`Unknown TypeScript node type: ${JSON.stringify(X.type)}.`);
              }
            }
            n.exports = { printTypescript: se };
          } }), Gm = ee({ "src/language-js/print/comment.js"(e, n) {
            "use strict";
            re();
            var { hasNewline: t } = Ge(), { builders: { join: s, hardline: a }, utils: { replaceTextEndOfLine: r } } = qe(), { isLineComment: u } = Ke(), { locStart: i, locEnd: l } = it(), c = Lt();
            function y(p, D) {
              let v = p.getValue();
              if (u(v))
                return D.originalText.slice(i(v), l(v)).trimEnd();
              if (c(v)) {
                if (h(v)) {
                  let F = g(v);
                  return v.trailing && !t(D.originalText, i(v), { backwards: true }) ? [a, F] : F;
                }
                let w = l(v), T = D.originalText.slice(w - 3, w) === "*-/";
                return ["/*", r(v.value), T ? "*-/" : "*/"];
              }
              throw new Error("Not a comment: " + JSON.stringify(v));
            }
            function h(p) {
              let D = `*${p.value}*`.split(`
`);
              return D.length > 1 && D.every((v) => v.trim()[0] === "*");
            }
            function g(p) {
              let D = p.value.split(`
`);
              return ["/*", s(a, D.map((v, w) => w === 0 ? v.trimEnd() : " " + (w < D.length - 1 ? v.trim() : v.trimStart()))), "*/"];
            }
            n.exports = { printComment: y };
          } }), Um = ee({ "src/language-js/print/literal.js"(e, n) {
            "use strict";
            re();
            var { printString: t, printNumber: s } = Ge(), { replaceTextEndOfLine: a } = Xt();
            function r(l, c) {
              let y = l.getNode();
              switch (y.type) {
                case "RegExpLiteral":
                  return i(y);
                case "BigIntLiteral":
                  return u(y.bigint || y.extra.raw);
                case "NumericLiteral":
                  return s(y.extra.raw);
                case "StringLiteral":
                  return a(t(y.extra.raw, c));
                case "NullLiteral":
                  return "null";
                case "BooleanLiteral":
                  return String(y.value);
                case "DecimalLiteral":
                  return s(y.value) + "m";
                case "Literal": {
                  if (y.regex)
                    return i(y.regex);
                  if (y.bigint)
                    return u(y.raw);
                  if (y.decimal)
                    return s(y.decimal) + "m";
                  let { value: h } = y;
                  return typeof h == "number" ? s(y.raw) : typeof h == "string" ? a(t(y.raw, c)) : String(h);
                }
              }
            }
            function u(l) {
              return l.toLowerCase();
            }
            function i(l) {
              let { pattern: c, flags: y } = l;
              return y = [...y].sort().join(""), `/${c}/${y}`;
            }
            n.exports = { printLiteral: r };
          } }), Jm = ee({ "src/language-js/printer-estree.js"(e, n) {
            "use strict";
            re();
            var { printDanglingComments: t } = et(), { hasNewline: s } = Ge(), { builders: { join: a, line: r, hardline: u, softline: i, group: l, indent: c }, utils: { replaceTextEndOfLine: y } } = qe(), h = Nm(), g = wm(), { insertPragma: p } = Qa(), D = Za(), v = Ot(), w = eo(), { hasFlowShorthandAnnotationComment: T, hasComment: F, CommentCheckFlags: A3, isTheOnlyJsxElementInMarkdown: B, isLineComment: I, isNextLineEmpty: P2, needsHardlineAfterDanglingComment: R, rawText: f, hasIgnoreComment: x, isCallExpression: m, isMemberExpression: E, markerForIfWithoutBlockAndSameLineComment: o } = Ke(), { locStart: d, locEnd: C } = it(), _ = Lt(), { printHtmlBinding: b, isVueEventBindingExpression: N } = qm(), { printAngular: k } = Mm(), { printJsx: $, hasJsxIgnoreComment: M } = Rm(), { printFlow: q } = Vm(), { printTypescript: J } = Hm(), { printOptionalToken: L, printBindExpressionCallee: Y, printTypeAnnotation: V, adjustClause: O, printRestSpread: K, printDefiniteToken: se } = Dt(), { printImportDeclaration: Q, printExportDeclaration: le, printExportAllDeclaration: W, printModuleSpecifier: X } = so(), { printTernary: oe } = io(), { printTemplateLiteral: ae } = jt(), { printArray: Ae } = Qt(), { printObject: z } = Xn(), { printClass: H, printClassMethod: Z, printClassProperty: ne } = tr(), { printProperty: fe } = er(), { printFunction: ge, printArrowFunction: Ce, printMethod: _e, printReturnStatement: Oe, printThrowStatement: pe } = Or(), { printCallExpression: ie } = no(), { printVariableDeclarator: ve, printAssignmentExpression: ce } = Zt(), { printBinaryishExpression: U } = Jn(), { printSwitchCaseConsequent: de } = ao(), { printMemberExpression: De } = ro(), { printBlock: he, printBlockBody: Be } = oo(), { printComment: Se } = Gm(), { printLiteral: ye } = Um(), { printDecorators: S } = zn();
            function G(Te, Pe, Fe, Ze) {
              let xe = te(Te, Pe, Fe, Ze);
              if (!xe)
                return "";
              let Je = Te.getValue(), { type: we } = Je;
              if (we === "ClassMethod" || we === "ClassPrivateMethod" || we === "ClassProperty" || we === "ClassAccessorProperty" || we === "PropertyDefinition" || we === "TSAbstractPropertyDefinition" || we === "ClassPrivateProperty" || we === "MethodDefinition" || we === "TSAbstractMethodDefinition" || we === "TSDeclareMethod")
                return xe;
              let Le = [xe], Ve = S(Te, Pe, Fe), be = Je.type === "ClassExpression" && Ve;
              if (Ve && (Le = [...Ve, xe], !be))
                return l(Le);
              if (!v(Te, Pe))
                return Ze && Ze.needsSemi && Le.unshift(";"), Le.length === 1 && Le[0] === xe ? xe : Le;
              if (be && (Le = [c([r, ...Le])]), Le.unshift("("), Ze && Ze.needsSemi && Le.unshift(";"), T(Je)) {
                let [Me] = Je.trailingComments;
                Le.push(" /*", Me.value.trimStart(), "*/"), Me.printed = true;
              }
              return be && Le.push(r), Le.push(")"), Le;
            }
            function te(Te, Pe, Fe, Ze) {
              let xe = Te.getValue(), Je = Pe.semi ? ";" : "";
              if (!xe)
                return "";
              if (typeof xe == "string")
                return xe;
              for (let Le of [ye, b, k, $, q, J]) {
                let Ve = Le(Te, Pe, Fe);
                if (typeof Ve < "u")
                  return Ve;
              }
              let we = [];
              switch (xe.type) {
                case "JsExpressionRoot":
                  return Fe("node");
                case "JsonRoot":
                  return [Fe("node"), u];
                case "File":
                  return xe.program && xe.program.interpreter && we.push(Fe(["program", "interpreter"])), we.push(Fe("program")), we;
                case "Program":
                  return Be(Te, Pe, Fe);
                case "EmptyStatement":
                  return "";
                case "ExpressionStatement": {
                  if (xe.directive)
                    return [Ee(xe.expression, Pe), Je];
                  if (Pe.parser === "__vue_event_binding" || Pe.parser === "__vue_ts_event_binding") {
                    let Ve = Te.getParentNode();
                    if (Ve.type === "Program" && Ve.body.length === 1 && Ve.body[0] === xe)
                      return [Fe("expression"), N(xe.expression) ? ";" : ""];
                  }
                  let Le = t(Te, Pe, true, (Ve) => {
                    let { marker: be } = Ve;
                    return be === o;
                  });
                  return [Fe("expression"), B(Pe, Te) ? "" : Je, Le ? [" ", Le] : ""];
                }
                case "ParenthesizedExpression":
                  return !F(xe.expression) && (xe.expression.type === "ObjectExpression" || xe.expression.type === "ArrayExpression") ? ["(", Fe("expression"), ")"] : l(["(", c([i, Fe("expression")]), i, ")"]);
                case "AssignmentExpression":
                  return ce(Te, Pe, Fe);
                case "VariableDeclarator":
                  return ve(Te, Pe, Fe);
                case "BinaryExpression":
                case "LogicalExpression":
                  return U(Te, Pe, Fe);
                case "AssignmentPattern":
                  return [Fe("left"), " = ", Fe("right")];
                case "OptionalMemberExpression":
                case "MemberExpression":
                  return De(Te, Pe, Fe);
                case "MetaProperty":
                  return [Fe("meta"), ".", Fe("property")];
                case "BindExpression":
                  return xe.object && we.push(Fe("object")), we.push(l(c([i, Y(Te, Pe, Fe)]))), we;
                case "Identifier":
                  return [xe.name, L(Te), se(Te), V(Te, Pe, Fe)];
                case "V8IntrinsicIdentifier":
                  return ["%", xe.name];
                case "SpreadElement":
                case "SpreadElementPattern":
                case "SpreadProperty":
                case "SpreadPropertyPattern":
                case "RestElement":
                  return K(Te, Pe, Fe);
                case "FunctionDeclaration":
                case "FunctionExpression":
                  return ge(Te, Fe, Pe, Ze);
                case "ArrowFunctionExpression":
                  return Ce(Te, Pe, Fe, Ze);
                case "YieldExpression":
                  return we.push("yield"), xe.delegate && we.push("*"), xe.argument && we.push(" ", Fe("argument")), we;
                case "AwaitExpression": {
                  if (we.push("await"), xe.argument) {
                    we.push(" ", Fe("argument"));
                    let Le = Te.getParentNode();
                    if (m(Le) && Le.callee === xe || E(Le) && Le.object === xe) {
                      we = [c([i, ...we]), i];
                      let Ve = Te.findAncestor((be) => be.type === "AwaitExpression" || be.type === "BlockStatement");
                      if (!Ve || Ve.type !== "AwaitExpression")
                        return l(we);
                    }
                  }
                  return we;
                }
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                  return le(Te, Pe, Fe);
                case "ExportAllDeclaration":
                  return W(Te, Pe, Fe);
                case "ImportDeclaration":
                  return Q(Te, Pe, Fe);
                case "ImportSpecifier":
                case "ExportSpecifier":
                case "ImportNamespaceSpecifier":
                case "ExportNamespaceSpecifier":
                case "ImportDefaultSpecifier":
                case "ExportDefaultSpecifier":
                  return X(Te, Pe, Fe);
                case "ImportAttribute":
                  return [Fe("key"), ": ", Fe("value")];
                case "Import":
                  return "import";
                case "BlockStatement":
                case "StaticBlock":
                case "ClassBody":
                  return he(Te, Pe, Fe);
                case "ThrowStatement":
                  return pe(Te, Pe, Fe);
                case "ReturnStatement":
                  return Oe(Te, Pe, Fe);
                case "NewExpression":
                case "ImportExpression":
                case "OptionalCallExpression":
                case "CallExpression":
                  return ie(Te, Pe, Fe);
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  return z(Te, Pe, Fe);
                case "ObjectProperty":
                case "Property":
                  return xe.method || xe.kind === "get" || xe.kind === "set" ? _e(Te, Pe, Fe) : fe(Te, Pe, Fe);
                case "ObjectMethod":
                  return _e(Te, Pe, Fe);
                case "Decorator":
                  return ["@", Fe("expression")];
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  return Ae(Te, Pe, Fe);
                case "SequenceExpression": {
                  let Le = Te.getParentNode(0);
                  if (Le.type === "ExpressionStatement" || Le.type === "ForStatement") {
                    let Ve = [];
                    return Te.each((be, ke) => {
                      ke === 0 ? Ve.push(Fe()) : Ve.push(",", c([r, Fe()]));
                    }, "expressions"), l(Ve);
                  }
                  return l(a([",", r], Te.map(Fe, "expressions")));
                }
                case "ThisExpression":
                  return "this";
                case "Super":
                  return "super";
                case "Directive":
                  return [Fe("value"), Je];
                case "DirectiveLiteral":
                  return Ee(xe, Pe);
                case "UnaryExpression":
                  return we.push(xe.operator), /[a-z]$/.test(xe.operator) && we.push(" "), F(xe.argument) ? we.push(l(["(", c([i, Fe("argument")]), i, ")"])) : we.push(Fe("argument")), we;
                case "UpdateExpression":
                  return we.push(Fe("argument"), xe.operator), xe.prefix && we.reverse(), we;
                case "ConditionalExpression":
                  return oe(Te, Pe, Fe);
                case "VariableDeclaration": {
                  let Le = Te.map(Fe, "declarations"), Ve = Te.getParentNode(), be = Ve.type === "ForStatement" || Ve.type === "ForInStatement" || Ve.type === "ForOfStatement", ke = xe.declarations.some((ue) => ue.init), Me;
                  return Le.length === 1 && !F(xe.declarations[0]) ? Me = Le[0] : Le.length > 0 && (Me = c(Le[0])), we = [xe.declare ? "declare " : "", xe.kind, Me ? [" ", Me] : "", c(Le.slice(1).map((ue) => [",", ke && !be ? u : r, ue]))], be && Ve.body !== xe || we.push(Je), l(we);
                }
                case "WithStatement":
                  return l(["with (", Fe("object"), ")", O(xe.body, Fe("body"))]);
                case "IfStatement": {
                  let Le = O(xe.consequent, Fe("consequent")), Ve = l(["if (", l([c([i, Fe("test")]), i]), ")", Le]);
                  if (we.push(Ve), xe.alternate) {
                    let be = F(xe.consequent, A3.Trailing | A3.Line) || R(xe), ke = xe.consequent.type === "BlockStatement" && !be;
                    we.push(ke ? " " : u), F(xe, A3.Dangling) && we.push(t(Te, Pe, true), be ? u : " "), we.push("else", l(O(xe.alternate, Fe("alternate"), xe.alternate.type === "IfStatement")));
                  }
                  return we;
                }
                case "ForStatement": {
                  let Le = O(xe.body, Fe("body")), Ve = t(Te, Pe, true), be = Ve ? [Ve, i] : "";
                  return !xe.init && !xe.test && !xe.update ? [be, l(["for (;;)", Le])] : [be, l(["for (", l([c([i, Fe("init"), ";", r, Fe("test"), ";", r, Fe("update")]), i]), ")", Le])];
                }
                case "WhileStatement":
                  return l(["while (", l([c([i, Fe("test")]), i]), ")", O(xe.body, Fe("body"))]);
                case "ForInStatement":
                  return l(["for (", Fe("left"), " in ", Fe("right"), ")", O(xe.body, Fe("body"))]);
                case "ForOfStatement":
                  return l(["for", xe.await ? " await" : "", " (", Fe("left"), " of ", Fe("right"), ")", O(xe.body, Fe("body"))]);
                case "DoWhileStatement": {
                  let Le = O(xe.body, Fe("body"));
                  return we = [l(["do", Le])], xe.body.type === "BlockStatement" ? we.push(" ") : we.push(u), we.push("while (", l([c([i, Fe("test")]), i]), ")", Je), we;
                }
                case "DoExpression":
                  return [xe.async ? "async " : "", "do ", Fe("body")];
                case "BreakStatement":
                  return we.push("break"), xe.label && we.push(" ", Fe("label")), we.push(Je), we;
                case "ContinueStatement":
                  return we.push("continue"), xe.label && we.push(" ", Fe("label")), we.push(Je), we;
                case "LabeledStatement":
                  return xe.body.type === "EmptyStatement" ? [Fe("label"), ":;"] : [Fe("label"), ": ", Fe("body")];
                case "TryStatement":
                  return ["try ", Fe("block"), xe.handler ? [" ", Fe("handler")] : "", xe.finalizer ? [" finally ", Fe("finalizer")] : ""];
                case "CatchClause":
                  if (xe.param) {
                    let Le = F(xe.param, (be) => !_(be) || be.leading && s(Pe.originalText, C(be)) || be.trailing && s(Pe.originalText, d(be), { backwards: true })), Ve = Fe("param");
                    return ["catch ", Le ? ["(", c([i, Ve]), i, ") "] : ["(", Ve, ") "], Fe("body")];
                  }
                  return ["catch ", Fe("body")];
                case "SwitchStatement":
                  return [l(["switch (", c([i, Fe("discriminant")]), i, ")"]), " {", xe.cases.length > 0 ? c([u, a(u, Te.map((Le, Ve, be) => {
                    let ke = Le.getValue();
                    return [Fe(), Ve !== be.length - 1 && P2(ke, Pe) ? u : ""];
                  }, "cases"))]) : "", u, "}"];
                case "SwitchCase": {
                  xe.test ? we.push("case ", Fe("test"), ":") : we.push("default:"), F(xe, A3.Dangling) && we.push(" ", t(Te, Pe, true));
                  let Le = xe.consequent.filter((Ve) => Ve.type !== "EmptyStatement");
                  if (Le.length > 0) {
                    let Ve = de(Te, Pe, Fe);
                    we.push(Le.length === 1 && Le[0].type === "BlockStatement" ? [" ", Ve] : c([u, Ve]));
                  }
                  return we;
                }
                case "DebuggerStatement":
                  return ["debugger", Je];
                case "ClassDeclaration":
                case "ClassExpression":
                  return H(Te, Pe, Fe);
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "MethodDefinition":
                  return Z(Te, Pe, Fe);
                case "ClassProperty":
                case "PropertyDefinition":
                case "ClassPrivateProperty":
                case "ClassAccessorProperty":
                  return ne(Te, Pe, Fe);
                case "TemplateElement":
                  return y(xe.value.raw);
                case "TemplateLiteral":
                  return ae(Te, Fe, Pe);
                case "TaggedTemplateExpression":
                  return [Fe("tag"), Fe("typeParameters"), Fe("quasi")];
                case "PrivateIdentifier":
                  return ["#", Fe("name")];
                case "PrivateName":
                  return ["#", Fe("id")];
                case "InterpreterDirective":
                  return we.push("#!", xe.value, u), P2(xe, Pe) && we.push(u), we;
                case "TopicReference":
                  return "%";
                case "ArgumentPlaceholder":
                  return "?";
                case "ModuleExpression": {
                  we.push("module {");
                  let Le = Fe("body");
                  return Le && we.push(c([u, Le]), u), we.push("}"), we;
                }
                default:
                  throw new Error("unknown type: " + JSON.stringify(xe.type));
              }
            }
            function Ee(Te, Pe) {
              let Fe = f(Te), Ze = Fe.slice(1, -1);
              if (Ze.includes('"') || Ze.includes("'"))
                return Fe;
              let xe = Pe.singleQuote ? "'" : '"';
              return xe + Ze + xe;
            }
            function Re(Te) {
              return Te.type && !_(Te) && !I(Te) && Te.type !== "EmptyStatement" && Te.type !== "TemplateElement" && Te.type !== "Import" && Te.type !== "TSEmptyBodyFunctionExpression";
            }
            n.exports = { preprocess: w, print: G, embed: h, insertPragma: p, massageAstNode: g, hasPrettierIgnore(Te) {
              return x(Te) || M(Te);
            }, willPrintOwnComments: D.willPrintOwnComments, canAttachComment: Re, printComment: Se, isBlockComment: _, handleComments: { avoidAstMutation: true, ownLine: D.handleOwnLineComment, endOfLine: D.handleEndOfLineComment, remaining: D.handleRemainingComment }, getCommentChildNodes: D.getCommentChildNodes };
          } }), zm = ee({ "src/language-js/printer-estree-json.js"(e, n) {
            "use strict";
            re();
            var { builders: { hardline: t, indent: s, join: a } } = qe(), r = eo();
            function u(c, y, h) {
              let g = c.getValue();
              switch (g.type) {
                case "JsonRoot":
                  return [h("node"), t];
                case "ArrayExpression": {
                  if (g.elements.length === 0)
                    return "[]";
                  let p = c.map(() => c.getValue() === null ? "null" : h(), "elements");
                  return ["[", s([t, a([",", t], p)]), t, "]"];
                }
                case "ObjectExpression":
                  return g.properties.length === 0 ? "{}" : ["{", s([t, a([",", t], c.map(h, "properties"))]), t, "}"];
                case "ObjectProperty":
                  return [h("key"), ": ", h("value")];
                case "UnaryExpression":
                  return [g.operator === "+" ? "" : g.operator, h("argument")];
                case "NullLiteral":
                  return "null";
                case "BooleanLiteral":
                  return g.value ? "true" : "false";
                case "StringLiteral":
                case "NumericLiteral":
                  return JSON.stringify(g.value);
                case "Identifier": {
                  let p = c.getParentNode();
                  return p && p.type === "ObjectProperty" && p.key === g ? JSON.stringify(g.name) : g.name;
                }
                case "TemplateLiteral":
                  return h(["quasis", 0]);
                case "TemplateElement":
                  return JSON.stringify(g.value.cooked);
                default:
                  throw new Error("unknown type: " + JSON.stringify(g.type));
              }
            }
            var i = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
            function l(c, y) {
              let { type: h } = c;
              if (h === "ObjectProperty" && c.key.type === "Identifier") {
                y.key = { type: "StringLiteral", value: c.key.name };
                return;
              }
              if (h === "UnaryExpression" && c.operator === "+")
                return y.argument;
              if (h === "ArrayExpression") {
                for (let [g, p] of c.elements.entries())
                  p === null && y.elements.splice(g, 0, { type: "NullLiteral" });
                return;
              }
              if (h === "TemplateLiteral")
                return { type: "StringLiteral", value: c.quasis[0].value.cooked };
            }
            l.ignoredProperties = i, n.exports = { preprocess: r, print: u, massageAstNode: l };
          } }), qt = ee({ "src/common/common-options.js"(e, n) {
            "use strict";
            re();
            var t = "Common";
            n.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
          } }), Xm = ee({ "src/language-js/options.js"(e, n) {
            "use strict";
            re();
            var t = qt(), s = "JavaScript";
            n.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
          } }), Km = ee({ "src/language-js/parse/parsers.js"() {
            re();
          } }), bn = ee({ "node_modules/linguist-languages/data/JavaScript.json"(e, n) {
            n.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
          } }), Ym = ee({ "node_modules/linguist-languages/data/TypeScript.json"(e, n) {
            n.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
          } }), Qm = ee({ "node_modules/linguist-languages/data/TSX.json"(e, n) {
            n.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
          } }), la = ee({ "node_modules/linguist-languages/data/JSON.json"(e, n) {
            n.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
          } }), Zm = ee({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, n) {
            n.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
          } }), ed = ee({ "node_modules/linguist-languages/data/JSON5.json"(e, n) {
            n.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
          } }), td = ee({ "src/language-js/index.js"(e, n) {
            "use strict";
            re();
            var t = wt(), s = Jm(), a = zm(), r = Xm(), u = Km(), i = [t(bn(), (c) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...c.interpreters, "zx"], extensions: [...c.extensions.filter((y) => y !== ".jsx"), ".wxs"] })), t(bn(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(bn(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(Ym(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(Qm(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(la(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(la(), (c) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: c.extensions.filter((y) => y !== ".jsonl") })), t(Zm(), (c) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...c.filenames, ".eslintrc", ".swcrc"] })), t(ed(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l = { estree: s, "estree-json": a };
            n.exports = { languages: i, options: r, printers: l, parsers: u };
          } }), rd = ee({ "src/language-css/clean.js"(e, n) {
            "use strict";
            re();
            var { isFrontMatterNode: t } = Ge(), s = lt(), a = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
            function r(i, l, c) {
              if (t(i) && i.lang === "yaml" && delete l.value, i.type === "css-comment" && c.type === "css-root" && c.nodes.length > 0 && ((c.nodes[0] === i || t(c.nodes[0]) && c.nodes[1] === i) && (delete l.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || c.type === "css-root" && s(c.nodes) === i))
                return null;
              if (i.type === "value-root" && delete l.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete l.value, i.type === "css-rule" && delete l.params, i.type === "selector-combinator" && (l.value = l.value.replace(/\s+/g, " ")), i.type === "media-feature" && (l.value = l.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(l.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (l.value = l.value.toLowerCase()), i.type === "css-decl" && (l.prop = l.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (l.name = l.name.toLowerCase()), i.type === "value-number" && (l.unit = l.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && l.value && (l.value = u(l.value)), i.type === "selector-attribute" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == "string" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = true)), l.value && (l.value = l.value.trim().replace(/^["']|["']$/g, ""), delete l.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && l.value && (l.value = l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (y, h, g) => {
                let p = Number(h);
                return Number.isNaN(p) ? y : p + g.toLowerCase();
              })), i.type === "selector-tag") {
                let y = i.value.toLowerCase();
                ["from", "to"].includes(y) && (l.value = y);
              }
              if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete l.value, i.type === "selector-unknown" && delete l.value, i.type === "value-comma_group") {
                let y = i.groups.findIndex((h) => h.type === "value-number" && h.unit === "...");
                y !== -1 && (l.groups[y].unit = "", l.groups.splice(y + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
              }
            }
            r.ignoredProperties = a;
            function u(i) {
              return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
            }
            n.exports = r;
          } }), Kn = ee({ "src/utils/front-matter/print.js"(e, n) {
            "use strict";
            re();
            var { builders: { hardline: t, markAsRoot: s } } = qe();
            function a(r, u) {
              if (r.lang === "yaml") {
                let i = r.value.trim(), l = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
                return s([r.startDelimiter, t, l, l ? t : "", r.endDelimiter]);
              }
            }
            n.exports = a;
          } }), nd = ee({ "src/language-css/embed.js"(e, n) {
            "use strict";
            re();
            var { builders: { hardline: t } } = qe(), s = Kn();
            function a(r, u, i) {
              let l = r.getValue();
              if (l.type === "front-matter") {
                let c = s(l, i);
                return c ? [c, t] : "";
              }
            }
            n.exports = a;
          } }), lo = ee({ "src/utils/front-matter/parse.js"(e, n) {
            "use strict";
            re();
            var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
            function s(a) {
              let r = a.match(t);
              if (!r)
                return { content: a };
              let { startDelimiter: u, language: i, value: l = "", endDelimiter: c } = r.groups, y = i.trim() || "yaml";
              if (u === "+++" && (y = "toml"), y !== "yaml" && u !== c)
                return { content: a };
              let [h] = r;
              return { frontMatter: { type: "front-matter", lang: y, value: l, startDelimiter: u, endDelimiter: c, raw: h.replace(/\n$/, "") }, content: h.replace(/[^\n]/g, " ") + a.slice(h.length) };
            }
            n.exports = s;
          } }), ud = ee({ "src/language-css/pragma.js"(e, n) {
            "use strict";
            re();
            var t = Qa(), s = lo();
            function a(u) {
              return t.hasPragma(s(u).content);
            }
            function r(u) {
              let { frontMatter: i, content: l } = s(u);
              return (i ? i.raw + `

` : "") + t.insertPragma(l);
            }
            n.exports = { hasPragma: a, insertPragma: r };
          } }), sd = ee({ "src/language-css/utils/index.js"(e, n) {
            "use strict";
            re();
            var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
            function s(z, H) {
              let Z = Array.isArray(H) ? H : [H], ne = -1, fe;
              for (; fe = z.getParentNode(++ne); )
                if (Z.includes(fe.type))
                  return ne;
              return -1;
            }
            function a(z, H) {
              let Z = s(z, H);
              return Z === -1 ? null : z.getParentNode(Z);
            }
            function r(z) {
              var H;
              let Z = a(z, "css-decl");
              return Z == null || (H = Z.prop) === null || H === void 0 ? void 0 : H.toLowerCase();
            }
            var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
            function i(z) {
              return u.has(z.toLowerCase());
            }
            function l(z, H) {
              let Z = a(z, "css-atrule");
              return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(H.toLowerCase());
            }
            function c(z) {
              return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
            }
            function y(z, H) {
              var Z;
              let ne = a(z, "value-func");
              return (ne == null || (Z = ne.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === H;
            }
            function h(z) {
              var H;
              let Z = a(z, "css-rule"), ne = Z == null || (H = Z.raws) === null || H === void 0 ? void 0 : H.selector;
              return ne && (ne.startsWith(":import") || ne.startsWith(":export"));
            }
            function g(z, H) {
              let Z = Array.isArray(H) ? H : [H], ne = a(z, "css-atrule");
              return ne && Z.includes(ne.name.toLowerCase());
            }
            function p(z) {
              let H = z.getValue(), Z = a(z, "css-atrule");
              return (Z == null ? void 0 : Z.name) === "import" && H.groups[0].value === "url" && H.groups.length === 2;
            }
            function D(z) {
              return z.type === "value-func" && z.value.toLowerCase() === "url";
            }
            function v(z, H) {
              var Z;
              let ne = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
              return ne && ne.indexOf(H) === ne.length - 1;
            }
            function w(z) {
              let { selector: H } = z;
              return H ? typeof H == "string" && /^@.+:.*$/.test(H) || H.value && /^@.+:.*$/.test(H.value) : false;
            }
            function T(z) {
              return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
            }
            function F(z) {
              return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
            }
            function A3(z) {
              return z.type === "value-word" && z.value === "in";
            }
            function B(z) {
              return z.type === "value-operator" && z.value === "*";
            }
            function I(z) {
              return z.type === "value-operator" && z.value === "/";
            }
            function P2(z) {
              return z.type === "value-operator" && z.value === "+";
            }
            function R(z) {
              return z.type === "value-operator" && z.value === "-";
            }
            function f(z) {
              return z.type === "value-operator" && z.value === "%";
            }
            function x(z) {
              return B(z) || I(z) || P2(z) || R(z) || f(z);
            }
            function m(z) {
              return z.type === "value-word" && ["==", "!="].includes(z.value);
            }
            function E(z) {
              return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
            }
            function o(z) {
              return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
            }
            function d(z) {
              var H;
              return ((H = z.raws) === null || H === void 0 ? void 0 : H.params) && /^\(\s*\)$/.test(z.raws.params);
            }
            function C(z) {
              return z.name.startsWith("prettier-placeholder");
            }
            function _(z) {
              return z.prop.startsWith("@prettier-placeholder");
            }
            function b(z, H) {
              return z.value === "$$" && z.type === "value-func" && (H == null ? void 0 : H.type) === "value-word" && !H.raws.before;
            }
            function N(z) {
              var H, Z;
              return ((H = z.value) === null || H === void 0 ? void 0 : H.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
            }
            function k(z) {
              var H, Z, ne;
              return ((H = z.value) === null || H === void 0 || (Z = H.group) === null || Z === void 0 || (ne = Z.group) === null || ne === void 0 ? void 0 : ne.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
            }
            function $(z) {
              var H;
              return ((H = z.raws) === null || H === void 0 ? void 0 : H.before) === "";
            }
            function M(z) {
              var H, Z;
              return z.type === "value-comma_group" && ((H = z.groups) === null || H === void 0 || (Z = H[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
            }
            function q(z) {
              var H;
              return z.type === "value-paren_group" && ((H = z.groups) === null || H === void 0 ? void 0 : H[0]) && M(z.groups[0]);
            }
            function J(z) {
              var H;
              let Z = z.getValue();
              if (Z.groups.length === 0)
                return false;
              let ne = z.getParentNode(1);
              if (!q(Z) && !(ne && q(ne)))
                return false;
              let fe = a(z, "css-decl");
              return !!(fe != null && (H = fe.prop) !== null && H !== void 0 && H.startsWith("$") || q(ne) || ne.type === "value-func");
            }
            function L(z) {
              return z.type === "value-comment" && z.inline;
            }
            function Y(z) {
              return z.type === "value-word" && z.value === "#";
            }
            function V(z) {
              return z.type === "value-word" && z.value === "{";
            }
            function O(z) {
              return z.type === "value-word" && z.value === "}";
            }
            function K(z) {
              return ["value-word", "value-atword"].includes(z.type);
            }
            function se(z) {
              return (z == null ? void 0 : z.type) === "value-colon";
            }
            function Q(z, H) {
              if (!M(H))
                return false;
              let { groups: Z } = H, ne = Z.indexOf(z);
              return ne === -1 ? false : se(Z[ne + 1]);
            }
            function le(z) {
              return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
            }
            function W(z) {
              return z.type !== "value-func" ? false : t.has(z.value.toLowerCase());
            }
            function X(z) {
              return /\/\//.test(z.split(/[\n\r]/).pop());
            }
            function oe(z) {
              return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
            }
            function ae(z, H) {
              var Z, ne;
              if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((ne = z.close) === null || ne === void 0 ? void 0 : ne.value) !== ")" || z.groups.some((fe) => fe.type !== "value-comma_group"))
                return false;
              if (H.type === "value-comma_group") {
                let fe = H.groups.indexOf(z) - 1, ge = H.groups[fe];
                if ((ge == null ? void 0 : ge.type) === "value-word" && ge.value === "with")
                  return true;
              }
              return false;
            }
            function Ae(z) {
              var H, Z;
              return z.type === "value-paren_group" && ((H = z.open) === null || H === void 0 ? void 0 : H.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
            }
            n.exports = { getAncestorCounter: s, getAncestorNode: a, getPropOfDeclNode: r, maybeToLowerCase: c, insideValueFunctionNode: y, insideICSSRuleNode: h, insideAtRuleNode: g, insideURLFunctionInImportAtRuleNode: p, isKeyframeAtRuleKeywords: l, isWideKeywords: i, isLastNode: v, isSCSSControlDirectiveNode: o, isDetachedRulesetDeclarationNode: w, isRelationalOperatorNode: E, isEqualityOperatorNode: m, isMultiplicationNode: B, isDivisionNode: I, isAdditionNode: P2, isSubtractionNode: R, isModuloNode: f, isMathOperatorNode: x, isEachKeywordNode: A3, isForKeywordNode: T, isURLFunctionNode: D, isIfElseKeywordNode: F, hasComposesNode: N, hasParensAroundNode: k, hasEmptyRawBefore: $, isDetachedRulesetCallNode: d, isTemplatePlaceholderNode: C, isTemplatePropNode: _, isPostcssSimpleVarNode: b, isKeyValuePairNode: M, isKeyValuePairInParenGroupNode: q, isKeyInValuePairNode: Q, isSCSSMapItemNode: J, isInlineValueCommentNode: L, isHashNode: Y, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: O, isWordNode: K, isColonNode: se, isMediaAndSupportsKeywords: le, isColorAdjusterFuncNode: W, lastLineHasInlineComment: X, isAtWordPlaceholderNode: oe, isConfigurationNode: ae, isParenGroupNode: Ae };
          } }), id = ee({ "src/utils/line-column-to-index.js"(e, n) {
            "use strict";
            re(), n.exports = function(t, s) {
              let a = 0;
              for (let r = 0; r < t.line - 1; ++r)
                a = s.indexOf(`
`, a) + 1;
              return a + t.column;
            };
          } }), ad = ee({ "src/language-css/loc.js"(e, n) {
            "use strict";
            re();
            var { skipEverythingButNewLine: t } = _r(), s = lt(), a = id();
            function r(p, D) {
              return typeof p.sourceIndex == "number" ? p.sourceIndex : p.source ? a(p.source.start, D) - 1 : null;
            }
            function u(p, D) {
              if (p.type === "css-comment" && p.inline)
                return t(D, p.source.startOffset);
              let v = p.nodes && s(p.nodes);
              return v && p.source && !p.source.end && (p = v), p.source && p.source.end ? a(p.source.end, D) : null;
            }
            function i(p, D) {
              p.source && (p.source.startOffset = r(p, D), p.source.endOffset = u(p, D));
              for (let v in p) {
                let w = p[v];
                v === "source" || !w || typeof w != "object" || (w.type === "value-root" || w.type === "value-unknown" ? l(w, c(p), w.text || w.value) : i(w, D));
              }
            }
            function l(p, D, v) {
              p.source && (p.source.startOffset = r(p, v) + D, p.source.endOffset = u(p, v) + D);
              for (let w in p) {
                let T = p[w];
                w === "source" || !T || typeof T != "object" || l(T, D, v);
              }
            }
            function c(p) {
              let D = p.source.startOffset;
              return typeof p.prop == "string" && (D += p.prop.length), p.type === "css-atrule" && typeof p.name == "string" && (D += 1 + p.name.length + p.raws.afterName.match(/^\s*:?\s*/)[0].length), p.type !== "css-atrule" && p.raws && typeof p.raws.between == "string" && (D += p.raws.between.length), D;
            }
            function y(p) {
              let D = "initial", v = "initial", w, T = false, F = [];
              for (let A3 = 0; A3 < p.length; A3++) {
                let B = p[A3];
                switch (D) {
                  case "initial":
                    if (B === "'") {
                      D = "single-quotes";
                      continue;
                    }
                    if (B === '"') {
                      D = "double-quotes";
                      continue;
                    }
                    if ((B === "u" || B === "U") && p.slice(A3, A3 + 4).toLowerCase() === "url(") {
                      D = "url", A3 += 3;
                      continue;
                    }
                    if (B === "*" && p[A3 - 1] === "/") {
                      D = "comment-block";
                      continue;
                    }
                    if (B === "/" && p[A3 - 1] === "/") {
                      D = "comment-inline", w = A3 - 1;
                      continue;
                    }
                    continue;
                  case "single-quotes":
                    if (B === "'" && p[A3 - 1] !== "\\" && (D = v, v = "initial"), B === `
` || B === "\r")
                      return p;
                    continue;
                  case "double-quotes":
                    if (B === '"' && p[A3 - 1] !== "\\" && (D = v, v = "initial"), B === `
` || B === "\r")
                      return p;
                    continue;
                  case "url":
                    if (B === ")" && (D = "initial"), B === `
` || B === "\r")
                      return p;
                    if (B === "'") {
                      D = "single-quotes", v = "url";
                      continue;
                    }
                    if (B === '"') {
                      D = "double-quotes", v = "url";
                      continue;
                    }
                    continue;
                  case "comment-block":
                    B === "/" && p[A3 - 1] === "*" && (D = "initial");
                    continue;
                  case "comment-inline":
                    (B === '"' || B === "'" || B === "*") && (T = true), (B === `
` || B === "\r") && (T && F.push([w, A3]), D = "initial", T = false);
                    continue;
                }
              }
              for (let [A3, B] of F)
                p = p.slice(0, A3) + p.slice(A3, B).replace(/["'*]/g, " ") + p.slice(B);
              return p;
            }
            function h(p) {
              return p.source.startOffset;
            }
            function g(p) {
              return p.source.endOffset;
            }
            n.exports = { locStart: h, locEnd: g, calculateLoc: i, replaceQuotesInInlineComments: y };
          } }), od = ee({ "src/language-css/utils/is-less-parser.js"(e, n) {
            "use strict";
            re();
            function t(s) {
              return s.parser === "css" || s.parser === "less";
            }
            n.exports = t;
          } }), ld = ee({ "src/language-css/utils/is-scss.js"(e, n) {
            "use strict";
            re();
            function t(s, a) {
              return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
            }
            n.exports = t;
          } }), cd = ee({ "src/language-css/utils/css-units.evaluate.js"(e, n) {
            n.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
          } }), pd = ee({ "src/language-css/utils/print-unit.js"(e, n) {
            "use strict";
            re();
            var t = cd();
            function s(a) {
              let r = a.toLowerCase();
              return Object.prototype.hasOwnProperty.call(t, r) ? t[r] : a;
            }
            n.exports = s;
          } }), fd = ee({ "src/language-css/printer-postcss.js"(e, n) {
            "use strict";
            re();
            var t = lt(), { printNumber: s, printString: a, hasNewline: r, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: l } = Ge(), { builders: { join: c, line: y, hardline: h, softline: g, group: p, fill: D, indent: v, dedent: w, ifBreak: T, breakParent: F }, utils: { removeLines: A3, getDocParts: B } } = qe(), I = rd(), P2 = nd(), { insertPragma: R } = ud(), { getAncestorNode: f, getPropOfDeclNode: x, maybeToLowerCase: m, insideValueFunctionNode: E, insideICSSRuleNode: o, insideAtRuleNode: d, insideURLFunctionInImportAtRuleNode: C, isKeyframeAtRuleKeywords: _, isWideKeywords: b, isLastNode: N, isSCSSControlDirectiveNode: k, isDetachedRulesetDeclarationNode: $, isRelationalOperatorNode: M, isEqualityOperatorNode: q, isMultiplicationNode: J, isDivisionNode: L, isAdditionNode: Y, isSubtractionNode: V, isMathOperatorNode: O, isEachKeywordNode: K, isForKeywordNode: se, isURLFunctionNode: Q, isIfElseKeywordNode: le, hasComposesNode: W, hasParensAroundNode: X, hasEmptyRawBefore: oe, isKeyValuePairNode: ae, isKeyInValuePairNode: Ae, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: H, isTemplatePropNode: Z, isPostcssSimpleVarNode: ne, isSCSSMapItemNode: fe, isInlineValueCommentNode: ge, isHashNode: Ce, isLeftCurlyBraceNode: _e, isRightCurlyBraceNode: Oe, isWordNode: pe, isColonNode: ie, isMediaAndSupportsKeywords: ve, isColorAdjusterFuncNode: ce, lastLineHasInlineComment: U, isAtWordPlaceholderNode: de, isConfigurationNode: De, isParenGroupNode: he } = sd(), { locStart: Be, locEnd: Se } = ad(), ye = od(), S = ld(), G = pd();
            function te(be) {
              return be.trailingComma === "es5" || be.trailingComma === "all";
            }
            function Ee(be, ke, Me) {
              let ue = be.getValue();
              if (!ue)
                return "";
              if (typeof ue == "string")
                return ue;
              switch (ue.type) {
                case "front-matter":
                  return [ue.raw, h];
                case "css-root": {
                  let He = Re(be, ke, Me), Ue = ue.raws.after.trim();
                  return [He, Ue ? ` ${Ue}` : "", B(He).length > 0 ? h : ""];
                }
                case "css-comment": {
                  let He = ue.inline || ue.raws.inline, Ue = ke.originalText.slice(Be(ue), Se(ue));
                  return He ? Ue.trimEnd() : Ue;
                }
                case "css-rule":
                  return [Me("selector"), ue.important ? " !important" : "", ue.nodes ? [ue.selector && ue.selector.type === "selector-unknown" && U(ue.selector.value) ? y : " ", "{", ue.nodes.length > 0 ? v([h, Re(be, ke, Me)]) : "", h, "}", $(ue) ? ";" : ""] : ";"];
                case "css-decl": {
                  let He = be.getParentNode(), { between: Ue } = ue.raws, Xe = Ue.trim(), at = Xe === ":", nt = W(ue) ? A3(Me("value")) : Me("value");
                  return !at && U(Xe) && (nt = v([h, w(nt)])), [ue.raws.before.replace(/[\s;]/g, ""), o(be) ? ue.prop : m(ue.prop), Xe.startsWith("//") ? " " : "", Xe, ue.extend ? "" : " ", ye(ke) && ue.extend && ue.selector ? ["extend(", Me("selector"), ")"] : "", nt, ue.raws.important ? ue.raws.important.replace(/\s*!\s*important/i, " !important") : ue.important ? " !important" : "", ue.raws.scssDefault ? ue.raws.scssDefault.replace(/\s*!default/i, " !default") : ue.scssDefault ? " !default" : "", ue.raws.scssGlobal ? ue.raws.scssGlobal.replace(/\s*!global/i, " !global") : ue.scssGlobal ? " !global" : "", ue.nodes ? [" {", v([g, Re(be, ke, Me)]), g, "}"] : Z(ue) && !He.raws.semicolon && ke.originalText[Se(ue) - 1] !== ";" ? "" : ke.__isHTMLStyleAttribute && N(be, ue) ? T(";") : ";"];
                }
                case "css-atrule": {
                  let He = be.getParentNode(), Ue = H(ue) && !He.raws.semicolon && ke.originalText[Se(ue) - 1] !== ";";
                  if (ye(ke)) {
                    if (ue.mixin)
                      return [Me("selector"), ue.important ? " !important" : "", Ue ? "" : ";"];
                    if (ue.function)
                      return [ue.name, Me("params"), Ue ? "" : ";"];
                    if (ue.variable)
                      return ["@", ue.name, ": ", ue.value ? Me("value") : "", ue.raws.between.trim() ? ue.raws.between.trim() + " " : "", ue.nodes ? ["{", v([ue.nodes.length > 0 ? g : "", Re(be, ke, Me)]), g, "}"] : "", Ue ? "" : ";"];
                  }
                  return ["@", z(ue) || ue.name.endsWith(":") ? ue.name : m(ue.name), ue.params ? [z(ue) ? "" : H(ue) ? ue.raws.afterName === "" ? "" : ue.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ue.raws.afterName) ? [h, h] : /^\s*\n/.test(ue.raws.afterName) ? h : " " : " ", Me("params")] : "", ue.selector ? v([" ", Me("selector")]) : "", ue.value ? p([" ", Me("value"), k(ue) ? X(ue) ? " " : y : ""]) : ue.name === "else" ? " " : "", ue.nodes ? [k(ue) ? "" : ue.selector && !ue.selector.nodes && typeof ue.selector.value == "string" && U(ue.selector.value) || !ue.selector && typeof ue.params == "string" && U(ue.params) ? y : " ", "{", v([ue.nodes.length > 0 ? g : "", Re(be, ke, Me)]), g, "}"] : Ue ? "" : ";"];
                }
                case "media-query-list": {
                  let He = [];
                  return be.each((Ue) => {
                    let Xe = Ue.getValue();
                    Xe.type === "media-query" && Xe.value === "" || He.push(Me());
                  }, "nodes"), p(v(c(y, He)));
                }
                case "media-query":
                  return [c(" ", be.map(Me, "nodes")), N(be, ue) ? "" : ","];
                case "media-type":
                  return Le(Je(ue.value, ke));
                case "media-feature-expression":
                  return ue.nodes ? ["(", ...be.map(Me, "nodes"), ")"] : ue.value;
                case "media-feature":
                  return m(Je(ue.value.replace(/ +/g, " "), ke));
                case "media-colon":
                  return [ue.value, " "];
                case "media-value":
                  return Le(Je(ue.value, ke));
                case "media-keyword":
                  return Je(ue.value, ke);
                case "media-url":
                  return Je(ue.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), ke);
                case "media-unknown":
                  return ue.value;
                case "selector-root":
                  return p([d(be, "custom-selector") ? [f(be, "css-atrule").customSelector, y] : "", c([",", d(be, ["extend", "custom-selector", "nest"]) ? y : h], be.map(Me, "nodes"))]);
                case "selector-selector":
                  return p(v(be.map(Me, "nodes")));
                case "selector-comment":
                  return ue.value;
                case "selector-string":
                  return Je(ue.value, ke);
                case "selector-tag": {
                  let He = be.getParentNode(), Ue = He && He.nodes.indexOf(ue), Xe = Ue && He.nodes[Ue - 1];
                  return [ue.namespace ? [ue.namespace === true ? "" : ue.namespace.trim(), "|"] : "", Xe.type === "selector-nesting" ? ue.value : Le(_(be, ue.value) ? ue.value.toLowerCase() : ue.value)];
                }
                case "selector-id":
                  return ["#", ue.value];
                case "selector-class":
                  return [".", Le(Je(ue.value, ke))];
                case "selector-attribute": {
                  var st;
                  return ["[", ue.namespace ? [ue.namespace === true ? "" : ue.namespace.trim(), "|"] : "", ue.attribute.trim(), (st = ue.operator) !== null && st !== void 0 ? st : "", ue.value ? we(Je(ue.value.trim(), ke), ke) : "", ue.insensitive ? " i" : "", "]"];
                }
                case "selector-combinator": {
                  if (ue.value === "+" || ue.value === ">" || ue.value === "~" || ue.value === ">>>") {
                    let Xe = be.getParentNode();
                    return [Xe.type === "selector-selector" && Xe.nodes[0] === ue ? "" : y, ue.value, N(be, ue) ? "" : " "];
                  }
                  let He = ue.value.trim().startsWith("(") ? y : "", Ue = Le(Je(ue.value.trim(), ke)) || y;
                  return [He, Ue];
                }
                case "selector-universal":
                  return [ue.namespace ? [ue.namespace === true ? "" : ue.namespace.trim(), "|"] : "", ue.value];
                case "selector-pseudo":
                  return [m(ue.value), l(ue.nodes) ? p(["(", v([g, c([",", y], be.map(Me, "nodes"))]), g, ")"]) : ""];
                case "selector-nesting":
                  return ue.value;
                case "selector-unknown": {
                  let He = f(be, "css-rule");
                  if (He && He.isSCSSNesterProperty)
                    return Le(Je(m(ue.value), ke));
                  let Ue = be.getParentNode();
                  if (Ue.raws && Ue.raws.selector) {
                    let at = Be(Ue), nt = at + Ue.raws.selector.length;
                    return ke.originalText.slice(at, nt).trim();
                  }
                  let Xe = be.getParentNode(1);
                  if (Ue.type === "value-paren_group" && Xe && Xe.type === "value-func" && Xe.value === "selector") {
                    let at = Se(Ue.open) + 1, nt = Be(Ue.close), j = ke.originalText.slice(at, nt).trim();
                    return U(j) ? [F, j] : j;
                  }
                  return ue.value;
                }
                case "value-value":
                case "value-root":
                  return Me("group");
                case "value-comment":
                  return ke.originalText.slice(Be(ue), Se(ue));
                case "value-comma_group": {
                  let He = be.getParentNode(), Ue = be.getParentNode(1), Xe = x(be), at = Xe && He.type === "value-value" && (Xe === "grid" || Xe.startsWith("grid-template")), nt = f(be, "css-atrule"), j = nt && k(nt), me = ue.groups.some((ot) => ge(ot)), Ie = be.map(Me, "groups"), je = [], Ye = E(be, "url"), ut = false, ze = false;
                  for (let ot = 0; ot < ue.groups.length; ++ot) {
                    var rt;
                    je.push(Ie[ot]);
                    let tt = ue.groups[ot - 1], $e = ue.groups[ot], We = ue.groups[ot + 1], nr = ue.groups[ot + 2];
                    if (Ye) {
                      (We && Y(We) || Y($e)) && je.push(" ");
                      continue;
                    }
                    if (d(be, "forward") && $e.type === "value-word" && $e.value && tt !== void 0 && tt.type === "value-word" && tt.value === "as" && We.type === "value-operator" && We.value === "*" || !We || $e.type === "value-word" && $e.value.endsWith("-") && de(We))
                      continue;
                    let go = $e.type === "value-string" && $e.value.startsWith("#{"), yo = ut && We.type === "value-string" && We.value.endsWith("}");
                    if (go || yo) {
                      ut = !ut;
                      continue;
                    }
                    if (ut || ie($e) || ie(We) || $e.type === "value-atword" && $e.value === "" || $e.value === "~" || $e.value && $e.value.includes("\\") && We && We.type !== "value-comment" || tt && tt.value && tt.value.indexOf("\\") === tt.value.length - 1 && $e.type === "value-operator" && $e.value === "/" || $e.value === "\\" || ne($e, We) || Ce($e) || _e($e) || Oe(We) || _e(We) && oe(We) || Oe($e) && oe(We) || $e.value === "--" && Ce(We))
                      continue;
                    let Zn = O($e), eu = O(We);
                    if ((Zn && Ce(We) || eu && Oe($e)) && oe(We) || !tt && L($e) || E(be, "calc") && (Y($e) || Y(We) || V($e) || V(We)) && oe(We))
                      continue;
                    let ho = (Y($e) || V($e)) && ot === 0 && (We.type === "value-number" || We.isHex) && Ue && ce(Ue) && !oe(We), tu = nr && nr.type === "value-func" || nr && pe(nr) || $e.type === "value-func" || pe($e), ru = We.type === "value-func" || pe(We) || tt && tt.type === "value-func" || tt && pe(tt);
                    if (!(!(J(We) || J($e)) && !E(be, "calc") && !ho && (L(We) && !tu || L($e) && !ru || Y(We) && !tu || Y($e) && !ru || V(We) || V($e)) && (oe(We) || Zn && (!tt || tt && O(tt))))) {
                      if (ge($e)) {
                        if (He.type === "value-paren_group") {
                          je.push(w(h));
                          continue;
                        }
                        je.push(h);
                        continue;
                      }
                      if (j && (q(We) || M(We) || le(We) || K($e) || se($e))) {
                        je.push(" ");
                        continue;
                      }
                      if (nt && nt.name.toLowerCase() === "namespace") {
                        je.push(" ");
                        continue;
                      }
                      if (at) {
                        $e.source && We.source && $e.source.start.line !== We.source.start.line ? (je.push(h), ze = true) : je.push(" ");
                        continue;
                      }
                      if (eu) {
                        je.push(" ");
                        continue;
                      }
                      if (!(We && We.value === "...") && !(de($e) && de(We) && Se($e) === Be(We))) {
                        if (de($e) && he(We) && Se($e) === Be(We.open)) {
                          je.push(g);
                          continue;
                        }
                        if ($e.value === "with" && he(We)) {
                          je.push(" ");
                          continue;
                        }
                        (rt = $e.value) !== null && rt !== void 0 && rt.endsWith("#") && We.value === "{" && he(We.group) || je.push(y);
                      }
                    }
                  }
                  return me && je.push(F), ze && je.unshift(h), j ? p(v(je)) : C(be) ? p(D(je)) : p(v(D(je)));
                }
                case "value-paren_group": {
                  let He = be.getParentNode();
                  if (He && Q(He) && (ue.groups.length === 1 || ue.groups.length > 0 && ue.groups[0].type === "value-comma_group" && ue.groups[0].groups.length > 0 && ue.groups[0].groups[0].type === "value-word" && ue.groups[0].groups[0].value.startsWith("data:")))
                    return [ue.open ? Me("open") : "", c(",", be.map(Me, "groups")), ue.close ? Me("close") : ""];
                  if (!ue.open) {
                    let Ye = be.map(Me, "groups"), ut = [];
                    for (let ze = 0; ze < Ye.length; ze++)
                      ze !== 0 && ut.push([",", y]), ut.push(Ye[ze]);
                    return p(v(D(ut)));
                  }
                  let Ue = fe(be), Xe = t(ue.groups), at = Xe && Xe.type === "value-comment", nt = Ae(ue, He), j = De(ue, He), me = j || Ue && !nt, Ie = j || nt, je = p([ue.open ? Me("open") : "", v([g, c([y], be.map((Ye, ut) => {
                    let ze = Ye.getValue(), ot = ut === ue.groups.length - 1, tt = [Me(), ot ? "" : ","];
                    if (ae(ze) && ze.type === "value-comma_group" && ze.groups && ze.groups[0].type !== "value-paren_group" && ze.groups[2] && ze.groups[2].type === "value-paren_group") {
                      let $e = B(tt[0].contents.contents);
                      return $e[1] = p($e[1]), p(w(tt));
                    }
                    if (!ot && ze.type === "value-comma_group" && l(ze.groups)) {
                      let $e = t(ze.groups);
                      $e.source && i(ke.originalText, $e, Se) && tt.push(h);
                    }
                    return tt;
                  }, "groups"))]), T(!at && S(ke.parser, ke.originalText) && Ue && te(ke) ? "," : ""), g, ue.close ? Me("close") : ""], { shouldBreak: me });
                  return Ie ? w(je) : je;
                }
                case "value-func":
                  return [ue.value, d(be, "supports") && ve(ue) ? " " : "", Me("group")];
                case "value-paren":
                  return ue.value;
                case "value-number":
                  return [Ve(ue.value), G(ue.unit)];
                case "value-operator":
                  return ue.value;
                case "value-word":
                  return ue.isColor && ue.isHex || b(ue.value) ? ue.value.toLowerCase() : ue.value;
                case "value-colon": {
                  let He = be.getParentNode(), Ue = He && He.groups.indexOf(ue), Xe = Ue && He.groups[Ue - 1];
                  return [ue.value, Xe && typeof Xe.value == "string" && t(Xe.value) === "\\" || E(be, "url") ? "" : y];
                }
                case "value-comma":
                  return [ue.value, " "];
                case "value-string":
                  return a(ue.raws.quote + ue.value + ue.raws.quote, ke);
                case "value-atword":
                  return ["@", ue.value];
                case "value-unicode-range":
                  return ue.value;
                case "value-unknown":
                  return ue.value;
                default:
                  throw new Error(`Unknown postcss type ${JSON.stringify(ue.type)}`);
              }
            }
            function Re(be, ke, Me) {
              let ue = [];
              return be.each((st, rt, He) => {
                let Ue = He[rt - 1];
                if (Ue && Ue.type === "css-comment" && Ue.text.trim() === "prettier-ignore") {
                  let Xe = st.getValue();
                  ue.push(ke.originalText.slice(Be(Xe), Se(Xe)));
                } else
                  ue.push(Me());
                rt !== He.length - 1 && (He[rt + 1].type === "css-comment" && !r(ke.originalText, Be(He[rt + 1]), { backwards: true }) && !u(He[rt]) || He[rt + 1].type === "css-atrule" && He[rt + 1].name === "else" && He[rt].type !== "css-comment" ? ue.push(" ") : (ue.push(ke.__isHTMLStyleAttribute ? y : h), i(ke.originalText, st.getValue(), Se) && !u(He[rt]) && ue.push(h)));
              }, "nodes"), ue;
            }
            var Te = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, Pe = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, Fe = /[A-Za-z]+/g, Ze = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, xe = new RegExp(Te.source + `|(${Ze.source})?(${Pe.source})(${Fe.source})?`, "g");
            function Je(be, ke) {
              return be.replace(Te, (Me) => a(Me, ke));
            }
            function we(be, ke) {
              let Me = ke.singleQuote ? "'" : '"';
              return be.includes('"') || be.includes("'") ? be : Me + be + Me;
            }
            function Le(be) {
              return be.replace(xe, (ke, Me, ue, st, rt) => !ue && st ? Ve(st) + m(rt || "") : ke);
            }
            function Ve(be) {
              return s(be).replace(/\.0(?=$|e)/, "");
            }
            n.exports = { print: Ee, embed: P2, insertPragma: R, massageAstNode: I };
          } }), Dd = ee({ "src/language-css/options.js"(e, n) {
            "use strict";
            re();
            var t = qt();
            n.exports = { singleQuote: t.singleQuote };
          } }), md = ee({ "src/language-css/parsers.js"() {
            re();
          } }), dd = ee({ "node_modules/linguist-languages/data/CSS.json"(e, n) {
            n.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
          } }), gd = ee({ "node_modules/linguist-languages/data/PostCSS.json"(e, n) {
            n.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
          } }), yd = ee({ "node_modules/linguist-languages/data/Less.json"(e, n) {
            n.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
          } }), hd = ee({ "node_modules/linguist-languages/data/SCSS.json"(e, n) {
            n.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
          } }), vd = ee({ "src/language-css/index.js"(e, n) {
            "use strict";
            re();
            var t = wt(), s = fd(), a = Dd(), r = md(), u = [t(dd(), (l) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l.extensions, ".wxss"] })), t(gd(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(yd(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(hd(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s };
            n.exports = { languages: u, options: a, printers: i, parsers: r };
          } }), Cd = ee({ "src/language-handlebars/loc.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return a.loc.start.offset;
            }
            function s(a) {
              return a.loc.end.offset;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), Ed = ee({ "src/language-handlebars/clean.js"(e, n) {
            "use strict";
            re();
            function t(s, a) {
              if (s.type === "TextNode") {
                let r = s.chars.trim();
                if (!r)
                  return null;
                a.chars = r.replace(/[\t\n\f\r ]+/g, " ");
              }
              s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a.value;
            }
            t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), n.exports = t;
          } }), Fd = ee({ "vendors/html-void-elements.json"(e, n) {
            n.exports = { htmlVoidElements: ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"] };
          } }), Ad = ee({ "src/language-handlebars/utils.js"(e, n) {
            "use strict";
            re();
            var { htmlVoidElements: t } = Fd(), s = lt();
            function a(A3) {
              let B = A3.getValue(), I = A3.getParentNode(0);
              return !!(h(A3, ["ElementNode"]) && s(I.children) === B || h(A3, ["Block"]) && s(I.body) === B);
            }
            function r(A3) {
              return A3.toUpperCase() === A3;
            }
            function u(A3) {
              return y(A3, ["ElementNode"]) && typeof A3.tag == "string" && !A3.tag.startsWith(":") && (r(A3.tag[0]) || A3.tag.includes("."));
            }
            var i = new Set(t);
            function l(A3) {
              return i.has(A3.tag) || u(A3) && A3.children.every((B) => c(B));
            }
            function c(A3) {
              return y(A3, ["TextNode"]) && !/\S/.test(A3.chars);
            }
            function y(A3, B) {
              return A3 && B.includes(A3.type);
            }
            function h(A3, B) {
              let I = A3.getParentNode(0);
              return y(I, B);
            }
            function g(A3, B) {
              let I = v(A3);
              return y(I, B);
            }
            function p(A3, B) {
              let I = w(A3);
              return y(I, B);
            }
            function D(A3, B) {
              var I, P2, R, f;
              let x = A3.getValue(), m = (I = A3.getParentNode(0)) !== null && I !== void 0 ? I : {}, E = (P2 = (R = (f = m.children) !== null && f !== void 0 ? f : m.body) !== null && R !== void 0 ? R : m.parts) !== null && P2 !== void 0 ? P2 : [], o = E.indexOf(x);
              return o !== -1 && E[o + B];
            }
            function v(A3) {
              let B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
              return D(A3, -B);
            }
            function w(A3) {
              return D(A3, 1);
            }
            function T(A3) {
              return y(A3, ["MustacheCommentStatement"]) && typeof A3.value == "string" && A3.value.trim() === "prettier-ignore";
            }
            function F(A3) {
              let B = A3.getValue(), I = v(A3, 2);
              return T(B) || T(I);
            }
            n.exports = { getNextNode: w, getPreviousNode: v, hasPrettierIgnore: F, isLastNodeOfSiblings: a, isNextNodeOfSomeType: p, isNodeOfSomeType: y, isParentOfSomeType: h, isPreviousNodeOfSomeType: g, isVoid: l, isWhitespaceNode: c };
          } }), Sd = ee({ "src/language-handlebars/printer-glimmer.js"(e, n) {
            "use strict";
            re();
            var { builders: { dedent: t, fill: s, group: a, hardline: r, ifBreak: u, indent: i, join: l, line: c, softline: y }, utils: { getDocParts: h, replaceTextEndOfLine: g } } = qe(), { getPreferredQuote: p, isNonEmptyArray: D } = Ge(), { locStart: v, locEnd: w } = Cd(), T = Ed(), { getNextNode: F, getPreviousNode: A3, hasPrettierIgnore: B, isLastNodeOfSiblings: I, isNextNodeOfSomeType: P2, isNodeOfSomeType: R, isParentOfSomeType: f, isPreviousNodeOfSomeType: x, isVoid: m, isWhitespaceNode: E } = Ad(), o = 2;
            function d(U, de, De) {
              let he = U.getValue();
              if (!he)
                return "";
              if (B(U))
                return de.originalText.slice(v(he), w(he));
              let Be = de.singleQuote ? "'" : '"';
              switch (he.type) {
                case "Block":
                case "Program":
                case "Template":
                  return a(U.map(De, "body"));
                case "ElementNode": {
                  let Se = a(_(U, De)), ye = de.htmlWhitespaceSensitivity === "ignore" && P2(U, ["ElementNode"]) ? y : "";
                  if (m(he))
                    return [Se, ye];
                  let S = ["</", he.tag, ">"];
                  return he.children.length === 0 ? [Se, i(S), ye] : de.htmlWhitespaceSensitivity === "ignore" ? [Se, i(b(U, de, De)), r, i(S), ye] : [Se, i(a(b(U, de, De))), i(S), ye];
                }
                case "BlockStatement": {
                  let Se = U.getParentNode(1);
                  return Se && Se.inverse && Se.inverse.body.length === 1 && Se.inverse.body[0] === he && Se.inverse.body[0].path.parts[0] === Se.path.parts[0] ? [se(U, De, Se.inverse.body[0].path.parts[0]), oe(U, De, de), ae(U, De, de)] : [O(U, De), a([oe(U, De, de), ae(U, De, de), Q(U, De, de)])];
                }
                case "ElementModifierStatement":
                  return a(["{{", pe(U, De), "}}"]);
                case "MustacheStatement":
                  return a([k(he), pe(U, De), $(he)]);
                case "SubExpression":
                  return a(["(", Oe(U, De), y, ")"]);
                case "AttrNode": {
                  let Se = he.value.type === "TextNode";
                  if (Se && he.value.chars === "" && v(he.value) === w(he.value))
                    return he.name;
                  let S = Se ? p(he.value.chars, Be).quote : he.value.type === "ConcatStatement" ? p(he.value.parts.filter((te) => te.type === "TextNode").map((te) => te.chars).join(""), Be).quote : "", G = De("value");
                  return [he.name, "=", S, he.name === "class" && S ? a(i(G)) : G, S];
                }
                case "ConcatStatement":
                  return U.map(De, "parts");
                case "Hash":
                  return l(c, U.map(De, "pairs"));
                case "HashPair":
                  return [he.key, "=", De("value")];
                case "TextNode": {
                  let Se = he.chars.replace(/{{/g, "\\{{"), ye = H(U);
                  if (ye) {
                    if (ye === "class") {
                      let xe = Se.trim().split(/\s+/).join(" "), Je = false, we = false;
                      return f(U, ["ConcatStatement"]) && (x(U, ["MustacheStatement"]) && /^\s/.test(Se) && (Je = true), P2(U, ["MustacheStatement"]) && /\s$/.test(Se) && xe !== "" && (we = true)), [Je ? c : "", xe, we ? c : ""];
                    }
                    return g(Se);
                  }
                  let G = /^[\t\n\f\r ]*$/.test(Se), te = !A3(U), Ee = !F(U);
                  if (de.htmlWhitespaceSensitivity !== "ignore") {
                    let xe = /^[\t\n\f\r ]*/, Je = /[\t\n\f\r ]*$/, we = Ee && f(U, ["Template"]), Le = te && f(U, ["Template"]);
                    if (G) {
                      if (Le || we)
                        return "";
                      let ue = [c], st = Z(Se);
                      return st && (ue = ge(st)), I(U) && (ue = ue.map((rt) => t(rt))), ue;
                    }
                    let [Ve] = Se.match(xe), [be] = Se.match(Je), ke = [];
                    if (Ve) {
                      ke = [c];
                      let ue = Z(Ve);
                      ue && (ke = ge(ue)), Se = Se.replace(xe, "");
                    }
                    let Me = [];
                    if (be) {
                      if (!we) {
                        Me = [c];
                        let ue = Z(be);
                        ue && (Me = ge(ue)), I(U) && (Me = Me.map((st) => t(st)));
                      }
                      Se = Se.replace(Je, "");
                    }
                    return [...ke, s(Ae(Se)), ...Me];
                  }
                  let Re = Z(Se), Te = ne(Se), Pe = fe(Se);
                  if ((te || Ee) && G && f(U, ["Block", "ElementNode", "Template"]))
                    return "";
                  G && Re ? (Te = Math.min(Re, o), Pe = 0) : (P2(U, ["BlockStatement", "ElementNode"]) && (Pe = Math.max(Pe, 1)), x(U, ["BlockStatement", "ElementNode"]) && (Te = Math.max(Te, 1)));
                  let Fe = "", Ze = "";
                  return Pe === 0 && P2(U, ["MustacheStatement"]) && (Ze = " "), Te === 0 && x(U, ["MustacheStatement"]) && (Fe = " "), te && (Te = 0, Fe = ""), Ee && (Pe = 0, Ze = ""), Se = Se.replace(/^[\t\n\f\r ]+/g, Fe).replace(/[\t\n\f\r ]+$/, Ze), [...ge(Te), s(Ae(Se)), ...ge(Pe)];
                }
                case "MustacheCommentStatement": {
                  let Se = v(he), ye = w(he), S = de.originalText.charAt(Se + 2) === "~", G = de.originalText.charAt(ye - 3) === "~", te = he.value.includes("}}") ? "--" : "";
                  return ["{{", S ? "~" : "", "!", te, he.value, te, G ? "~" : "", "}}"];
                }
                case "PathExpression":
                  return he.original;
                case "BooleanLiteral":
                  return String(he.value);
                case "CommentStatement":
                  return ["<!--", he.value, "-->"];
                case "StringLiteral": {
                  if (_e(U)) {
                    let Se = de.singleQuote ? '"' : "'";
                    return Ce(he.value, Se);
                  }
                  return Ce(he.value, Be);
                }
                case "NumberLiteral":
                  return String(he.value);
                case "UndefinedLiteral":
                  return "undefined";
                case "NullLiteral":
                  return "null";
                default:
                  throw new Error("unknown glimmer type: " + JSON.stringify(he.type));
              }
            }
            function C(U, de) {
              return v(U) - v(de);
            }
            function _(U, de) {
              let De = U.getValue(), he = ["attributes", "modifiers", "comments"].filter((Se) => D(De[Se])), Be = he.flatMap((Se) => De[Se]).sort(C);
              for (let Se of he)
                U.each((ye) => {
                  let S = Be.indexOf(ye.getValue());
                  Be.splice(S, 1, [c, de()]);
                }, Se);
              return D(De.blockParams) && Be.push(c, ce(De)), ["<", De.tag, i(Be), N(De)];
            }
            function b(U, de, De) {
              let Be = U.getValue().children.every((Se) => E(Se));
              return de.htmlWhitespaceSensitivity === "ignore" && Be ? "" : U.map((Se, ye) => {
                let S = De();
                return ye === 0 && de.htmlWhitespaceSensitivity === "ignore" ? [y, S] : S;
              }, "children");
            }
            function N(U) {
              return m(U) ? u([y, "/>"], [" />", y]) : u([y, ">"], ">");
            }
            function k(U) {
              let de = U.escaped === false ? "{{{" : "{{", De = U.strip && U.strip.open ? "~" : "";
              return [de, De];
            }
            function $(U) {
              let de = U.escaped === false ? "}}}" : "}}";
              return [U.strip && U.strip.close ? "~" : "", de];
            }
            function M(U) {
              let de = k(U), De = U.openStrip.open ? "~" : "";
              return [de, De, "#"];
            }
            function q(U) {
              let de = $(U);
              return [U.openStrip.close ? "~" : "", de];
            }
            function J(U) {
              let de = k(U), De = U.closeStrip.open ? "~" : "";
              return [de, De, "/"];
            }
            function L(U) {
              let de = $(U);
              return [U.closeStrip.close ? "~" : "", de];
            }
            function Y(U) {
              let de = k(U), De = U.inverseStrip.open ? "~" : "";
              return [de, De];
            }
            function V(U) {
              let de = $(U);
              return [U.inverseStrip.close ? "~" : "", de];
            }
            function O(U, de) {
              let De = U.getValue(), he = M(De), Be = q(De), Se = [ie(U, de)], ye = ve(U, de);
              if (ye && Se.push(c, ye), D(De.program.blockParams)) {
                let S = ce(De.program);
                Se.push(c, S);
              }
              return a([he, i(Se), y, Be]);
            }
            function K(U, de) {
              return [de.htmlWhitespaceSensitivity === "ignore" ? r : "", Y(U), "else", V(U)];
            }
            function se(U, de, De) {
              let he = U.getParentNode(1);
              return [Y(he), "else ", De, " ", ve(U, de), V(he)];
            }
            function Q(U, de, De) {
              let he = U.getValue();
              return De.htmlWhitespaceSensitivity === "ignore" ? [le(he) ? y : r, J(he), de("path"), L(he)] : [J(he), de("path"), L(he)];
            }
            function le(U) {
              return R(U, ["BlockStatement"]) && U.program.body.every((de) => E(de));
            }
            function W(U) {
              return X(U) && U.inverse.body.length === 1 && R(U.inverse.body[0], ["BlockStatement"]) && U.inverse.body[0].path.parts[0] === U.path.parts[0];
            }
            function X(U) {
              return R(U, ["BlockStatement"]) && U.inverse;
            }
            function oe(U, de, De) {
              let he = U.getValue();
              if (le(he))
                return "";
              let Be = de("program");
              return De.htmlWhitespaceSensitivity === "ignore" ? i([r, Be]) : i(Be);
            }
            function ae(U, de, De) {
              let he = U.getValue(), Be = de("inverse"), Se = De.htmlWhitespaceSensitivity === "ignore" ? [r, Be] : Be;
              return W(he) ? Se : X(he) ? [K(he, De), i(Se)] : "";
            }
            function Ae(U) {
              return h(l(c, z(U)));
            }
            function z(U) {
              return U.split(/[\t\n\f\r ]+/);
            }
            function H(U) {
              for (let de = 0; de < 2; de++) {
                let De = U.getParentNode(de);
                if (De && De.type === "AttrNode")
                  return De.name.toLowerCase();
              }
            }
            function Z(U) {
              return U = typeof U == "string" ? U : "", U.split(`
`).length - 1;
            }
            function ne(U) {
              U = typeof U == "string" ? U : "";
              let de = (U.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
              return Z(de);
            }
            function fe(U) {
              U = typeof U == "string" ? U : "";
              let de = (U.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
              return Z(de);
            }
            function ge() {
              let U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return Array.from({ length: Math.min(U, o) }).fill(r);
            }
            function Ce(U, de) {
              let { quote: De, regex: he } = p(U, de);
              return [De, U.replace(he, `\\${De}`), De];
            }
            function _e(U) {
              let de = 0, De = U.getParentNode(de);
              for (; De && R(De, ["SubExpression"]); )
                de++, De = U.getParentNode(de);
              return !!(De && R(U.getParentNode(de + 1), ["ConcatStatement"]) && R(U.getParentNode(de + 2), ["AttrNode"]));
            }
            function Oe(U, de) {
              let De = ie(U, de), he = ve(U, de);
              return he ? i([De, c, a(he)]) : De;
            }
            function pe(U, de) {
              let De = ie(U, de), he = ve(U, de);
              return he ? [i([De, c, he]), y] : De;
            }
            function ie(U, de) {
              return de("path");
            }
            function ve(U, de) {
              let De = U.getValue(), he = [];
              if (De.params.length > 0) {
                let Be = U.map(de, "params");
                he.push(...Be);
              }
              if (De.hash && De.hash.pairs.length > 0) {
                let Be = de("hash");
                he.push(Be);
              }
              return he.length === 0 ? "" : l(c, he);
            }
            function ce(U) {
              return ["as |", U.blockParams.join(" "), "|"];
            }
            n.exports = { print: d, massageAstNode: T };
          } }), xd = ee({ "src/language-handlebars/parsers.js"() {
            re();
          } }), bd = ee({ "node_modules/linguist-languages/data/Handlebars.json"(e, n) {
            n.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
          } }), Td = ee({ "src/language-handlebars/index.js"(e, n) {
            "use strict";
            re();
            var t = wt(), s = Sd(), a = xd(), r = [t(bd(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
            n.exports = { languages: r, printers: u, parsers: a };
          } }), Bd = ee({ "src/language-graphql/pragma.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a);
            }
            function s(a) {
              return `# @format

` + a;
            }
            n.exports = { hasPragma: t, insertPragma: s };
          } }), Nd = ee({ "src/language-graphql/loc.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return typeof a.start == "number" ? a.start : a.loc && a.loc.start;
            }
            function s(a) {
              return typeof a.end == "number" ? a.end : a.loc && a.loc.end;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), wd = ee({ "src/language-graphql/printer-graphql.js"(e, n) {
            "use strict";
            re();
            var { builders: { join: t, hardline: s, line: a, softline: r, group: u, indent: i, ifBreak: l } } = qe(), { isNextLineEmpty: c, isNonEmptyArray: y } = Ge(), { insertPragma: h } = Bd(), { locStart: g, locEnd: p } = Nd();
            function D(P2, R, f) {
              let x = P2.getValue();
              if (!x)
                return "";
              if (typeof x == "string")
                return x;
              switch (x.kind) {
                case "Document": {
                  let m = [];
                  return P2.each((E, o, d) => {
                    m.push(f()), o !== d.length - 1 && (m.push(s), c(R.originalText, E.getValue(), p) && m.push(s));
                  }, "definitions"), [...m, s];
                }
                case "OperationDefinition": {
                  let m = R.originalText[g(x)] !== "{", E = Boolean(x.name);
                  return [m ? x.operation : "", m && E ? [" ", f("name")] : "", m && !E && y(x.variableDefinitions) ? " " : "", y(x.variableDefinitions) ? u(["(", i([r, t([l("", ", "), r], P2.map(f, "variableDefinitions"))]), r, ")"]) : "", v(P2, f, x), x.selectionSet ? !m && !E ? "" : " " : "", f("selectionSet")];
                }
                case "FragmentDefinition":
                  return ["fragment ", f("name"), y(x.variableDefinitions) ? u(["(", i([r, t([l("", ", "), r], P2.map(f, "variableDefinitions"))]), r, ")"]) : "", " on ", f("typeCondition"), v(P2, f, x), " ", f("selectionSet")];
                case "SelectionSet":
                  return ["{", i([s, t(s, w(P2, R, f, "selections"))]), s, "}"];
                case "Field":
                  return u([x.alias ? [f("alias"), ": "] : "", f("name"), x.arguments.length > 0 ? u(["(", i([r, t([l("", ", "), r], w(P2, R, f, "arguments"))]), r, ")"]) : "", v(P2, f, x), x.selectionSet ? " " : "", f("selectionSet")]);
                case "Name":
                  return x.value;
                case "StringValue": {
                  if (x.block) {
                    let m = x.value.replace(/"""/g, "\\$&").split(`
`);
                    return m.length === 1 && (m[0] = m[0].trim()), m.every((E) => E === "") && (m.length = 0), t(s, ['"""', ...m, '"""']);
                  }
                  return ['"', x.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
                }
                case "IntValue":
                case "FloatValue":
                case "EnumValue":
                  return x.value;
                case "BooleanValue":
                  return x.value ? "true" : "false";
                case "NullValue":
                  return "null";
                case "Variable":
                  return ["$", f("name")];
                case "ListValue":
                  return u(["[", i([r, t([l("", ", "), r], P2.map(f, "values"))]), r, "]"]);
                case "ObjectValue":
                  return u(["{", R.bracketSpacing && x.fields.length > 0 ? " " : "", i([r, t([l("", ", "), r], P2.map(f, "fields"))]), r, l("", R.bracketSpacing && x.fields.length > 0 ? " " : ""), "}"]);
                case "ObjectField":
                case "Argument":
                  return [f("name"), ": ", f("value")];
                case "Directive":
                  return ["@", f("name"), x.arguments.length > 0 ? u(["(", i([r, t([l("", ", "), r], w(P2, R, f, "arguments"))]), r, ")"]) : ""];
                case "NamedType":
                  return f("name");
                case "VariableDefinition":
                  return [f("variable"), ": ", f("type"), x.defaultValue ? [" = ", f("defaultValue")] : "", v(P2, f, x)];
                case "ObjectTypeExtension":
                case "ObjectTypeDefinition":
                  return [f("description"), x.description ? s : "", x.kind === "ObjectTypeExtension" ? "extend " : "", "type ", f("name"), x.interfaces.length > 0 ? [" implements ", ...A3(P2, R, f)] : "", v(P2, f, x), x.fields.length > 0 ? [" {", i([s, t(s, w(P2, R, f, "fields"))]), s, "}"] : ""];
                case "FieldDefinition":
                  return [f("description"), x.description ? s : "", f("name"), x.arguments.length > 0 ? u(["(", i([r, t([l("", ", "), r], w(P2, R, f, "arguments"))]), r, ")"]) : "", ": ", f("type"), v(P2, f, x)];
                case "DirectiveDefinition":
                  return [f("description"), x.description ? s : "", "directive ", "@", f("name"), x.arguments.length > 0 ? u(["(", i([r, t([l("", ", "), r], w(P2, R, f, "arguments"))]), r, ")"]) : "", x.repeatable ? " repeatable" : "", " on ", t(" | ", P2.map(f, "locations"))];
                case "EnumTypeExtension":
                case "EnumTypeDefinition":
                  return [f("description"), x.description ? s : "", x.kind === "EnumTypeExtension" ? "extend " : "", "enum ", f("name"), v(P2, f, x), x.values.length > 0 ? [" {", i([s, t(s, w(P2, R, f, "values"))]), s, "}"] : ""];
                case "EnumValueDefinition":
                  return [f("description"), x.description ? s : "", f("name"), v(P2, f, x)];
                case "InputValueDefinition":
                  return [f("description"), x.description ? x.description.block ? s : a : "", f("name"), ": ", f("type"), x.defaultValue ? [" = ", f("defaultValue")] : "", v(P2, f, x)];
                case "InputObjectTypeExtension":
                case "InputObjectTypeDefinition":
                  return [f("description"), x.description ? s : "", x.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", f("name"), v(P2, f, x), x.fields.length > 0 ? [" {", i([s, t(s, w(P2, R, f, "fields"))]), s, "}"] : ""];
                case "SchemaExtension":
                  return ["extend schema", v(P2, f, x), ...x.operationTypes.length > 0 ? [" {", i([s, t(s, w(P2, R, f, "operationTypes"))]), s, "}"] : []];
                case "SchemaDefinition":
                  return [f("description"), x.description ? s : "", "schema", v(P2, f, x), " {", x.operationTypes.length > 0 ? i([s, t(s, w(P2, R, f, "operationTypes"))]) : "", s, "}"];
                case "OperationTypeDefinition":
                  return [f("operation"), ": ", f("type")];
                case "InterfaceTypeExtension":
                case "InterfaceTypeDefinition":
                  return [f("description"), x.description ? s : "", x.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", f("name"), x.interfaces.length > 0 ? [" implements ", ...A3(P2, R, f)] : "", v(P2, f, x), x.fields.length > 0 ? [" {", i([s, t(s, w(P2, R, f, "fields"))]), s, "}"] : ""];
                case "FragmentSpread":
                  return ["...", f("name"), v(P2, f, x)];
                case "InlineFragment":
                  return ["...", x.typeCondition ? [" on ", f("typeCondition")] : "", v(P2, f, x), " ", f("selectionSet")];
                case "UnionTypeExtension":
                case "UnionTypeDefinition":
                  return u([f("description"), x.description ? s : "", u([x.kind === "UnionTypeExtension" ? "extend " : "", "union ", f("name"), v(P2, f, x), x.types.length > 0 ? [" =", l("", " "), i([l([a, "  "]), t([a, "| "], P2.map(f, "types"))])] : ""])]);
                case "ScalarTypeExtension":
                case "ScalarTypeDefinition":
                  return [f("description"), x.description ? s : "", x.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", f("name"), v(P2, f, x)];
                case "NonNullType":
                  return [f("type"), "!"];
                case "ListType":
                  return ["[", f("type"), "]"];
                default:
                  throw new Error("unknown graphql type: " + JSON.stringify(x.kind));
              }
            }
            function v(P2, R, f) {
              if (f.directives.length === 0)
                return "";
              let x = t(a, P2.map(R, "directives"));
              return f.kind === "FragmentDefinition" || f.kind === "OperationDefinition" ? u([a, x]) : [" ", u(i([r, x]))];
            }
            function w(P2, R, f, x) {
              return P2.map((m, E, o) => {
                let d = f();
                return E < o.length - 1 && c(R.originalText, m.getValue(), p) ? [d, s] : d;
              }, x);
            }
            function T(P2) {
              return P2.kind && P2.kind !== "Comment";
            }
            function F(P2) {
              let R = P2.getValue();
              if (R.kind === "Comment")
                return "#" + R.value.trimEnd();
              throw new Error("Not a comment: " + JSON.stringify(R));
            }
            function A3(P2, R, f) {
              let x = P2.getNode(), m = [], { interfaces: E } = x, o = P2.map((d) => f(d), "interfaces");
              for (let d = 0; d < E.length; d++) {
                let C = E[d];
                m.push(o[d]);
                let _ = E[d + 1];
                if (_) {
                  let b = R.originalText.slice(C.loc.end, _.loc.start), N = b.includes("#"), k = b.replace(/#.*/g, "").trim();
                  m.push(k === "," ? "," : " &", N ? a : " ");
                }
              }
              return m;
            }
            function B(P2, R) {
              P2.kind === "StringValue" && P2.block && !P2.value.includes(`
`) && (R.value = R.value.trim());
            }
            B.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
            function I(P2) {
              var R;
              let f = P2.getValue();
              return f == null || (R = f.comments) === null || R === void 0 ? void 0 : R.some((x) => x.value.trim() === "prettier-ignore");
            }
            n.exports = { print: D, massageAstNode: B, hasPrettierIgnore: I, insertPragma: h, printComment: F, canAttachComment: T };
          } }), _d = ee({ "src/language-graphql/options.js"(e, n) {
            "use strict";
            re();
            var t = qt();
            n.exports = { bracketSpacing: t.bracketSpacing };
          } }), Pd = ee({ "src/language-graphql/parsers.js"() {
            re();
          } }), Id = ee({ "node_modules/linguist-languages/data/GraphQL.json"(e, n) {
            n.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
          } }), kd = ee({ "src/language-graphql/index.js"(e, n) {
            "use strict";
            re();
            var t = wt(), s = wd(), a = _d(), r = Pd(), u = [t(Id(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s };
            n.exports = { languages: u, options: a, printers: i, parsers: r };
          } }), co = ee({ "src/language-markdown/loc.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return a.position.start.offset;
            }
            function s(a) {
              return a.position.end.offset;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), Ld = ee({ "src/language-markdown/constants.evaluate.js"(e, n) {
            n.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
          } }), Yn = ee({ "src/language-markdown/utils.js"(e, n) {
            "use strict";
            re();
            var { getLast: t } = Ge(), { locStart: s, locEnd: a } = co(), { cjkPattern: r, kPattern: u, punctuationPattern: i } = Ld(), l = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], c = [...l, "tableCell", "paragraph", "heading"], y = new RegExp(u), h = new RegExp(i);
            function g(F, A3) {
              let B = "non-cjk", I = "cj-letter", P2 = "k-letter", R = "cjk-punctuation", f = [], x = (A3.proseWrap === "preserve" ? F : F.replace(new RegExp(`(${r})
(${r})`, "g"), "$1$2")).split(/([\t\n ]+)/);
              for (let [E, o] of x.entries()) {
                if (E % 2 === 1) {
                  f.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
                  continue;
                }
                if ((E === 0 || E === x.length - 1) && o === "")
                  continue;
                let d = o.split(new RegExp(`(${r})`));
                for (let [C, _] of d.entries())
                  if (!((C === 0 || C === d.length - 1) && _ === "")) {
                    if (C % 2 === 0) {
                      _ !== "" && m({ type: "word", value: _, kind: B, hasLeadingPunctuation: h.test(_[0]), hasTrailingPunctuation: h.test(t(_)) });
                      continue;
                    }
                    m(h.test(_) ? { type: "word", value: _, kind: R, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: _, kind: y.test(_) ? P2 : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                  }
              }
              return f;
              function m(E) {
                let o = t(f);
                o && o.type === "word" && (o.kind === B && E.kind === I && !o.hasTrailingPunctuation || o.kind === I && E.kind === B && !E.hasLeadingPunctuation ? f.push({ type: "whitespace", value: " " }) : !d(B, R) && ![o.value, E.value].some((C) => /\u3000/.test(C)) && f.push({ type: "whitespace", value: "" })), f.push(E);
                function d(C, _) {
                  return o.kind === C && E.kind === _ || o.kind === _ && E.kind === C;
                }
              }
            }
            function p(F, A3) {
              let [, B, I, P2] = A3.slice(F.position.start.offset, F.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
              return { numberText: B, marker: I, leadingSpaces: P2 };
            }
            function D(F, A3) {
              if (!F.ordered || F.children.length < 2)
                return false;
              let B = Number(p(F.children[0], A3.originalText).numberText), I = Number(p(F.children[1], A3.originalText).numberText);
              if (B === 0 && F.children.length > 2) {
                let P2 = Number(p(F.children[2], A3.originalText).numberText);
                return I === 1 && P2 === 1;
              }
              return I === 1;
            }
            function v(F, A3) {
              let { value: B } = F;
              return F.position.end.offset === A3.length && B.endsWith(`
`) && A3.endsWith(`
`) ? B.slice(0, -1) : B;
            }
            function w(F, A3) {
              return function B(I, P2, R) {
                let f = Object.assign({}, A3(I, P2, R));
                return f.children && (f.children = f.children.map((x, m) => B(x, m, [f, ...R]))), f;
              }(F, null, []);
            }
            function T(F) {
              if ((F == null ? void 0 : F.type) !== "link" || F.children.length !== 1)
                return false;
              let [A3] = F.children;
              return s(F) === s(A3) && a(F) === a(A3);
            }
            n.exports = { mapAst: w, splitText: g, punctuationPattern: i, getFencedCodeBlockValue: v, getOrderedListItemInfo: p, hasGitDiffFriendlyOrderedList: D, INLINE_NODE_TYPES: l, INLINE_NODE_WRAPPER_TYPES: c, isAutolink: T };
          } }), jd = ee({ "src/language-markdown/embed.js"(e, n) {
            "use strict";
            re();
            var { inferParserByLanguage: t, getMaxContinuousCount: s } = Ge(), { builders: { hardline: a, markAsRoot: r }, utils: { replaceEndOfLine: u } } = qe(), i = Kn(), { getFencedCodeBlockValue: l } = Yn();
            function c(y, h, g, p) {
              let D = y.getValue();
              if (D.type === "code" && D.lang !== null) {
                let v = t(D.lang, p);
                if (v) {
                  let w = p.__inJsTemplate ? "~" : "`", T = w.repeat(Math.max(3, s(D.value, w) + 1)), F = { parser: v };
                  D.lang === "tsx" && (F.filepath = "dummy.tsx");
                  let A3 = g(l(D, p.originalText), F, { stripTrailingHardline: true });
                  return r([T, D.lang, D.meta ? " " + D.meta : "", a, u(A3), a, T]);
                }
              }
              switch (D.type) {
                case "front-matter":
                  return i(D, g);
                case "importExport":
                  return [g(D.value, { parser: "babel" }, { stripTrailingHardline: true }), a];
                case "jsx":
                  return g(`<$>${D.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
              }
              return null;
            }
            n.exports = c;
          } }), po = ee({ "src/language-markdown/pragma.js"(e, n) {
            "use strict";
            re();
            var t = lo(), s = ["format", "prettier"];
            function a(r) {
              let u = `@(${s.join("|")})`, i = new RegExp([`<!--\\s*${u}\\s*-->`, `{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l = r.match(i);
              return (l == null ? void 0 : l.index) === 0;
            }
            n.exports = { startWithPragma: a, hasPragma: (r) => a(t(r).content.trimStart()), insertPragma: (r) => {
              let u = t(r), i = `<!-- @${s[0]} -->`;
              return u.frontMatter ? `${u.frontMatter.raw}

${i}

${u.content}` : `${i}

${u.content}`;
            } };
          } }), Od = ee({ "src/language-markdown/print-preprocess.js"(e, n) {
            "use strict";
            re();
            var t = lt(), { getOrderedListItemInfo: s, mapAst: a, splitText: r } = Yn(), u = /^.$/su;
            function i(T, F) {
              return T = y(T, F), T = p(T), T = c(T, F), T = v(T, F), T = w(T, F), T = D(T, F), T = l(T), T = h(T), T;
            }
            function l(T) {
              return a(T, (F) => F.type !== "import" && F.type !== "export" ? F : Object.assign(Object.assign({}, F), {}, { type: "importExport" }));
            }
            function c(T, F) {
              return a(T, (A3) => A3.type !== "inlineCode" || F.proseWrap === "preserve" ? A3 : Object.assign(Object.assign({}, A3), {}, { value: A3.value.replace(/\s+/g, " ") }));
            }
            function y(T, F) {
              return a(T, (A3) => A3.type !== "text" || A3.value === "*" || A3.value === "_" || !u.test(A3.value) || A3.position.end.offset - A3.position.start.offset === A3.value.length ? A3 : Object.assign(Object.assign({}, A3), {}, { value: F.originalText.slice(A3.position.start.offset, A3.position.end.offset) }));
            }
            function h(T) {
              return g(T, (F, A3) => F.type === "importExport" && A3.type === "importExport", (F, A3) => ({ type: "importExport", value: F.value + `

` + A3.value, position: { start: F.position.start, end: A3.position.end } }));
            }
            function g(T, F, A3) {
              return a(T, (B) => {
                if (!B.children)
                  return B;
                let I = B.children.reduce((P2, R) => {
                  let f = t(P2);
                  return f && F(f, R) ? P2.splice(-1, 1, A3(f, R)) : P2.push(R), P2;
                }, []);
                return Object.assign(Object.assign({}, B), {}, { children: I });
              });
            }
            function p(T) {
              return g(T, (F, A3) => F.type === "text" && A3.type === "text", (F, A3) => ({ type: "text", value: F.value + A3.value, position: { start: F.position.start, end: A3.position.end } }));
            }
            function D(T, F) {
              return a(T, (A3, B, I) => {
                let [P2] = I;
                if (A3.type !== "text")
                  return A3;
                let { value: R } = A3;
                return P2.type === "paragraph" && (B === 0 && (R = R.trimStart()), B === P2.children.length - 1 && (R = R.trimEnd())), { type: "sentence", position: A3.position, children: r(R, F) };
              });
            }
            function v(T, F) {
              return a(T, (A3, B, I) => {
                if (A3.type === "code") {
                  let P2 = /^\n?(?: {4,}|\t)/.test(F.originalText.slice(A3.position.start.offset, A3.position.end.offset));
                  if (A3.isIndented = P2, P2)
                    for (let R = 0; R < I.length; R++) {
                      let f = I[R];
                      if (f.hasIndentedCodeblock)
                        break;
                      f.type === "list" && (f.hasIndentedCodeblock = true);
                    }
                }
                return A3;
              });
            }
            function w(T, F) {
              return a(T, (I, P2, R) => {
                if (I.type === "list" && I.children.length > 0) {
                  for (let f = 0; f < R.length; f++) {
                    let x = R[f];
                    if (x.type === "list" && !x.isAligned)
                      return I.isAligned = false, I;
                  }
                  I.isAligned = B(I);
                }
                return I;
              });
              function A3(I) {
                return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
              }
              function B(I) {
                if (!I.ordered)
                  return true;
                let [P2, R] = I.children;
                if (s(P2, F.originalText).leadingSpaces.length > 1)
                  return true;
                let x = A3(P2);
                if (x === -1)
                  return false;
                if (I.children.length === 1)
                  return x % F.tabWidth === 0;
                let m = A3(R);
                return x !== m ? false : x % F.tabWidth === 0 ? true : s(R, F.originalText).leadingSpaces.length > 1;
              }
            }
            n.exports = i;
          } }), qd = ee({ "src/language-markdown/clean.js"(e, n) {
            "use strict";
            re();
            var { isFrontMatterNode: t } = Ge(), { startWithPragma: s } = po(), a = /* @__PURE__ */ new Set(["position", "raw"]);
            function r(u, i, l) {
              if ((u.type === "front-matter" || u.type === "code" || u.type === "yaml" || u.type === "import" || u.type === "export" || u.type === "jsx") && delete i.value, u.type === "list" && delete i.isAligned, (u.type === "list" || u.type === "listItem") && (delete i.spread, delete i.loose), u.type === "text" || (u.type === "inlineCode" && (i.value = u.value.replace(/[\t\n ]+/g, " ")), u.type === "wikiLink" && (i.value = u.value.trim().replace(/[\t\n]+/g, " ")), (u.type === "definition" || u.type === "linkReference") && (i.label = u.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), (u.type === "definition" || u.type === "link" || u.type === "image") && u.title && (i.title = u.title.replace(/\\(["')])/g, "$1")), l && l.type === "root" && l.children.length > 0 && (l.children[0] === u || t(l.children[0]) && l.children[1] === u) && u.type === "html" && s(u.value)))
                return null;
            }
            r.ignoredProperties = a, n.exports = r;
          } }), Md = ee({ "src/language-markdown/printer-markdown.js"(e, n) {
            "use strict";
            re();
            var { getLast: t, getMinNotPresentContinuousCount: s, getMaxContinuousCount: a, getStringWidth: r, isNonEmptyArray: u } = Ge(), { builders: { breakParent: i, join: l, line: c, literalline: y, markAsRoot: h, hardline: g, softline: p, ifBreak: D, fill: v, align: w, indent: T, group: F, hardlineWithoutBreakParent: A3 }, utils: { normalizeDoc: B, replaceTextEndOfLine: I }, printer: { printDocToString: P2 } } = qe(), R = jd(), { insertPragma: f } = po(), { locStart: x, locEnd: m } = co(), E = Od(), o = qd(), { getFencedCodeBlockValue: d, hasGitDiffFriendlyOrderedList: C, splitText: _, punctuationPattern: b, INLINE_NODE_TYPES: N, INLINE_NODE_WRAPPER_TYPES: k, isAutolink: $ } = Yn(), M = /* @__PURE__ */ new Set(["importExport"]), q = ["heading", "tableCell", "link", "wikiLink"], J = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
            function L(pe, ie, ve) {
              let ce = pe.getValue();
              if (fe(pe))
                return _(ie.originalText.slice(ce.position.start.offset, ce.position.end.offset), ie).map((U) => U.type === "word" ? U.value : U.value === "" ? "" : le(pe, U.value, ie));
              switch (ce.type) {
                case "front-matter":
                  return ie.originalText.slice(ce.position.start.offset, ce.position.end.offset);
                case "root":
                  return ce.children.length === 0 ? "" : [B(X(pe, ie, ve)), M.has(Ae(ce).type) ? "" : g];
                case "paragraph":
                  return oe(pe, ie, ve, { postprocessor: v });
                case "sentence":
                  return oe(pe, ie, ve);
                case "word": {
                  let U = ce.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${b})(_+)`, `(_+)(${b}|$)`].join("|"), "g"), (he, Be, Se, ye, S) => (Se ? `${Be}${Se}` : `${ye}${S}`).replace(/_/g, "\\_")), de = (he, Be, Se) => he.type === "sentence" && Se === 0, De = (he, Be, Se) => $(he.children[Se - 1]);
                  return U !== ce.value && (pe.match(void 0, de, De) || pe.match(void 0, de, (he, Be, Se) => he.type === "emphasis" && Se === 0, De)) && (U = U.replace(/^(\\?[*_])+/, (he) => he.replace(/\\/g, ""))), U;
                }
                case "whitespace": {
                  let U = pe.getParentNode(), de = U.children.indexOf(ce), De = U.children[de + 1], he = De && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(De.value) ? "never" : ie.proseWrap;
                  return le(pe, ce.value, { proseWrap: he });
                }
                case "emphasis": {
                  let U;
                  if ($(ce.children[0]))
                    U = ie.originalText[ce.position.start.offset];
                  else {
                    let de = pe.getParentNode(), De = de.children.indexOf(ce), he = de.children[De - 1], Be = de.children[De + 1];
                    U = he && he.type === "sentence" && he.children.length > 0 && t(he.children).type === "word" && !t(he.children).hasTrailingPunctuation || Be && Be.type === "sentence" && Be.children.length > 0 && Be.children[0].type === "word" && !Be.children[0].hasLeadingPunctuation || Q(pe, "emphasis") ? "*" : "_";
                  }
                  return [U, oe(pe, ie, ve), U];
                }
                case "strong":
                  return ["**", oe(pe, ie, ve), "**"];
                case "delete":
                  return ["~~", oe(pe, ie, ve), "~~"];
                case "inlineCode": {
                  let U = s(ce.value, "`"), de = "`".repeat(U || 1), De = U && !/^\s/.test(ce.value) ? " " : "";
                  return [de, De, ce.value, De, de];
                }
                case "wikiLink": {
                  let U = "";
                  return ie.proseWrap === "preserve" ? U = ce.value : U = ce.value.replace(/[\t\n]+/g, " "), ["[[", U, "]]"];
                }
                case "link":
                  switch (ie.originalText[ce.position.start.offset]) {
                    case "<": {
                      let U = "mailto:", de = ce.url.startsWith(U) && ie.originalText.slice(ce.position.start.offset + 1, ce.position.start.offset + 1 + U.length) !== U ? ce.url.slice(U.length) : ce.url;
                      return ["<", de, ">"];
                    }
                    case "[":
                      return ["[", oe(pe, ie, ve), "](", ge(ce.url, ")"), Ce(ce.title, ie), ")"];
                    default:
                      return ie.originalText.slice(ce.position.start.offset, ce.position.end.offset);
                  }
                case "image":
                  return ["![", ce.alt || "", "](", ge(ce.url, ")"), Ce(ce.title, ie), ")"];
                case "blockquote":
                  return ["> ", w("> ", oe(pe, ie, ve))];
                case "heading":
                  return ["#".repeat(ce.depth) + " ", oe(pe, ie, ve)];
                case "code": {
                  if (ce.isIndented) {
                    let De = " ".repeat(4);
                    return w(De, [De, ...I(ce.value, g)]);
                  }
                  let U = ie.__inJsTemplate ? "~" : "`", de = U.repeat(Math.max(3, a(ce.value, U) + 1));
                  return [de, ce.lang || "", ce.meta ? " " + ce.meta : "", g, ...I(d(ce, ie.originalText), g), g, de];
                }
                case "html": {
                  let U = pe.getParentNode(), de = U.type === "root" && t(U.children) === ce ? ce.value.trimEnd() : ce.value, De = /^<!--.*-->$/s.test(de);
                  return I(de, De ? g : h(y));
                }
                case "list": {
                  let U = O(ce, pe.getParentNode()), de = C(ce, ie);
                  return oe(pe, ie, ve, { processor: (De, he) => {
                    let Be = ye(), Se = De.getValue();
                    if (Se.children.length === 2 && Se.children[1].type === "html" && Se.children[0].position.start.column !== Se.children[1].position.start.column)
                      return [Be, Y(De, ie, ve, Be)];
                    return [Be, w(" ".repeat(Be.length), Y(De, ie, ve, Be))];
                    function ye() {
                      let S = ce.ordered ? (he === 0 ? ce.start : de ? 1 : ce.start + he) + (U % 2 === 0 ? ". " : ") ") : U % 2 === 0 ? "- " : "* ";
                      return ce.isAligned || ce.hasIndentedCodeblock ? V(S, ie) : S;
                    }
                  } });
                }
                case "thematicBreak": {
                  let U = se(pe, "list");
                  return U === -1 ? "---" : O(pe.getParentNode(U), pe.getParentNode(U + 1)) % 2 === 0 ? "***" : "---";
                }
                case "linkReference":
                  return ["[", oe(pe, ie, ve), "]", ce.referenceType === "full" ? ["[", ce.identifier, "]"] : ce.referenceType === "collapsed" ? "[]" : ""];
                case "imageReference":
                  switch (ce.referenceType) {
                    case "full":
                      return ["![", ce.alt || "", "][", ce.identifier, "]"];
                    default:
                      return ["![", ce.alt, "]", ce.referenceType === "collapsed" ? "[]" : ""];
                  }
                case "definition": {
                  let U = ie.proseWrap === "always" ? c : " ";
                  return F(["[", ce.identifier, "]:", T([U, ge(ce.url), ce.title === null ? "" : [U, Ce(ce.title, ie, false)]])]);
                }
                case "footnote":
                  return ["[^", oe(pe, ie, ve), "]"];
                case "footnoteReference":
                  return ["[^", ce.identifier, "]"];
                case "footnoteDefinition": {
                  let U = pe.getParentNode().children[pe.getName() + 1], de = ce.children.length === 1 && ce.children[0].type === "paragraph" && (ie.proseWrap === "never" || ie.proseWrap === "preserve" && ce.children[0].position.start.line === ce.children[0].position.end.line);
                  return ["[^", ce.identifier, "]: ", de ? oe(pe, ie, ve) : F([w(" ".repeat(4), oe(pe, ie, ve, { processor: (De, he) => he === 0 ? F([p, ve()]) : ve() })), U && U.type === "footnoteDefinition" ? p : ""])];
                }
                case "table":
                  return W(pe, ie, ve);
                case "tableCell":
                  return oe(pe, ie, ve);
                case "break":
                  return /\s/.test(ie.originalText[ce.position.start.offset]) ? ["  ", h(y)] : ["\\", g];
                case "liquidNode":
                  return I(ce.value, g);
                case "importExport":
                  return [ce.value, g];
                case "esComment":
                  return ["{/* ", ce.value, " */}"];
                case "jsx":
                  return ce.value;
                case "math":
                  return ["$$", g, ce.value ? [...I(ce.value, g), g] : "", "$$"];
                case "inlineMath":
                  return ie.originalText.slice(x(ce), m(ce));
                case "tableRow":
                case "listItem":
                default:
                  throw new Error(`Unknown markdown type ${JSON.stringify(ce.type)}`);
              }
            }
            function Y(pe, ie, ve, ce) {
              let U = pe.getValue(), de = U.checked === null ? "" : U.checked ? "[x] " : "[ ] ";
              return [de, oe(pe, ie, ve, { processor: (De, he) => {
                if (he === 0 && De.getValue().type !== "list")
                  return w(" ".repeat(de.length), ve());
                let Be = " ".repeat(_e(ie.tabWidth - ce.length, 0, 3));
                return [Be, w(Be, ve())];
              } })];
            }
            function V(pe, ie) {
              let ve = ce();
              return pe + " ".repeat(ve >= 4 ? 0 : ve);
              function ce() {
                let U = pe.length % ie.tabWidth;
                return U === 0 ? 0 : ie.tabWidth - U;
              }
            }
            function O(pe, ie) {
              return K(pe, ie, (ve) => ve.ordered === pe.ordered);
            }
            function K(pe, ie, ve) {
              let ce = -1;
              for (let U of ie.children)
                if (U.type === pe.type && ve(U) ? ce++ : ce = -1, U === pe)
                  return ce;
            }
            function se(pe, ie) {
              let ve = Array.isArray(ie) ? ie : [ie], ce = -1, U;
              for (; U = pe.getParentNode(++ce); )
                if (ve.includes(U.type))
                  return ce;
              return -1;
            }
            function Q(pe, ie) {
              let ve = se(pe, ie);
              return ve === -1 ? null : pe.getParentNode(ve);
            }
            function le(pe, ie, ve) {
              if (ve.proseWrap === "preserve" && ie === `
`)
                return g;
              let ce = ve.proseWrap === "always" && !Q(pe, q);
              return ie !== "" ? ce ? c : " " : ce ? p : "";
            }
            function W(pe, ie, ve) {
              let ce = pe.getValue(), U = [], de = pe.map((S) => S.map((G, te) => {
                let Ee = P2(ve(), ie).formatted, Re = r(Ee);
                return U[te] = Math.max(U[te] || 3, Re), { text: Ee, width: Re };
              }, "children"), "children"), De = Be(false);
              if (ie.proseWrap !== "never")
                return [i, De];
              let he = Be(true);
              return [i, F(D(he, De))];
              function Be(S) {
                let G = [ye(de[0], S), Se(S)];
                return de.length > 1 && G.push(l(A3, de.slice(1).map((te) => ye(te, S)))), l(A3, G);
              }
              function Se(S) {
                return `| ${U.map((te, Ee) => {
                  let Re = ce.align[Ee], Te = Re === "center" || Re === "left" ? ":" : "-", Pe = Re === "center" || Re === "right" ? ":" : "-", Fe = S ? "-" : "-".repeat(te - 2);
                  return `${Te}${Fe}${Pe}`;
                }).join(" | ")} |`;
              }
              function ye(S, G) {
                return `| ${S.map((Ee, Re) => {
                  let { text: Te, width: Pe } = Ee;
                  if (G)
                    return Te;
                  let Fe = U[Re] - Pe, Ze = ce.align[Re], xe = 0;
                  Ze === "right" ? xe = Fe : Ze === "center" && (xe = Math.floor(Fe / 2));
                  let Je = Fe - xe;
                  return `${" ".repeat(xe)}${Te}${" ".repeat(Je)}`;
                }).join(" | ")} |`;
              }
            }
            function X(pe, ie, ve) {
              let ce = [], U = null, { children: de } = pe.getValue();
              for (let [De, he] of de.entries())
                switch (z(he)) {
                  case "start":
                    U === null && (U = { index: De, offset: he.position.end.offset });
                    break;
                  case "end":
                    U !== null && (ce.push({ start: U, end: { index: De, offset: he.position.start.offset } }), U = null);
                    break;
                  default:
                    break;
                }
              return oe(pe, ie, ve, { processor: (De, he) => {
                if (ce.length > 0) {
                  let Be = ce[0];
                  if (he === Be.start.index)
                    return [ae(de[Be.start.index]), ie.originalText.slice(Be.start.offset, Be.end.offset), ae(de[Be.end.index])];
                  if (Be.start.index < he && he < Be.end.index)
                    return false;
                  if (he === Be.end.index)
                    return ce.shift(), false;
                }
                return ve();
              } });
            }
            function oe(pe, ie, ve) {
              let ce = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: U } = ce, de = ce.processor || (() => ve()), De = pe.getValue(), he = [], Be;
              return pe.each((Se, ye) => {
                let S = Se.getValue(), G = de(Se, ye);
                if (G !== false) {
                  let te = { parts: he, prevNode: Be, parentNode: De, options: ie };
                  H(S, te) && (he.push(g), Be && M.has(Be.type) || (Z(S, te) || ne(S, te)) && he.push(g), ne(S, te) && he.push(g)), he.push(G), Be = S;
                }
              }, "children"), U ? U(he) : he;
            }
            function ae(pe) {
              if (pe.type === "html")
                return pe.value;
              if (pe.type === "paragraph" && Array.isArray(pe.children) && pe.children.length === 1 && pe.children[0].type === "esComment")
                return ["{/* ", pe.children[0].value, " */}"];
            }
            function Ae(pe) {
              let ie = pe;
              for (; u(ie.children); )
                ie = t(ie.children);
              return ie;
            }
            function z(pe) {
              let ie;
              if (pe.type === "html")
                ie = pe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
              else {
                let ve;
                pe.type === "esComment" ? ve = pe : pe.type === "paragraph" && pe.children.length === 1 && pe.children[0].type === "esComment" && (ve = pe.children[0]), ve && (ie = ve.value.match(/^prettier-ignore(?:-(start|end))?$/));
              }
              return ie ? ie[1] || "next" : false;
            }
            function H(pe, ie) {
              let ve = ie.parts.length === 0, ce = N.includes(pe.type), U = pe.type === "html" && k.includes(ie.parentNode.type);
              return !ve && !ce && !U;
            }
            function Z(pe, ie) {
              var ve, ce, U;
              let De = (ie.prevNode && ie.prevNode.type) === pe.type && J.has(pe.type), he = ie.parentNode.type === "listItem" && !ie.parentNode.loose, Be = ((ve = ie.prevNode) === null || ve === void 0 ? void 0 : ve.type) === "listItem" && ie.prevNode.loose, Se = z(ie.prevNode) === "next", ye = pe.type === "html" && ((ce = ie.prevNode) === null || ce === void 0 ? void 0 : ce.type) === "html" && ie.prevNode.position.end.line + 1 === pe.position.start.line, S = pe.type === "html" && ie.parentNode.type === "listItem" && ((U = ie.prevNode) === null || U === void 0 ? void 0 : U.type) === "paragraph" && ie.prevNode.position.end.line + 1 === pe.position.start.line;
              return Be || !(De || he || Se || ye || S);
            }
            function ne(pe, ie) {
              let ve = ie.prevNode && ie.prevNode.type === "list", ce = pe.type === "code" && pe.isIndented;
              return ve && ce;
            }
            function fe(pe) {
              let ie = Q(pe, ["linkReference", "imageReference"]);
              return ie && (ie.type !== "linkReference" || ie.referenceType !== "full");
            }
            function ge(pe) {
              let ie = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], ve = [" ", ...Array.isArray(ie) ? ie : [ie]];
              return new RegExp(ve.map((ce) => `\\${ce}`).join("|")).test(pe) ? `<${pe}>` : pe;
            }
            function Ce(pe, ie) {
              let ve = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
              if (!pe)
                return "";
              if (ve)
                return " " + Ce(pe, ie, false);
              if (pe = pe.replace(/\\(["')])/g, "$1"), pe.includes('"') && pe.includes("'") && !pe.includes(")"))
                return `(${pe})`;
              let ce = pe.split("'").length - 1, U = pe.split('"').length - 1, de = ce > U ? '"' : U > ce || ie.singleQuote ? "'" : '"';
              return pe = pe.replace(/\\/, "\\\\"), pe = pe.replace(new RegExp(`(${de})`, "g"), "\\$1"), `${de}${pe}${de}`;
            }
            function _e(pe, ie, ve) {
              return pe < ie ? ie : pe > ve ? ve : pe;
            }
            function Oe(pe) {
              let ie = Number(pe.getName());
              if (ie === 0)
                return false;
              let ve = pe.getParentNode().children[ie - 1];
              return z(ve) === "next";
            }
            n.exports = { preprocess: E, print: L, embed: R, massageAstNode: o, hasPrettierIgnore: Oe, insertPragma: f };
          } }), Rd = ee({ "src/language-markdown/options.js"(e, n) {
            "use strict";
            re();
            var t = qt();
            n.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
          } }), $d = ee({ "src/language-markdown/parsers.js"() {
            re();
          } }), ca = ee({ "node_modules/linguist-languages/data/Markdown.json"(e, n) {
            n.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
          } }), Vd = ee({ "src/language-markdown/index.js"(e, n) {
            "use strict";
            re();
            var t = wt(), s = Md(), a = Rd(), r = $d(), u = [t(ca(), (l) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l.filenames, "README"], extensions: l.extensions.filter((c) => c !== ".mdx") })), t(ca(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s };
            n.exports = { languages: u, options: a, printers: i, parsers: r };
          } }), Wd = ee({ "src/language-html/clean.js"(e, n) {
            "use strict";
            re();
            var { isFrontMatterNode: t } = Ge(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
            function a(r, u) {
              if (r.type === "text" || r.type === "comment" || t(r) || r.type === "yaml" || r.type === "toml")
                return null;
              r.type === "attribute" && delete u.value, r.type === "docType" && delete u.value;
            }
            a.ignoredProperties = s, n.exports = a;
          } }), Hd = ee({ "src/language-html/constants.evaluate.js"(e, n) {
            n.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
          } }), Gd = ee({ "src/language-html/utils/is-unknown-namespace.js"(e, n) {
            "use strict";
            re();
            function t(s) {
              return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
            }
            n.exports = t;
          } }), Mt = ee({ "src/language-html/utils/index.js"(e, n) {
            "use strict";
            re();
            var { inferParserByLanguage: t, isFrontMatterNode: s } = Ge(), { builders: { line: a, hardline: r, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: l } } = qe(), { CSS_DISPLAY_TAGS: c, CSS_DISPLAY_DEFAULT: y, CSS_WHITE_SPACE_TAGS: h, CSS_WHITE_SPACE_DEFAULT: g } = Hd(), p = Gd(), D = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), v = (S) => S.replace(/^[\t\n\f\r ]+/, ""), w = (S) => S.replace(/[\t\n\f\r ]+$/, ""), T = (S) => v(w(S)), F = (S) => S.replace(/^[\t\f\r ]*\n/g, ""), A3 = (S) => F(w(S)), B = (S) => S.split(/[\t\n\f\r ]+/), I = (S) => S.match(/^[\t\n\f\r ]*/)[0], P2 = (S) => {
              let [, G, te, Ee] = S.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
              return { leadingWhitespace: G, trailingWhitespace: Ee, text: te };
            }, R = (S) => /[\t\n\f\r ]/.test(S);
            function f(S, G) {
              return !!(S.type === "ieConditionalComment" && S.lastChild && !S.lastChild.isSelfClosing && !S.lastChild.endSourceSpan || S.type === "ieConditionalComment" && !S.complete || ne(S) && S.children.some((te) => te.type !== "text" && te.type !== "interpolation") || De(S, G) && !o(S) && S.type !== "interpolation");
            }
            function x(S) {
              return S.type === "attribute" || !S.parent || !S.prev ? false : m(S.prev);
            }
            function m(S) {
              return S.type === "comment" && S.value.trim() === "prettier-ignore";
            }
            function E(S) {
              return S.type === "text" || S.type === "comment";
            }
            function o(S) {
              return S.type === "element" && (S.fullName === "script" || S.fullName === "style" || S.fullName === "svg:style" || p(S) && (S.name === "script" || S.name === "style"));
            }
            function d(S) {
              return S.children && !o(S);
            }
            function C(S) {
              return o(S) || S.type === "interpolation" || _(S);
            }
            function _(S) {
              return _e(S).startsWith("pre");
            }
            function b(S, G) {
              let te = Ee();
              if (te && !S.prev && S.parent && S.parent.tagDefinition && S.parent.tagDefinition.ignoreFirstLf)
                return S.type === "interpolation";
              return te;
              function Ee() {
                return s(S) ? false : (S.type === "text" || S.type === "interpolation") && S.prev && (S.prev.type === "text" || S.prev.type === "interpolation") ? true : !S.parent || S.parent.cssDisplay === "none" ? false : ne(S.parent) ? true : !(!S.prev && (S.parent.type === "root" || ne(S) && S.parent || o(S.parent) || U(S.parent, G) || !ae(S.parent.cssDisplay)) || S.prev && !H(S.prev.cssDisplay));
              }
            }
            function N(S, G) {
              return s(S) ? false : (S.type === "text" || S.type === "interpolation") && S.next && (S.next.type === "text" || S.next.type === "interpolation") ? true : !S.parent || S.parent.cssDisplay === "none" ? false : ne(S.parent) ? true : !(!S.next && (S.parent.type === "root" || ne(S) && S.parent || o(S.parent) || U(S.parent, G) || !Ae(S.parent.cssDisplay)) || S.next && !z(S.next.cssDisplay));
            }
            function k(S) {
              return Z(S.cssDisplay) && !o(S);
            }
            function $(S) {
              return s(S) || S.next && S.sourceSpan.end && S.sourceSpan.end.line + 1 < S.next.sourceSpan.start.line;
            }
            function M(S) {
              return q(S) || S.type === "element" && S.children.length > 0 && (["body", "script", "style"].includes(S.name) || S.children.some((G) => Q(G))) || S.firstChild && S.firstChild === S.lastChild && S.firstChild.type !== "text" && V(S.firstChild) && (!S.lastChild.isTrailingSpaceSensitive || O(S.lastChild));
            }
            function q(S) {
              return S.type === "element" && S.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(S.name) || S.cssDisplay.startsWith("table") && S.cssDisplay !== "table-cell");
            }
            function J(S) {
              return K(S) || S.prev && L(S.prev) || Y(S);
            }
            function L(S) {
              return K(S) || S.type === "element" && S.fullName === "br" || Y(S);
            }
            function Y(S) {
              return V(S) && O(S);
            }
            function V(S) {
              return S.hasLeadingSpaces && (S.prev ? S.prev.sourceSpan.end.line < S.sourceSpan.start.line : S.parent.type === "root" || S.parent.startSourceSpan.end.line < S.sourceSpan.start.line);
            }
            function O(S) {
              return S.hasTrailingSpaces && (S.next ? S.next.sourceSpan.start.line > S.sourceSpan.end.line : S.parent.type === "root" || S.parent.endSourceSpan && S.parent.endSourceSpan.start.line > S.sourceSpan.end.line);
            }
            function K(S) {
              switch (S.type) {
                case "ieConditionalComment":
                case "comment":
                case "directive":
                  return true;
                case "element":
                  return ["script", "select"].includes(S.name);
              }
              return false;
            }
            function se(S) {
              return S.lastChild ? se(S.lastChild) : S;
            }
            function Q(S) {
              return S.children && S.children.some((G) => G.type !== "text");
            }
            function le(S) {
              let { type: G, lang: te } = S.attrMap;
              if (G === "module" || G === "text/javascript" || G === "text/babel" || G === "application/javascript" || te === "jsx")
                return "babel";
              if (G === "application/x-typescript" || te === "ts" || te === "tsx")
                return "typescript";
              if (G === "text/markdown")
                return "markdown";
              if (G === "text/html")
                return "html";
              if (G && (G.endsWith("json") || G.endsWith("importmap")) || G === "speculationrules")
                return "json";
              if (G === "text/x-handlebars-template")
                return "glimmer";
            }
            function W(S, G) {
              let { lang: te } = S.attrMap;
              if (!te || te === "postcss" || te === "css")
                return "css";
              if (te === "scss")
                return "scss";
              if (te === "less")
                return "less";
              if (te === "stylus")
                return t("stylus", G);
            }
            function X(S, G) {
              if (S.name === "script" && !S.attrMap.src)
                return !S.attrMap.lang && !S.attrMap.type ? "babel" : le(S);
              if (S.name === "style")
                return W(S, G);
              if (G && De(S, G))
                return le(S) || !("src" in S.attrMap) && t(S.attrMap.lang, G);
            }
            function oe(S) {
              return S === "block" || S === "list-item" || S.startsWith("table");
            }
            function ae(S) {
              return !oe(S) && S !== "inline-block";
            }
            function Ae(S) {
              return !oe(S) && S !== "inline-block";
            }
            function z(S) {
              return !oe(S);
            }
            function H(S) {
              return !oe(S);
            }
            function Z(S) {
              return !oe(S) && S !== "inline-block";
            }
            function ne(S) {
              return _e(S).startsWith("pre");
            }
            function fe(S, G) {
              let te = 0;
              for (let Ee = S.stack.length - 1; Ee >= 0; Ee--) {
                let Re = S.stack[Ee];
                Re && typeof Re == "object" && !Array.isArray(Re) && G(Re) && te++;
              }
              return te;
            }
            function ge(S, G) {
              let te = S;
              for (; te; ) {
                if (G(te))
                  return true;
                te = te.parent;
              }
              return false;
            }
            function Ce(S, G) {
              if (S.prev && S.prev.type === "comment") {
                let Ee = S.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
                if (Ee)
                  return Ee[1];
              }
              let te = false;
              if (S.type === "element" && S.namespace === "svg")
                if (ge(S, (Ee) => Ee.fullName === "svg:foreignObject"))
                  te = true;
                else
                  return S.name === "svg" ? "inline-block" : "block";
              switch (G.htmlWhitespaceSensitivity) {
                case "strict":
                  return "inline";
                case "ignore":
                  return "block";
                default:
                  return G.parser === "vue" && S.parent && S.parent.type === "root" ? "block" : S.type === "element" && (!S.namespace || te || p(S)) && c[S.name] || y;
              }
            }
            function _e(S) {
              return S.type === "element" && (!S.namespace || p(S)) && h[S.name] || g;
            }
            function Oe(S) {
              let G = Number.POSITIVE_INFINITY;
              for (let te of S.split(`
`)) {
                if (te.length === 0)
                  continue;
                if (!D.has(te[0]))
                  return 0;
                let Ee = I(te).length;
                te.length !== Ee && Ee < G && (G = Ee);
              }
              return G === Number.POSITIVE_INFINITY ? 0 : G;
            }
            function pe(S) {
              let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Oe(S);
              return G === 0 ? S : S.split(`
`).map((te) => te.slice(G)).join(`
`);
            }
            function ie(S, G) {
              let te = 0;
              for (let Ee = 0; Ee < S.length; Ee++)
                S[Ee] === G && te++;
              return te;
            }
            function ve(S) {
              return S.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
            }
            var ce = /* @__PURE__ */ new Set(["template", "style", "script"]);
            function U(S, G) {
              return de(S, G) && !ce.has(S.fullName);
            }
            function de(S, G) {
              return G.parser === "vue" && S.type === "element" && S.parent.type === "root" && S.fullName.toLowerCase() !== "html";
            }
            function De(S, G) {
              return de(S, G) && (U(S, G) || S.attrMap.lang && S.attrMap.lang !== "html");
            }
            function he(S) {
              let G = S.fullName;
              return G.charAt(0) === "#" || G === "slot-scope" || G === "v-slot" || G.startsWith("v-slot:");
            }
            function Be(S, G) {
              let te = S.parent;
              if (!de(te, G))
                return false;
              let Ee = te.fullName, Re = S.fullName;
              return Ee === "script" && Re === "setup" || Ee === "style" && Re === "vars";
            }
            function Se(S) {
              let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : S.value;
              return S.parent.isWhitespaceSensitive ? S.parent.isIndentationSensitive ? l(G) : l(pe(A3(G)), r) : i(u(a, B(G)));
            }
            function ye(S, G) {
              return de(S, G) && S.name === "script";
            }
            n.exports = { htmlTrim: T, htmlTrimPreserveIndentation: A3, hasHtmlWhitespace: R, getLeadingAndTrailingHtmlWhitespace: P2, canHaveInterpolation: d, countChars: ie, countParents: fe, dedentString: pe, forceBreakChildren: q, forceBreakContent: M, forceNextEmptyLine: $, getLastDescendant: se, getNodeCssStyleDisplay: Ce, getNodeCssStyleWhiteSpace: _e, hasPrettierIgnore: x, inferScriptParser: X, isVueCustomBlock: U, isVueNonHtmlBlock: De, isVueScriptTag: ye, isVueSlotAttribute: he, isVueSfcBindingsAttribute: Be, isVueSfcBlock: de, isDanglingSpaceSensitiveNode: k, isIndentationSensitiveNode: _, isLeadingSpaceSensitiveNode: b, isPreLikeNode: ne, isScriptLikeTag: o, isTextLikeNode: E, isTrailingSpaceSensitiveNode: N, isWhitespaceSensitiveNode: C, isUnknownNamespace: p, preferHardlineAsLeadingSpaces: J, preferHardlineAsTrailingSpaces: L, shouldPreserveContent: f, unescapeQuoteEntities: ve, getTextValueParts: Se };
          } }), Ud = ee({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
            function n(i) {
              return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
            }
            e.isWhitespace = n;
            function t(i) {
              return e.$0 <= i && i <= e.$9;
            }
            e.isDigit = t;
            function s(i) {
              return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
            }
            e.isAsciiLetter = s;
            function a(i) {
              return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);
            }
            e.isAsciiHexDigit = a;
            function r(i) {
              return i === e.$LF || i === e.$CR;
            }
            e.isNewLine = r;
            function u(i) {
              return e.$0 <= i && i <= e.$7;
            }
            e.isOctalDigit = u;
          } }), Jd = ee({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = class {
              constructor(s, a, r) {
                this.filePath = s, this.name = a, this.members = r;
              }
              assertNoMembers() {
                if (this.members.length)
                  throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
              }
            };
            e.StaticSymbol = n;
            var t = class {
              constructor() {
                this.cache = /* @__PURE__ */ new Map();
              }
              get(s, a, r) {
                r = r || [];
                let u = r.length ? `.${r.join(".")}` : "", i = `"${s}".${a}${u}`, l = this.cache.get(i);
                return l || (l = new n(s, a, r), this.cache.set(i, l)), l;
              }
            };
            e.StaticSymbolCache = t;
          } }), zd = ee({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = /-+([a-z0-9])/g;
            function t(o) {
              return o.replace(n, function() {
                for (var d = arguments.length, C = new Array(d), _ = 0; _ < d; _++)
                  C[_] = arguments[_];
                return C[1].toUpperCase();
              });
            }
            e.dashCaseToCamelCase = t;
            function s(o, d) {
              return r(o, ":", d);
            }
            e.splitAtColon = s;
            function a(o, d) {
              return r(o, ".", d);
            }
            e.splitAtPeriod = a;
            function r(o, d, C) {
              let _ = o.indexOf(d);
              return _ == -1 ? C : [o.slice(0, _).trim(), o.slice(_ + 1).trim()];
            }
            function u(o, d, C) {
              return Array.isArray(o) ? d.visitArray(o, C) : F(o) ? d.visitStringMap(o, C) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? d.visitPrimitive(o, C) : d.visitOther(o, C);
            }
            e.visitValue = u;
            function i(o) {
              return o != null;
            }
            e.isDefined = i;
            function l(o) {
              return o === void 0 ? null : o;
            }
            e.noUndefined = l;
            var c = class {
              visitArray(o, d) {
                return o.map((C) => u(C, this, d));
              }
              visitStringMap(o, d) {
                let C = {};
                return Object.keys(o).forEach((_) => {
                  C[_] = u(o[_], this, d);
                }), C;
              }
              visitPrimitive(o, d) {
                return o;
              }
              visitOther(o, d) {
                return o;
              }
            };
            e.ValueTransformer = c, e.SyncAsync = { assertSync: (o) => {
              if (P2(o))
                throw new Error("Illegal state: value cannot be a promise");
              return o;
            }, then: (o, d) => P2(o) ? o.then(d) : d(o), all: (o) => o.some(P2) ? Promise.all(o) : o };
            function y(o) {
              throw new Error(`Internal Error: ${o}`);
            }
            e.error = y;
            function h(o, d) {
              let C = Error(o);
              return C[g] = true, d && (C[p] = d), C;
            }
            e.syntaxError = h;
            var g = "ngSyntaxError", p = "ngParseErrors";
            function D(o) {
              return o[g];
            }
            e.isSyntaxError = D;
            function v(o) {
              return o[p] || [];
            }
            e.getParseErrors = v;
            function w(o) {
              return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
            }
            e.escapeRegExp = w;
            var T = Object.getPrototypeOf({});
            function F(o) {
              return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === T;
            }
            function A3(o) {
              let d = "";
              for (let C = 0; C < o.length; C++) {
                let _ = o.charCodeAt(C);
                if (_ >= 55296 && _ <= 56319 && o.length > C + 1) {
                  let b = o.charCodeAt(C + 1);
                  b >= 56320 && b <= 57343 && (C++, _ = (_ - 55296 << 10) + b - 56320 + 65536);
                }
                _ <= 127 ? d += String.fromCharCode(_) : _ <= 2047 ? d += String.fromCharCode(_ >> 6 & 31 | 192, _ & 63 | 128) : _ <= 65535 ? d += String.fromCharCode(_ >> 12 | 224, _ >> 6 & 63 | 128, _ & 63 | 128) : _ <= 2097151 && (d += String.fromCharCode(_ >> 18 & 7 | 240, _ >> 12 & 63 | 128, _ >> 6 & 63 | 128, _ & 63 | 128));
              }
              return d;
            }
            e.utf8Encode = A3;
            function B(o) {
              if (typeof o == "string")
                return o;
              if (o instanceof Array)
                return "[" + o.map(B).join(", ") + "]";
              if (o == null)
                return "" + o;
              if (o.overriddenName)
                return `${o.overriddenName}`;
              if (o.name)
                return `${o.name}`;
              if (!o.toString)
                return "object";
              let d = o.toString();
              if (d == null)
                return "" + d;
              let C = d.indexOf(`
`);
              return C === -1 ? d : d.substring(0, C);
            }
            e.stringify = B;
            function I(o) {
              return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
            }
            e.resolveForwardRef = I;
            function P2(o) {
              return !!o && typeof o.then == "function";
            }
            e.isPromise = P2;
            var R = class {
              constructor(o) {
                this.full = o;
                let d = o.split(".");
                this.major = d[0], this.minor = d[1], this.patch = d.slice(2).join(".");
              }
            };
            e.Version = R;
            var f = typeof window < "u" && window, x = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m = typeof globalThis < "u" && globalThis, E = m || f || x;
            e.global = E;
          } }), Xd = ee({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Jd(), t = zd(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
            function a(C) {
              return C.replace(/\W/g, "_");
            }
            e.sanitizeIdentifier = a;
            var r = 0;
            function u(C) {
              if (!C || !C.reference)
                return null;
              let _ = C.reference;
              if (_ instanceof n.StaticSymbol)
                return _.name;
              if (_.__anonymousType)
                return _.__anonymousType;
              let b = t.stringify(_);
              return b.indexOf("(") >= 0 ? (b = `anonymous_${r++}`, _.__anonymousType = b) : b = a(b), b;
            }
            e.identifierName = u;
            function i(C) {
              let _ = C.reference;
              return _ instanceof n.StaticSymbol ? _.filePath : `./${t.stringify(_)}`;
            }
            e.identifierModuleUrl = i;
            function l(C, _) {
              return `View_${u({ reference: C })}_${_}`;
            }
            e.viewClassName = l;
            function c(C) {
              return `RenderType_${u({ reference: C })}`;
            }
            e.rendererTypeName = c;
            function y(C) {
              return `HostView_${u({ reference: C })}`;
            }
            e.hostViewClassName = y;
            function h(C) {
              return `${u({ reference: C })}NgFactory`;
            }
            e.componentFactoryName = h;
            var g;
            (function(C) {
              C[C.Pipe = 0] = "Pipe", C[C.Directive = 1] = "Directive", C[C.NgModule = 2] = "NgModule", C[C.Injectable = 3] = "Injectable";
            })(g = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
            function p(C) {
              return C.value != null ? a(C.value) : u(C.identifier);
            }
            e.tokenName = p;
            function D(C) {
              return C.identifier != null ? C.identifier.reference : C.value;
            }
            e.tokenReference = D;
            var v = class {
              constructor() {
                let { moduleUrl: C, styles: _, styleUrls: b } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                this.moduleUrl = C || null, this.styles = P2(_), this.styleUrls = P2(b);
              }
            };
            e.CompileStylesheetMetadata = v;
            var w = class {
              constructor(C) {
                let { encapsulation: _, template: b, templateUrl: N, htmlAst: k, styles: $, styleUrls: M, externalStylesheets: q, animations: J, ngContentSelectors: L, interpolation: Y, isInline: V, preserveWhitespaces: O } = C;
                if (this.encapsulation = _, this.template = b, this.templateUrl = N, this.htmlAst = k, this.styles = P2($), this.styleUrls = P2(M), this.externalStylesheets = P2(q), this.animations = J ? f(J) : [], this.ngContentSelectors = L || [], Y && Y.length != 2)
                  throw new Error("'interpolation' should have a start and an end symbol.");
                this.interpolation = Y, this.isInline = V, this.preserveWhitespaces = O;
              }
              toSummary() {
                return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
              }
            };
            e.CompileTemplateMetadata = w;
            var T = class {
              static create(C) {
                let { isHost: _, type: b, isComponent: N, selector: k, exportAs: $, changeDetection: M, inputs: q, outputs: J, host: L, providers: Y, viewProviders: V, queries: O, guards: K, viewQueries: se, entryComponents: Q, template: le, componentViewType: W, rendererType: X, componentFactory: oe } = C, ae = {}, Ae = {}, z = {};
                L != null && Object.keys(L).forEach((ne) => {
                  let fe = L[ne], ge = ne.match(s);
                  ge === null ? z[ne] = fe : ge[1] != null ? Ae[ge[1]] = fe : ge[2] != null && (ae[ge[2]] = fe);
                });
                let H = {};
                q == null ? void 0 : q.forEach((ne) => {
                  let fe = t.splitAtColon(ne, [ne, ne]);
                  H[fe[0]] = fe[1];
                });
                let Z = {};
                return J == null ? void 0 : J.forEach((ne) => {
                  let fe = t.splitAtColon(ne, [ne, ne]);
                  Z[fe[0]] = fe[1];
                }), new T({ isHost: _, type: b, isComponent: !!N, selector: k, exportAs: $, changeDetection: M, inputs: H, outputs: Z, hostListeners: ae, hostProperties: Ae, hostAttributes: z, providers: Y, viewProviders: V, queries: O, guards: K, viewQueries: se, entryComponents: Q, template: le, componentViewType: W, rendererType: X, componentFactory: oe });
              }
              constructor(C) {
                let { isHost: _, type: b, isComponent: N, selector: k, exportAs: $, changeDetection: M, inputs: q, outputs: J, hostListeners: L, hostProperties: Y, hostAttributes: V, providers: O, viewProviders: K, queries: se, guards: Q, viewQueries: le, entryComponents: W, template: X, componentViewType: oe, rendererType: ae, componentFactory: Ae } = C;
                this.isHost = !!_, this.type = b, this.isComponent = N, this.selector = k, this.exportAs = $, this.changeDetection = M, this.inputs = q, this.outputs = J, this.hostListeners = L, this.hostProperties = Y, this.hostAttributes = V, this.providers = P2(O), this.viewProviders = P2(K), this.queries = P2(se), this.guards = Q, this.viewQueries = P2(le), this.entryComponents = P2(W), this.template = X, this.componentViewType = oe, this.rendererType = ae, this.componentFactory = Ae;
              }
              toSummary() {
                return { summaryKind: g.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
              }
            };
            e.CompileDirectiveMetadata = T;
            var F = class {
              constructor(C) {
                let { type: _, name: b, pure: N } = C;
                this.type = _, this.name = b, this.pure = !!N;
              }
              toSummary() {
                return { summaryKind: g.Pipe, type: this.type, name: this.name, pure: this.pure };
              }
            };
            e.CompilePipeMetadata = F;
            var A3 = class {
            };
            e.CompileShallowModuleMetadata = A3;
            var B = class {
              constructor(C) {
                let { type: _, providers: b, declaredDirectives: N, exportedDirectives: k, declaredPipes: $, exportedPipes: M, entryComponents: q, bootstrapComponents: J, importedModules: L, exportedModules: Y, schemas: V, transitiveModule: O, id: K } = C;
                this.type = _ || null, this.declaredDirectives = P2(N), this.exportedDirectives = P2(k), this.declaredPipes = P2($), this.exportedPipes = P2(M), this.providers = P2(b), this.entryComponents = P2(q), this.bootstrapComponents = P2(J), this.importedModules = P2(L), this.exportedModules = P2(Y), this.schemas = P2(V), this.id = K || null, this.transitiveModule = O || null;
              }
              toSummary() {
                let C = this.transitiveModule;
                return { summaryKind: g.NgModule, type: this.type, entryComponents: C.entryComponents, providers: C.providers, modules: C.modules, exportedDirectives: C.exportedDirectives, exportedPipes: C.exportedPipes };
              }
            };
            e.CompileNgModuleMetadata = B;
            var I = class {
              constructor() {
                this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
              }
              addProvider(C, _) {
                this.providers.push({ provider: C, module: _ });
              }
              addDirective(C) {
                this.directivesSet.has(C.reference) || (this.directivesSet.add(C.reference), this.directives.push(C));
              }
              addExportedDirective(C) {
                this.exportedDirectivesSet.has(C.reference) || (this.exportedDirectivesSet.add(C.reference), this.exportedDirectives.push(C));
              }
              addPipe(C) {
                this.pipesSet.has(C.reference) || (this.pipesSet.add(C.reference), this.pipes.push(C));
              }
              addExportedPipe(C) {
                this.exportedPipesSet.has(C.reference) || (this.exportedPipesSet.add(C.reference), this.exportedPipes.push(C));
              }
              addModule(C) {
                this.modulesSet.has(C.reference) || (this.modulesSet.add(C.reference), this.modules.push(C));
              }
              addEntryComponent(C) {
                this.entryComponentsSet.has(C.componentType) || (this.entryComponentsSet.add(C.componentType), this.entryComponents.push(C));
              }
            };
            e.TransitiveCompileNgModuleMetadata = I;
            function P2(C) {
              return C || [];
            }
            var R = class {
              constructor(C, _) {
                let { useClass: b, useValue: N, useExisting: k, useFactory: $, deps: M, multi: q } = _;
                this.token = C, this.useClass = b || null, this.useValue = N, this.useExisting = k, this.useFactory = $ || null, this.dependencies = M || null, this.multi = !!q;
              }
            };
            e.ProviderMeta = R;
            function f(C) {
              return C.reduce((_, b) => {
                let N = Array.isArray(b) ? f(b) : b;
                return _.concat(N);
              }, []);
            }
            e.flatten = f;
            function x(C) {
              return C.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
            }
            function m(C, _, b) {
              let N;
              return b.isInline ? _.type.reference instanceof n.StaticSymbol ? N = `${_.type.reference.filePath}.${_.type.reference.name}.html` : N = `${u(C)}/${u(_.type)}.html` : N = b.templateUrl, _.type.reference instanceof n.StaticSymbol ? N : x(N);
            }
            e.templateSourceUrl = m;
            function E(C, _) {
              let b = C.moduleUrl.split(/\/\\/g), N = b[b.length - 1];
              return x(`css/${_}${N}.ngstyle.js`);
            }
            e.sharedStylesheetJitUrl = E;
            function o(C) {
              return x(`${u(C.type)}/module.ngfactory.js`);
            }
            e.ngModuleJitUrl = o;
            function d(C, _) {
              return x(`${u(C)}/${u(_.type)}.ngfactory.js`);
            }
            e.templateJitUrl = d;
          } }), Kd = ee({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
            "use strict";
            re(), Object.defineProperty(e, "__esModule", { value: true });
            var n = Ud(), t = Xd(), s = class {
              constructor(y, h, g, p) {
                this.file = y, this.offset = h, this.line = g, this.col = p;
              }
              toString() {
                return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
              }
              moveBy(y) {
                let h = this.file.content, g = h.length, p = this.offset, D = this.line, v = this.col;
                for (; p > 0 && y < 0; )
                  if (p--, y++, h.charCodeAt(p) == n.$LF) {
                    D--;
                    let T = h.substr(0, p - 1).lastIndexOf(String.fromCharCode(n.$LF));
                    v = T > 0 ? p - T : p;
                  } else
                    v--;
                for (; p < g && y > 0; ) {
                  let w = h.charCodeAt(p);
                  p++, y--, w == n.$LF ? (D++, v = 0) : v++;
                }
                return new s(this.file, p, D, v);
              }
              getContext(y, h) {
                let g = this.file.content, p = this.offset;
                if (p != null) {
                  p > g.length - 1 && (p = g.length - 1);
                  let D = p, v = 0, w = 0;
                  for (; v < y && p > 0 && (p--, v++, !(g[p] == `
` && ++w == h)); )
                    ;
                  for (v = 0, w = 0; v < y && D < g.length - 1 && (D++, v++, !(g[D] == `
` && ++w == h)); )
                    ;
                  return { before: g.substring(p, this.offset), after: g.substring(this.offset, D + 1) };
                }
                return null;
              }
            };
            e.ParseLocation = s;
            var a = class {
              constructor(y, h) {
                this.content = y, this.url = h;
              }
            };
            e.ParseSourceFile = a;
            var r = class {
              constructor(y, h) {
                let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                this.start = y, this.end = h, this.details = g;
              }
              toString() {
                return this.start.file.content.substring(this.start.offset, this.end.offset);
              }
            };
            e.ParseSourceSpan = r, e.EMPTY_PARSE_LOCATION = new s(new a("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new r(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
            var u;
            (function(y) {
              y[y.WARNING = 0] = "WARNING", y[y.ERROR = 1] = "ERROR";
            })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
            var i = class {
              constructor(y, h) {
                let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
                this.span = y, this.msg = h, this.level = g;
              }
              contextualMessage() {
                let y = this.span.start.getContext(100, 3);
                return y ? `${this.msg} ("${y.before}[${u[this.level]} ->]${y.after}")` : this.msg;
              }
              toString() {
                let y = this.span.details ? `, ${this.span.details}` : "";
                return `${this.contextualMessage()}: ${this.span.start}${y}`;
              }
            };
            e.ParseError = i;
            function l(y, h) {
              let g = t.identifierModuleUrl(h), p = g != null ? `in ${y} ${t.identifierName(h)} in ${g}` : `in ${y} ${t.identifierName(h)}`, D = new a("", p);
              return new r(new s(D, -1, -1, -1), new s(D, -1, -1, -1));
            }
            e.typeSourceSpan = l;
            function c(y, h, g) {
              let p = `in ${y} ${h} in ${g}`, D = new a("", p);
              return new r(new s(D, -1, -1, -1), new s(D, -1, -1, -1));
            }
            e.r3JitTypeSourceSpan = c;
          } }), Yd = ee({ "src/language-html/print-preprocess.js"(e, n) {
            "use strict";
            re();
            var { ParseSourceSpan: t } = Kd(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: a, hasHtmlWhitespace: r, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: l, isIndentationSensitiveNode: c, isLeadingSpaceSensitiveNode: y, isTrailingSpaceSensitiveNode: h, isWhitespaceSensitiveNode: g, isVueScriptTag: p } = Mt(), D = [w, T, A3, I, P2, x, R, f, m, B, E];
            function v(o, d) {
              for (let C of D)
                C(o, d);
              return o;
            }
            function w(o) {
              o.walk((d) => {
                if (d.type === "element" && d.tagDefinition.ignoreFirstLf && d.children.length > 0 && d.children[0].type === "text" && d.children[0].value[0] === `
`) {
                  let C = d.children[0];
                  C.value.length === 1 ? d.removeChild(C) : C.value = C.value.slice(1);
                }
              });
            }
            function T(o) {
              let d = (C) => C.type === "element" && C.prev && C.prev.type === "ieConditionalStartComment" && C.prev.sourceSpan.end.offset === C.startSourceSpan.start.offset && C.firstChild && C.firstChild.type === "ieConditionalEndComment" && C.firstChild.sourceSpan.start.offset === C.startSourceSpan.end.offset;
              o.walk((C) => {
                if (C.children)
                  for (let _ = 0; _ < C.children.length; _++) {
                    let b = C.children[_];
                    if (!d(b))
                      continue;
                    let N = b.prev, k = b.firstChild;
                    C.removeChild(N), _--;
                    let $ = new t(N.sourceSpan.start, k.sourceSpan.end), M = new t($.start, b.sourceSpan.end);
                    b.condition = N.condition, b.sourceSpan = M, b.startSourceSpan = $, b.removeChild(k);
                  }
              });
            }
            function F(o, d, C) {
              o.walk((_) => {
                if (_.children)
                  for (let b = 0; b < _.children.length; b++) {
                    let N = _.children[b];
                    if (N.type !== "text" && !d(N))
                      continue;
                    N.type !== "text" && (N.type = "text", N.value = C(N));
                    let k = N.prev;
                    !k || k.type !== "text" || (k.value += N.value, k.sourceSpan = new t(k.sourceSpan.start, N.sourceSpan.end), _.removeChild(N), b--);
                  }
              });
            }
            function A3(o) {
              return F(o, (d) => d.type === "cdata", (d) => `<![CDATA[${d.value}]]>`);
            }
            function B(o) {
              let d = (C) => C.type === "element" && C.attrs.length === 0 && C.children.length === 1 && C.firstChild.type === "text" && !r(C.children[0].value) && !C.firstChild.hasLeadingSpaces && !C.firstChild.hasTrailingSpaces && C.isLeadingSpaceSensitive && !C.hasLeadingSpaces && C.isTrailingSpaceSensitive && !C.hasTrailingSpaces && C.prev && C.prev.type === "text" && C.next && C.next.type === "text";
              o.walk((C) => {
                if (C.children)
                  for (let _ = 0; _ < C.children.length; _++) {
                    let b = C.children[_];
                    if (!d(b))
                      continue;
                    let N = b.prev, k = b.next;
                    N.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, N.sourceSpan = new t(N.sourceSpan.start, k.sourceSpan.end), N.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, N.hasTrailingSpaces = k.hasTrailingSpaces, C.removeChild(b), _--, C.removeChild(k);
                  }
              });
            }
            function I(o, d) {
              if (d.parser === "html")
                return;
              let C = /{{(.+?)}}/s;
              o.walk((_) => {
                if (u(_))
                  for (let b of _.children) {
                    if (b.type !== "text")
                      continue;
                    let N = b.sourceSpan.start, k = null, $ = b.value.split(C);
                    for (let M = 0; M < $.length; M++, N = k) {
                      let q = $[M];
                      if (M % 2 === 0) {
                        k = N.moveBy(q.length), q.length > 0 && _.insertChildBefore(b, { type: "text", value: q, sourceSpan: new t(N, k) });
                        continue;
                      }
                      k = N.moveBy(q.length + 4), _.insertChildBefore(b, { type: "interpolation", sourceSpan: new t(N, k), children: q.length === 0 ? [] : [{ type: "text", value: q, sourceSpan: new t(N.moveBy(2), k.moveBy(-2)) }] });
                    }
                    _.removeChild(b);
                  }
              });
            }
            function P2(o) {
              o.walk((d) => {
                if (!d.children)
                  return;
                if (d.children.length === 0 || d.children.length === 1 && d.children[0].type === "text" && s(d.children[0].value).length === 0) {
                  d.hasDanglingSpaces = d.children.length > 0, d.children = [];
                  return;
                }
                let C = g(d), _ = c(d);
                if (!C)
                  for (let b = 0; b < d.children.length; b++) {
                    let N = d.children[b];
                    if (N.type !== "text")
                      continue;
                    let { leadingWhitespace: k, text: $, trailingWhitespace: M } = a(N.value), q = N.prev, J = N.next;
                    $ ? (N.value = $, N.sourceSpan = new t(N.sourceSpan.start.moveBy(k.length), N.sourceSpan.end.moveBy(-M.length)), k && (q && (q.hasTrailingSpaces = true), N.hasLeadingSpaces = true), M && (N.hasTrailingSpaces = true, J && (J.hasLeadingSpaces = true))) : (d.removeChild(N), b--, (k || M) && (q && (q.hasTrailingSpaces = true), J && (J.hasLeadingSpaces = true)));
                  }
                d.isWhitespaceSensitive = C, d.isIndentationSensitive = _;
              });
            }
            function R(o) {
              o.walk((d) => {
                d.isSelfClosing = !d.children || d.type === "element" && (d.tagDefinition.isVoid || d.startSourceSpan === d.endSourceSpan);
              });
            }
            function f(o, d) {
              o.walk((C) => {
                C.type === "element" && (C.hasHtmComponentClosingTag = C.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(d.originalText.slice(C.endSourceSpan.start.offset, C.endSourceSpan.end.offset)));
              });
            }
            function x(o, d) {
              o.walk((C) => {
                C.cssDisplay = i(C, d);
              });
            }
            function m(o, d) {
              o.walk((C) => {
                let { children: _ } = C;
                if (_) {
                  if (_.length === 0) {
                    C.isDanglingSpaceSensitive = l(C);
                    return;
                  }
                  for (let b of _)
                    b.isLeadingSpaceSensitive = y(b, d), b.isTrailingSpaceSensitive = h(b, d);
                  for (let b = 0; b < _.length; b++) {
                    let N = _[b];
                    N.isLeadingSpaceSensitive = (b === 0 || N.prev.isTrailingSpaceSensitive) && N.isLeadingSpaceSensitive, N.isTrailingSpaceSensitive = (b === _.length - 1 || N.next.isLeadingSpaceSensitive) && N.isTrailingSpaceSensitive;
                  }
                }
              });
            }
            function E(o, d) {
              if (d.parser === "vue") {
                let C = o.children.find((b) => p(b, d));
                if (!C)
                  return;
                let { lang: _ } = C.attrMap;
                (_ === "ts" || _ === "typescript") && (d.__should_parse_vue_template_with_ts = true);
              }
            }
            n.exports = v;
          } }), Qd = ee({ "src/language-html/pragma.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a);
            }
            function s(a) {
              return `<!-- @format -->

` + a.replace(/^\s*\n/, "");
            }
            n.exports = { hasPragma: t, insertPragma: s };
          } }), Qn = ee({ "src/language-html/loc.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return a.sourceSpan.start.offset;
            }
            function s(a) {
              return a.sourceSpan.end.offset;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), rr = ee({ "src/language-html/print/tag.js"(e, n) {
            "use strict";
            re();
            var t = Yt(), { isNonEmptyArray: s } = Ge(), { builders: { indent: a, join: r, line: u, softline: i, hardline: l }, utils: { replaceTextEndOfLine: c } } = qe(), { locStart: y, locEnd: h } = Qn(), { isTextLikeNode: g, getLastDescendant: p, isPreLikeNode: D, hasPrettierIgnore: v, shouldPreserveContent: w, isVueSfcBlock: T } = Mt();
            function F(L, Y) {
              return [L.isSelfClosing ? "" : A3(L, Y), B(L, Y)];
            }
            function A3(L, Y) {
              return L.lastChild && o(L.lastChild) ? "" : [I(L, Y), R(L, Y)];
            }
            function B(L, Y) {
              return (L.next ? m(L.next) : E(L.parent)) ? "" : [f(L, Y), P2(L, Y)];
            }
            function I(L, Y) {
              return E(L) ? f(L.lastChild, Y) : "";
            }
            function P2(L, Y) {
              return o(L) ? R(L.parent, Y) : d(L) ? q(L.next) : "";
            }
            function R(L, Y) {
              if (t(!L.isSelfClosing), x(L, Y))
                return "";
              switch (L.type) {
                case "ieConditionalComment":
                  return "<!";
                case "element":
                  if (L.hasHtmComponentClosingTag)
                    return "<//";
                default:
                  return `</${L.rawName}`;
              }
            }
            function f(L, Y) {
              if (x(L, Y))
                return "";
              switch (L.type) {
                case "ieConditionalComment":
                case "ieConditionalEndComment":
                  return "[endif]-->";
                case "ieConditionalStartComment":
                  return "]><!-->";
                case "interpolation":
                  return "}}";
                case "element":
                  if (L.isSelfClosing)
                    return "/>";
                default:
                  return ">";
              }
            }
            function x(L, Y) {
              return !L.isSelfClosing && !L.endSourceSpan && (v(L) || w(L.parent, Y));
            }
            function m(L) {
              return L.prev && L.prev.type !== "docType" && !g(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
            }
            function E(L) {
              return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g(p(L.lastChild)) && !D(L);
            }
            function o(L) {
              return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g(p(L));
            }
            function d(L) {
              return L.next && !g(L.next) && g(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;
            }
            function C(L) {
              let Y = L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
              return Y ? Y[1] ? Y[1].split(/\s+/) : true : false;
            }
            function _(L) {
              return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
            }
            function b(L, Y, V) {
              let O = L.getValue();
              if (!s(O.attrs))
                return O.isSelfClosing ? " " : "";
              let K = O.prev && O.prev.type === "comment" && C(O.prev.value), se = typeof K == "boolean" ? () => K : Array.isArray(K) ? (ae) => K.includes(ae.rawName) : () => false, Q = L.map((ae) => {
                let Ae = ae.getValue();
                return se(Ae) ? c(Y.originalText.slice(y(Ae), h(Ae))) : V();
              }, "attrs"), le = O.type === "element" && O.fullName === "script" && O.attrs.length === 1 && O.attrs[0].fullName === "src" && O.children.length === 0, X = Y.singleAttributePerLine && O.attrs.length > 1 && !T(O, Y) ? l : u, oe = [a([le ? " " : u, r(X, Q)])];
              return O.firstChild && _(O.firstChild) || O.isSelfClosing && E(O.parent) || le ? oe.push(O.isSelfClosing ? " " : "") : oe.push(Y.bracketSameLine ? O.isSelfClosing ? " " : "" : O.isSelfClosing ? u : i), oe;
            }
            function N(L) {
              return L.firstChild && _(L.firstChild) ? "" : J(L);
            }
            function k(L, Y, V) {
              let O = L.getValue();
              return [$(O, Y), b(L, Y, V), O.isSelfClosing ? "" : N(O)];
            }
            function $(L, Y) {
              return L.prev && d(L.prev) ? "" : [M(L, Y), q(L)];
            }
            function M(L, Y) {
              return _(L) ? J(L.parent) : m(L) ? f(L.prev, Y) : "";
            }
            function q(L) {
              switch (L.type) {
                case "ieConditionalComment":
                case "ieConditionalStartComment":
                  return `<!--[if ${L.condition}`;
                case "ieConditionalEndComment":
                  return "<!--<!";
                case "interpolation":
                  return "{{";
                case "docType":
                  return "<!DOCTYPE";
                case "element":
                  if (L.condition)
                    return `<!--[if ${L.condition}]><!--><${L.rawName}`;
                default:
                  return `<${L.rawName}`;
              }
            }
            function J(L) {
              switch (t(!L.isSelfClosing), L.type) {
                case "ieConditionalComment":
                  return "]>";
                case "element":
                  if (L.condition)
                    return "><!--<![endif]-->";
                default:
                  return ">";
              }
            }
            n.exports = { printClosingTag: F, printClosingTagStart: A3, printClosingTagStartMarker: R, printClosingTagEndMarker: f, printClosingTagSuffix: P2, printClosingTagEnd: B, needsToBorrowLastChildClosingTagEndMarker: E, needsToBorrowParentClosingTagStartMarker: o, needsToBorrowPrevClosingTagEndMarker: m, printOpeningTag: k, printOpeningTagStart: $, printOpeningTagPrefix: M, printOpeningTagStartMarker: q, printOpeningTagEndMarker: J, needsToBorrowNextOpeningTagStartMarker: d, needsToBorrowParentOpeningTagEndMarker: _ };
          } }), Zd = ee({ "node_modules/parse-srcset/src/parse-srcset.js"(e, n) {
            re(), function(t, s) {
              typeof define == "function" && define.amd ? define([], s) : typeof n == "object" && n.exports ? n.exports = s() : t.parseSrcset = s();
            }(e, function() {
              return function(t, s) {
                var a = s && s.logger || console;
                function r(R) {
                  return R === " " || R === "	" || R === `
` || R === "\f" || R === "\r";
                }
                function u(R) {
                  var f, x = R.exec(t.substring(A3));
                  if (x)
                    return f = x[0], A3 += f.length, f;
                }
                for (var i = t.length, l = /^[ \t\n\r\u000c]+/, c = /^[, \t\n\r\u000c]+/, y = /^[^ \t\n\r\u000c]+/, h = /[,]+$/, g = /^\d+$/, p = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, D, v, w, T, F, A3 = 0, B = []; ; ) {
                  if (u(c), A3 >= i)
                    return B;
                  D = u(y), v = [], D.slice(-1) === "," ? (D = D.replace(h, ""), P2()) : I();
                }
                function I() {
                  for (u(l), w = "", T = "in descriptor"; ; ) {
                    if (F = t.charAt(A3), T === "in descriptor")
                      if (r(F))
                        w && (v.push(w), w = "", T = "after descriptor");
                      else if (F === ",") {
                        A3 += 1, w && v.push(w), P2();
                        return;
                      } else if (F === "(")
                        w = w + F, T = "in parens";
                      else if (F === "") {
                        w && v.push(w), P2();
                        return;
                      } else
                        w = w + F;
                    else if (T === "in parens")
                      if (F === ")")
                        w = w + F, T = "in descriptor";
                      else if (F === "") {
                        v.push(w), P2();
                        return;
                      } else
                        w = w + F;
                    else if (T === "after descriptor" && !r(F))
                      if (F === "") {
                        P2();
                        return;
                      } else
                        T = "in descriptor", A3 -= 1;
                    A3 += 1;
                  }
                }
                function P2() {
                  var R = false, f, x, m, E, o = {}, d, C, _, b, N;
                  for (E = 0; E < v.length; E++)
                    d = v[E], C = d[d.length - 1], _ = d.substring(0, d.length - 1), b = parseInt(_, 10), N = parseFloat(_), g.test(_) && C === "w" ? ((f || x) && (R = true), b === 0 ? R = true : f = b) : p.test(_) && C === "x" ? ((f || x || m) && (R = true), N < 0 ? R = true : x = N) : g.test(_) && C === "h" ? ((m || x) && (R = true), b === 0 ? R = true : m = b) : R = true;
                  R ? a && a.error && a.error("Invalid srcset descriptor found in '" + t + "' at '" + d + "'.") : (o.url = D, f && (o.w = f), x && (o.d = x), m && (o.h = m), B.push(o));
                }
              };
            });
          } }), eg = ee({ "src/language-html/syntax-attribute.js"(e, n) {
            "use strict";
            re();
            var t = Zd(), { builders: { ifBreak: s, join: a, line: r } } = qe();
            function u(l) {
              let c = t(l, { logger: { error(I) {
                throw new Error(I);
              } } }), y = c.some((I) => {
                let { w: P2 } = I;
                return P2;
              }), h = c.some((I) => {
                let { h: P2 } = I;
                return P2;
              }), g = c.some((I) => {
                let { d: P2 } = I;
                return P2;
              });
              if (y + h + g > 1)
                throw new Error("Mixed descriptor in srcset is not supported");
              let p = y ? "w" : h ? "h" : "d", D = y ? "w" : h ? "h" : "x", v = (I) => Math.max(...I), w = c.map((I) => I.url), T = v(w.map((I) => I.length)), F = c.map((I) => I[p]).map((I) => I ? I.toString() : ""), A3 = F.map((I) => {
                let P2 = I.indexOf(".");
                return P2 === -1 ? I.length : P2;
              }), B = v(A3);
              return a([",", r], w.map((I, P2) => {
                let R = [I], f = F[P2];
                if (f) {
                  let x = T - I.length + 1, m = B - A3[P2], E = " ".repeat(x + m);
                  R.push(s(E, " "), f + D);
                }
                return R;
              }));
            }
            function i(l) {
              return l.trim().split(/\s+/).join(" ");
            }
            n.exports = { printImgSrcset: u, printClassNames: i };
          } }), tg = ee({ "src/language-html/syntax-vue.js"(e, n) {
            "use strict";
            re();
            var { builders: { group: t } } = qe();
            function s(i, l) {
              let { left: c, operator: y, right: h } = a(i);
              return [t(l(`function _(${c}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", y, " ", l(h, { parser: "__js_expression" }, { stripTrailingHardline: true })];
            }
            function a(i) {
              let l = /(.*?)\s+(in|of)\s+(.*)/s, c = /,([^,\]}]*)(?:,([^,\]}]*))?$/, y = /^\(|\)$/g, h = i.match(l);
              if (!h)
                return;
              let g = {};
              if (g.for = h[3].trim(), !g.for)
                return;
              let p = h[1].trim().replace(y, ""), D = p.match(c);
              D ? (g.alias = p.replace(c, ""), g.iterator1 = D[1].trim(), D[2] && (g.iterator2 = D[2].trim())) : g.alias = p;
              let v = [g.alias, g.iterator1, g.iterator2];
              if (!v.some((w, T) => !w && (T === 0 || v.slice(T + 1).some(Boolean))))
                return { left: v.filter(Boolean).join(","), operator: h[2], right: g.for };
            }
            function r(i, l) {
              return l(`function _(${i}) {}`, { parser: "babel", __isVueBindings: true });
            }
            function u(i) {
              let l = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, c = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, y = i.trim();
              return l.test(y) || c.test(y);
            }
            n.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: r };
          } }), fo = ee({ "src/language-html/get-node-content.js"(e, n) {
            "use strict";
            re();
            var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: a, printClosingTagEndMarker: r, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = rr();
            function l(c, y) {
              let h = c.startSourceSpan.end.offset;
              c.firstChild && u(c.firstChild) && (h -= i(c).length);
              let g = c.endSourceSpan.start.offset;
              return c.lastChild && t(c.lastChild) ? g += s(c, y).length : a(c) && (g -= r(c.lastChild, y).length), y.originalText.slice(h, g);
            }
            n.exports = l;
          } }), rg = ee({ "src/language-html/embed.js"(e, n) {
            "use strict";
            re();
            var { builders: { breakParent: t, group: s, hardline: a, indent: r, line: u, fill: i, softline: l }, utils: { mapDoc: c, replaceTextEndOfLine: y } } = qe(), h = Kn(), { printClosingTag: g, printClosingTagSuffix: p, needsToBorrowPrevClosingTagEndMarker: D, printOpeningTagPrefix: v, printOpeningTag: w } = rr(), { printImgSrcset: T, printClassNames: F } = eg(), { printVueFor: A3, printVueBindings: B, isVueEventBindingExpression: I } = tg(), { isScriptLikeTag: P2, isVueNonHtmlBlock: R, inferScriptParser: f, htmlTrimPreserveIndentation: x, dedentString: m, unescapeQuoteEntities: E, isVueSlotAttribute: o, isVueSfcBindingsAttribute: d, getTextValueParts: C } = Mt(), _ = fo();
            function b(k, $, M) {
              let q = (Q) => new RegExp(Q.join("|")).test(k.fullName), J = () => E(k.value), L = false, Y = (Q, le) => {
                let W = Q.type === "NGRoot" ? Q.node.type === "NGMicrosyntax" && Q.node.body.length === 1 && Q.node.body[0].type === "NGMicrosyntaxExpression" ? Q.node.body[0].expression : Q.node : Q.type === "JsExpressionRoot" ? Q.node : Q;
                W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || le.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (L = true);
              }, V = (Q) => s(Q), O = function(Q) {
                let le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                return s([r([l, Q]), le ? l : ""]);
              }, K = (Q) => L ? V(Q) : O(Q), se = (Q, le) => $(Q, Object.assign({ __onHtmlBindingRoot: Y, __embeddedInHtml: true }, le));
              if (k.fullName === "srcset" && (k.parent.fullName === "img" || k.parent.fullName === "source"))
                return O(T(J()));
              if (k.fullName === "class" && !M.parentParser) {
                let Q = J();
                if (!Q.includes("{{"))
                  return F(Q);
              }
              if (k.fullName === "style" && !M.parentParser) {
                let Q = J();
                if (!Q.includes("{{"))
                  return O(se(Q, { parser: "css", __isHTMLStyleAttribute: true }));
              }
              if (M.parser === "vue") {
                if (k.fullName === "v-for")
                  return A3(J(), se);
                if (o(k) || d(k, M))
                  return B(J(), se);
                let Q = ["^@", "^v-on:"], le = ["^:", "^v-bind:"], W = ["^v-"];
                if (q(Q)) {
                  let X = J(), oe = I(X) ? "__js_expression" : M.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                  return K(se(X, { parser: oe }));
                }
                if (q(le))
                  return K(se(J(), { parser: "__vue_expression" }));
                if (q(W))
                  return K(se(J(), { parser: "__js_expression" }));
              }
              if (M.parser === "angular") {
                let Q = (z, H) => se(z, Object.assign(Object.assign({}, H), {}, { trailingComma: "none" })), le = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], X = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], oe = ["^i18n(-.+)?$"];
                if (q(W))
                  return K(Q(J(), { parser: "__ng_action" }));
                if (q(X))
                  return K(Q(J(), { parser: "__ng_binding" }));
                if (q(oe)) {
                  let z = J().trim();
                  return O(i(C(k, z)), !z.includes("@@"));
                }
                if (q(le))
                  return K(Q(J(), { parser: "__ng_directive" }));
                let ae = /{{(.+?)}}/s, Ae = J();
                if (ae.test(Ae)) {
                  let z = [];
                  for (let [H, Z] of Ae.split(ae).entries())
                    if (H % 2 === 0)
                      z.push(y(Z));
                    else
                      try {
                        z.push(s(["{{", r([u, Q(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                      } catch {
                        z.push("{{", y(Z), "}}");
                      }
                  return s(z);
                }
              }
              return null;
            }
            function N(k, $, M, q) {
              let J = k.getValue();
              switch (J.type) {
                case "element": {
                  if (P2(J) || J.type === "interpolation")
                    return;
                  if (!J.isSelfClosing && R(J, q)) {
                    let L = f(J, q);
                    if (!L)
                      return;
                    let Y = _(J, q), V = /^\s*$/.test(Y), O = "";
                    return V || (O = M(x(Y), { parser: L, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = O === ""), [v(J, q), s(w(k, q, $)), V ? "" : a, O, V ? "" : a, g(J, q), p(J, q)];
                  }
                  break;
                }
                case "text": {
                  if (P2(J.parent)) {
                    let L = f(J.parent, q);
                    if (L) {
                      let Y = L === "markdown" ? m(J.value.replace(/^[^\S\n]*\n/, "")) : J.value, V = { parser: L, __embeddedInHtml: true };
                      if (q.parser === "html" && L === "babel") {
                        let O = "script", { attrMap: K } = J.parent;
                        K && (K.type === "module" || K.type === "text/babel" && K["data-type"] === "module") && (O = "module"), V.__babelSourceType = O;
                      }
                      return [t, v(J, q), M(Y, V, { stripTrailingHardline: true }), p(J, q)];
                    }
                  } else if (J.parent.type === "interpolation") {
                    let L = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                    return q.parser === "angular" ? (L.parser = "__ng_interpolation", L.trailingComma = "none") : q.parser === "vue" ? L.parser = q.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L.parser = "__js_expression", [r([u, M(J.value, L, { stripTrailingHardline: true })]), J.parent.next && D(J.parent.next) ? " " : u];
                  }
                  break;
                }
                case "attribute": {
                  if (!J.value)
                    break;
                  if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                    return [J.rawName, "=", J.value];
                  if (q.parser === "lwc" && /^{.*}$/s.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                    return [J.rawName, "=", J.value];
                  let L = b(J, (Y, V) => M(Y, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q);
                  if (L)
                    return [J.rawName, '="', s(c(L, (Y) => typeof Y == "string" ? Y.replace(/"/g, "&quot;") : Y)), '"'];
                  break;
                }
                case "front-matter":
                  return h(J, M);
              }
            }
            n.exports = N;
          } }), Do = ee({ "src/language-html/print/children.js"(e, n) {
            "use strict";
            re();
            var { builders: { breakParent: t, group: s, ifBreak: a, line: r, softline: u, hardline: i }, utils: { replaceTextEndOfLine: l } } = qe(), { locStart: c, locEnd: y } = Qn(), { forceBreakChildren: h, forceNextEmptyLine: g, isTextLikeNode: p, hasPrettierIgnore: D, preferHardlineAsLeadingSpaces: v } = Mt(), { printOpeningTagPrefix: w, needsToBorrowNextOpeningTagStartMarker: T, printOpeningTagStartMarker: F, needsToBorrowPrevClosingTagEndMarker: A3, printClosingTagEndMarker: B, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: P2 } = rr();
            function R(m, E, o) {
              let d = m.getValue();
              return D(d) ? [w(d, E), ...l(E.originalText.slice(c(d) + (d.prev && T(d.prev) ? F(d).length : 0), y(d) - (d.next && A3(d.next) ? B(d, E).length : 0))), I(d, E)] : o();
            }
            function f(m, E) {
              return p(m) && p(E) ? m.isTrailingSpaceSensitive ? m.hasTrailingSpaces ? v(E) ? i : r : "" : v(E) ? i : u : T(m) && (D(E) || E.firstChild || E.isSelfClosing || E.type === "element" && E.attrs.length > 0) || m.type === "element" && m.isSelfClosing && A3(E) ? "" : !E.isLeadingSpaceSensitive || v(E) || A3(E) && m.lastChild && P2(m.lastChild) && m.lastChild.lastChild && P2(m.lastChild.lastChild) ? i : E.hasLeadingSpaces ? r : u;
            }
            function x(m, E, o) {
              let d = m.getValue();
              if (h(d))
                return [t, ...m.map((_) => {
                  let b = _.getValue(), N = b.prev ? f(b.prev, b) : "";
                  return [N ? [N, g(b.prev) ? i : ""] : "", R(_, E, o)];
                }, "children")];
              let C = d.children.map(() => Symbol(""));
              return m.map((_, b) => {
                let N = _.getValue();
                if (p(N)) {
                  if (N.prev && p(N.prev)) {
                    let Y = f(N.prev, N);
                    if (Y)
                      return g(N.prev) ? [i, i, R(_, E, o)] : [Y, R(_, E, o)];
                  }
                  return R(_, E, o);
                }
                let k = [], $ = [], M = [], q = [], J = N.prev ? f(N.prev, N) : "", L = N.next ? f(N, N.next) : "";
                return J && (g(N.prev) ? k.push(i, i) : J === i ? k.push(i) : p(N.prev) ? $.push(J) : $.push(a("", u, { groupId: C[b - 1] }))), L && (g(N) ? p(N.next) && q.push(i, i) : L === i ? p(N.next) && q.push(i) : M.push(L)), [...k, s([...$, s([R(_, E, o), ...M], { id: C[b] })]), ...q];
              }, "children");
            }
            n.exports = { printChildren: x };
          } }), ng = ee({ "src/language-html/print/element.js"(e, n) {
            "use strict";
            re();
            var { builders: { breakParent: t, dedentToRoot: s, group: a, ifBreak: r, indentIfBreak: u, indent: i, line: l, softline: c }, utils: { replaceTextEndOfLine: y } } = qe(), h = fo(), { shouldPreserveContent: g, isScriptLikeTag: p, isVueCustomBlock: D, countParents: v, forceBreakContent: w } = Mt(), { printOpeningTagPrefix: T, printOpeningTag: F, printClosingTagSuffix: A3, printClosingTag: B, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: P2 } = rr(), { printChildren: R } = Do();
            function f(x, m, E) {
              let o = x.getValue();
              if (g(o, m))
                return [T(o, m), a(F(x, m, E)), ...y(h(o, m)), ...B(o, m), A3(o, m)];
              let d = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, C = Symbol("element-attr-group-id"), _ = ($) => a([a(F(x, m, E), { id: C }), $, B(o, m)]), b = ($) => d ? u($, { groupId: C }) : (p(o) || D(o, m)) && o.parent.type === "root" && m.parser === "vue" && !m.vueIndentScriptAndStyle ? $ : i($), N = () => d ? r(c, "", { groupId: C }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(c) : c, k = () => (o.next ? I(o.next) : P2(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : d ? r(c, "", { groupId: C }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m.tabWidth * v(x, (M) => M.parent && M.parent.type !== "root")}}$`).test(o.lastChild.value) ? "" : c;
              return o.children.length === 0 ? _(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : "") : _([w(o) ? t : "", b([N(), R(x, m, E)]), k()]);
            }
            n.exports = { printElement: f };
          } }), ug = ee({ "src/language-html/printer-html.js"(e, n) {
            "use strict";
            re();
            var { builders: { fill: t, group: s, hardline: a, literalline: r }, utils: { cleanDoc: u, getDocParts: i, isConcat: l, replaceTextEndOfLine: c } } = qe(), y = Wd(), { countChars: h, unescapeQuoteEntities: g, getTextValueParts: p } = Mt(), D = Yd(), { insertPragma: v } = Qd(), { locStart: w, locEnd: T } = Qn(), F = rg(), { printClosingTagSuffix: A3, printClosingTagEnd: B, printOpeningTagPrefix: I, printOpeningTagStart: P2 } = rr(), { printElement: R } = ng(), { printChildren: f } = Do();
            function x(m, E, o) {
              let d = m.getValue();
              switch (d.type) {
                case "front-matter":
                  return c(d.raw);
                case "root":
                  return E.__onHtmlRoot && E.__onHtmlRoot(d), [s(f(m, E, o)), a];
                case "element":
                case "ieConditionalComment":
                  return R(m, E, o);
                case "ieConditionalStartComment":
                case "ieConditionalEndComment":
                  return [P2(d), B(d)];
                case "interpolation":
                  return [P2(d, E), ...m.map(o, "children"), B(d, E)];
                case "text": {
                  if (d.parent.type === "interpolation") {
                    let _ = /\n[^\S\n]*$/, b = _.test(d.value), N = b ? d.value.replace(_, "") : d.value;
                    return [...c(N), b ? a : ""];
                  }
                  let C = u([I(d, E), ...p(d), A3(d, E)]);
                  return l(C) || C.type === "fill" ? t(i(C)) : C;
                }
                case "docType":
                  return [s([P2(d, E), " ", d.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), B(d, E)];
                case "comment":
                  return [I(d, E), ...c(E.originalText.slice(w(d), T(d)), r), A3(d, E)];
                case "attribute": {
                  if (d.value === null)
                    return d.rawName;
                  let C = g(d.value), _ = h(C, "'"), b = h(C, '"'), N = _ < b ? "'" : '"';
                  return [d.rawName, "=", N, ...c(N === '"' ? C.replace(/"/g, "&quot;") : C.replace(/'/g, "&apos;")), N];
                }
                default:
                  throw new Error(`Unexpected node type ${d.type}`);
              }
            }
            n.exports = { preprocess: D, print: x, insertPragma: v, massageAstNode: y, embed: F };
          } }), sg = ee({ "src/language-html/options.js"(e, n) {
            "use strict";
            re();
            var t = qt(), s = "HTML";
            n.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
          } }), ig = ee({ "src/language-html/parsers.js"() {
            re();
          } }), Tn = ee({ "node_modules/linguist-languages/data/HTML.json"(e, n) {
            n.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
          } }), ag = ee({ "node_modules/linguist-languages/data/Vue.json"(e, n) {
            n.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
          } }), og = ee({ "src/language-html/index.js"(e, n) {
            "use strict";
            re();
            var t = wt(), s = ug(), a = sg(), r = ig(), u = [t(Tn(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(Tn(), (l) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l.extensions, ".mjml"] })), t(Tn(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(ag(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s };
            n.exports = { languages: u, printers: i, options: a, parsers: r };
          } }), lg = ee({ "src/language-yaml/pragma.js"(e, n) {
            "use strict";
            re();
            function t(r) {
              return /^\s*@(?:prettier|format)\s*$/.test(r);
            }
            function s(r) {
              return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(r);
            }
            function a(r) {
              return `# @format

${r}`;
            }
            n.exports = { isPragma: t, hasPragma: s, insertPragma: a };
          } }), cg = ee({ "src/language-yaml/loc.js"(e, n) {
            "use strict";
            re();
            function t(a) {
              return a.position.start.offset;
            }
            function s(a) {
              return a.position.end.offset;
            }
            n.exports = { locStart: t, locEnd: s };
          } }), pg = ee({ "src/language-yaml/embed.js"(e, n) {
            "use strict";
            re();
            function t(s, a, r, u) {
              if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath))
                return r(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
            }
            n.exports = t;
          } }), Rt = ee({ "src/language-yaml/utils.js"(e, n) {
            "use strict";
            re();
            var { getLast: t, isNonEmptyArray: s } = Ge();
            function a(f, x) {
              let m = 0, E = f.stack.length - 1;
              for (let o = 0; o < E; o++) {
                let d = f.stack[o];
                r(d) && x(d) && m++;
              }
              return m;
            }
            function r(f, x) {
              return f && typeof f.type == "string" && (!x || x.includes(f.type));
            }
            function u(f, x, m) {
              return x("children" in f ? Object.assign(Object.assign({}, f), {}, { children: f.children.map((E) => u(E, x, f)) }) : f, m);
            }
            function i(f, x, m) {
              Object.defineProperty(f, x, { get: m, enumerable: false });
            }
            function l(f, x) {
              let m = 0, E = x.length;
              for (let o = f.position.end.offset - 1; o < E; o++) {
                let d = x[o];
                if (d === `
` && m++, m === 1 && /\S/.test(d))
                  return false;
                if (m === 2)
                  return true;
              }
              return false;
            }
            function c(f) {
              switch (f.getValue().type) {
                case "tag":
                case "anchor":
                case "comment":
                  return false;
              }
              let m = f.stack.length;
              for (let E = 1; E < m; E++) {
                let o = f.stack[E], d = f.stack[E - 1];
                if (Array.isArray(d) && typeof o == "number" && o !== d.length - 1)
                  return false;
              }
              return true;
            }
            function y(f) {
              return s(f.children) ? y(t(f.children)) : f;
            }
            function h(f) {
              return f.value.trim() === "prettier-ignore";
            }
            function g(f) {
              let x = f.getValue();
              if (x.type === "documentBody") {
                let m = f.getParentNode();
                return A3(m.head) && h(t(m.head.endComments));
              }
              return v(x) && h(t(x.leadingComments));
            }
            function p(f) {
              return !s(f.children) && !D(f);
            }
            function D(f) {
              return v(f) || w(f) || T(f) || F(f) || A3(f);
            }
            function v(f) {
              return s(f == null ? void 0 : f.leadingComments);
            }
            function w(f) {
              return s(f == null ? void 0 : f.middleComments);
            }
            function T(f) {
              return f == null ? void 0 : f.indicatorComment;
            }
            function F(f) {
              return f == null ? void 0 : f.trailingComment;
            }
            function A3(f) {
              return s(f == null ? void 0 : f.endComments);
            }
            function B(f) {
              let x = [], m;
              for (let E of f.split(/( +)/))
                E !== " " ? m === " " ? x.push(E) : x.push((x.pop() || "") + E) : m === void 0 && x.unshift(""), m = E;
              return m === " " && x.push((x.pop() || "") + " "), x[0] === "" && (x.shift(), x.unshift(" " + (x.shift() || ""))), x;
            }
            function I(f, x, m) {
              let E = x.split(`
`).map((o, d, C) => d === 0 && d === C.length - 1 ? o : d !== 0 && d !== C.length - 1 ? o.trim() : d === 0 ? o.trimEnd() : o.trimStart());
              return m.proseWrap === "preserve" ? E.map((o) => o.length === 0 ? [] : [o]) : E.map((o) => o.length === 0 ? [] : B(o)).reduce((o, d, C) => C !== 0 && E[C - 1].length > 0 && d.length > 0 && !(f === "quoteDouble" && t(t(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t(o), ...d]] : [...o, d], []).map((o) => m.proseWrap === "never" ? [o.join(" ")] : o);
            }
            function P2(f, x) {
              let { parentIndent: m, isLastDescendant: E, options: o } = x, d = f.position.start.line === f.position.end.line ? "" : o.originalText.slice(f.position.start.offset, f.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], C;
              if (f.indent === null) {
                let N = d.match(/^(?<leadingSpace> *)[^\n\r ]/m);
                C = N ? N.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
              } else
                C = f.indent - 1 + m;
              let _ = d.split(`
`).map((N) => N.slice(C));
              if (o.proseWrap === "preserve" || f.type === "blockLiteral")
                return b(_.map((N) => N.length === 0 ? [] : [N]));
              return b(_.map((N) => N.length === 0 ? [] : B(N)).reduce((N, k, $) => $ !== 0 && _[$ - 1].length > 0 && k.length > 0 && !/^\s/.test(k[0]) && !/^\s|\s$/.test(t(N)) ? [...N.slice(0, -1), [...t(N), ...k]] : [...N, k], []).map((N) => N.reduce((k, $) => k.length > 0 && /\s$/.test(t(k)) ? [...k.slice(0, -1), t(k) + " " + $] : [...k, $], [])).map((N) => o.proseWrap === "never" ? [N.join(" ")] : N));
              function b(N) {
                if (f.chomping === "keep")
                  return t(N).length === 0 ? N.slice(0, -1) : N;
                let k = 0;
                for (let $ = N.length - 1; $ >= 0 && N[$].length === 0; $--)
                  k++;
                return k === 0 ? N : k >= 2 && !E ? N.slice(0, -(k - 1)) : N.slice(0, -k);
              }
            }
            function R(f) {
              if (!f)
                return true;
              switch (f.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                case "alias":
                case "flowMapping":
                case "flowSequence":
                  return true;
                default:
                  return false;
              }
            }
            n.exports = { getLast: t, getAncestorCount: a, isNode: r, isEmptyNode: p, isInlineNode: R, mapNode: u, defineShortcut: i, isNextLineEmpty: l, isLastDescendantNode: c, getBlockValueLineContents: P2, getFlowScalarLineContents: I, getLastDescendantNode: y, hasPrettierIgnore: g, hasLeadingComments: v, hasMiddleComments: w, hasIndicatorComment: T, hasTrailingComment: F, hasEndComments: A3 };
          } }), fg = ee({ "src/language-yaml/print-preprocess.js"(e, n) {
            "use strict";
            re();
            var { defineShortcut: t, mapNode: s } = Rt();
            function a(u) {
              return s(u, r);
            }
            function r(u) {
              switch (u.type) {
                case "document":
                  t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
                  break;
                case "documentBody":
                case "sequenceItem":
                case "flowSequenceItem":
                case "mappingKey":
                case "mappingValue":
                  t(u, "content", () => u.children[0]);
                  break;
                case "mappingItem":
                case "flowMappingItem":
                  t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
                  break;
              }
              return u;
            }
            n.exports = a;
          } }), qr = ee({ "src/language-yaml/print/misc.js"(e, n) {
            "use strict";
            re();
            var { builders: { softline: t, align: s } } = qe(), { hasEndComments: a, isNextLineEmpty: r, isNode: u } = Rt(), i = /* @__PURE__ */ new WeakMap();
            function l(h, g) {
              let p = h.getValue(), D = h.stack[0], v;
              return i.has(D) ? v = i.get(D) : (v = /* @__PURE__ */ new Set(), i.set(D, v)), !v.has(p.position.end.line) && (v.add(p.position.end.line), r(p, g) && !c(h.getParentNode())) ? t : "";
            }
            function c(h) {
              return a(h) && !u(h, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
            }
            function y(h, g) {
              return s(" ".repeat(h), g);
            }
            n.exports = { alignWithSpaces: y, shouldPrintEndComments: c, printNextEmptyLine: l };
          } }), Dg = ee({ "src/language-yaml/print/flow-mapping-sequence.js"(e, n) {
            "use strict";
            re();
            var { builders: { ifBreak: t, line: s, softline: a, hardline: r, join: u } } = qe(), { isEmptyNode: i, getLast: l, hasEndComments: c } = Rt(), { printNextEmptyLine: y, alignWithSpaces: h } = qr();
            function g(D, v, w) {
              let T = D.getValue(), F = T.type === "flowMapping", A3 = F ? "{" : "[", B = F ? "}" : "]", I = a;
              F && T.children.length > 0 && w.bracketSpacing && (I = s);
              let P2 = l(T.children), R = P2 && P2.type === "flowMappingItem" && i(P2.key) && i(P2.value);
              return [A3, h(w.tabWidth, [I, p(D, v, w), w.trailingComma === "none" ? "" : t(","), c(T) ? [r, u(r, D.map(v, "endComments"))] : ""]), R ? "" : I, B];
            }
            function p(D, v, w) {
              let T = D.getValue();
              return D.map((A3, B) => [v(), B === T.children.length - 1 ? "" : [",", s, T.children[B].position.start.line !== T.children[B + 1].position.start.line ? y(A3, w.originalText) : ""]], "children");
            }
            n.exports = { printFlowMapping: g, printFlowSequence: g };
          } }), mg = ee({ "src/language-yaml/print/mapping-item.js"(e, n) {
            "use strict";
            re();
            var { builders: { conditionalGroup: t, group: s, hardline: a, ifBreak: r, join: u, line: i } } = qe(), { hasLeadingComments: l, hasMiddleComments: c, hasTrailingComment: y, hasEndComments: h, isNode: g, isEmptyNode: p, isInlineNode: D } = Rt(), { alignWithSpaces: v } = qr();
            function w(B, I, P2, R, f) {
              let { key: x, value: m } = B, E = p(x), o = p(m);
              if (E && o)
                return ": ";
              let d = R("key"), C = F(B) ? " " : "";
              if (o)
                return B.type === "flowMappingItem" && I.type === "flowMapping" ? d : B.type === "mappingItem" && T(x.content, f) && !y(x.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [d, C, ":"] : ["? ", v(2, d)];
              let _ = R("value");
              if (E)
                return [": ", v(2, _)];
              if (l(m) || !D(x.content))
                return ["? ", v(2, d), a, u("", P2.map(R, "value", "leadingComments").map((q) => [q, a])), ": ", v(2, _)];
              if (A3(x.content) && !l(x.content) && !c(x.content) && !y(x.content) && !h(x) && !l(m.content) && !c(m.content) && !h(m) && T(m.content, f))
                return [d, C, ": ", _];
              let b = Symbol("mappingKey"), N = s([r("? "), s(v(2, d), { id: b })]), k = [a, ": ", v(2, _)], $ = [C, ":"];
              l(m.content) || h(m) && m.content && !g(m.content, ["mapping", "sequence"]) || I.type === "mapping" && y(x.content) && D(m.content) || g(m.content, ["mapping", "sequence"]) && m.content.tag === null && m.content.anchor === null ? $.push(a) : m.content && $.push(i), $.push(_);
              let M = v(f.tabWidth, $);
              return T(x.content, f) && !l(x.content) && !c(x.content) && !h(x) ? t([[d, M]]) : t([[N, r(k, M, { groupId: b })]]);
            }
            function T(B, I) {
              if (!B)
                return true;
              switch (B.type) {
                case "plain":
                case "quoteSingle":
                case "quoteDouble":
                  break;
                case "alias":
                  return true;
                default:
                  return false;
              }
              if (I.proseWrap === "preserve")
                return B.position.start.line === B.position.end.line;
              if (/\\$/m.test(I.originalText.slice(B.position.start.offset, B.position.end.offset)))
                return false;
              switch (I.proseWrap) {
                case "never":
                  return !B.value.includes(`
`);
                case "always":
                  return !/[\n ]/.test(B.value);
                default:
                  return false;
              }
            }
            function F(B) {
              return B.key.content && B.key.content.type === "alias";
            }
            function A3(B) {
              if (!B)
                return true;
              switch (B.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                  return B.position.start.line === B.position.end.line;
                case "alias":
                  return true;
                default:
                  return false;
              }
            }
            n.exports = w;
          } }), dg = ee({ "src/language-yaml/print/block.js"(e, n) {
            "use strict";
            re();
            var { builders: { dedent: t, dedentToRoot: s, fill: a, hardline: r, join: u, line: i, literalline: l, markAsRoot: c }, utils: { getDocParts: y } } = qe(), { getAncestorCount: h, getBlockValueLineContents: g, hasIndicatorComment: p, isLastDescendantNode: D, isNode: v } = Rt(), { alignWithSpaces: w } = qr();
            function T(F, A3, B) {
              let I = F.getValue(), P2 = h(F, (E) => v(E, ["sequence", "mapping"])), R = D(F), f = [I.type === "blockFolded" ? ">" : "|"];
              I.indent !== null && f.push(I.indent.toString()), I.chomping !== "clip" && f.push(I.chomping === "keep" ? "+" : "-"), p(I) && f.push(" ", A3("indicatorComment"));
              let x = g(I, { parentIndent: P2, isLastDescendant: R, options: B }), m = [];
              for (let [E, o] of x.entries())
                E === 0 && m.push(r), m.push(a(y(u(i, o)))), E !== x.length - 1 ? m.push(o.length === 0 ? r : c(l)) : I.chomping === "keep" && R && m.push(s(o.length === 0 ? r : l));
              return I.indent === null ? f.push(t(w(B.tabWidth, m))) : f.push(s(w(I.indent - 1 + P2, m))), f;
            }
            n.exports = T;
          } }), gg = ee({ "src/language-yaml/printer-yaml.js"(e, n) {
            "use strict";
            re();
            var { builders: { breakParent: t, fill: s, group: a, hardline: r, join: u, line: i, lineSuffix: l, literalline: c }, utils: { getDocParts: y, replaceTextEndOfLine: h } } = qe(), { isPreviousLineEmpty: g } = Ge(), { insertPragma: p, isPragma: D } = lg(), { locStart: v } = cg(), w = pg(), { getFlowScalarLineContents: T, getLastDescendantNode: F, hasLeadingComments: A3, hasMiddleComments: B, hasTrailingComment: I, hasEndComments: P2, hasPrettierIgnore: R, isLastDescendantNode: f, isNode: x, isInlineNode: m } = Rt(), E = fg(), { alignWithSpaces: o, printNextEmptyLine: d, shouldPrintEndComments: C } = qr(), { printFlowMapping: _, printFlowSequence: b } = Dg(), N = mg(), k = dg();
            function $(O, K, se) {
              let Q = O.getValue(), le = [];
              Q.type !== "mappingValue" && A3(Q) && le.push([u(r, O.map(se, "leadingComments")), r]);
              let { tag: W, anchor: X } = Q;
              W && le.push(se("tag")), W && X && le.push(" "), X && le.push(se("anchor"));
              let oe = "";
              x(Q, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !f(O) && (oe = d(O, K.originalText)), (W || X) && (x(Q, ["sequence", "mapping"]) && !B(Q) ? le.push(r) : le.push(" ")), B(Q) && le.push([Q.middleComments.length === 1 ? "" : r, u(r, O.map(se, "middleComments")), r]);
              let ae = O.getParentNode();
              return R(O) ? le.push(h(K.originalText.slice(Q.position.start.offset, Q.position.end.offset).trimEnd(), c)) : le.push(a(M(Q, ae, O, K, se))), I(Q) && !x(Q, ["document", "documentHead"]) && le.push(l([Q.type === "mappingValue" && !Q.content ? "" : " ", ae.type === "mappingKey" && O.getParentNode(2).type === "mapping" && m(Q) ? "" : t, se("trailingComment")])), C(Q) && le.push(o(Q.type === "sequenceItem" ? 2 : 0, [r, u(r, O.map((Ae) => [g(K.originalText, Ae.getValue(), v) ? r : "", se()], "endComments"))])), le.push(oe), le;
            }
            function M(O, K, se, Q, le) {
              switch (O.type) {
                case "root": {
                  let { children: W } = O, X = [];
                  se.each((ae, Ae) => {
                    let z = W[Ae], H = W[Ae + 1];
                    Ae !== 0 && X.push(r), X.push(le()), J(z, H) ? (X.push(r, "..."), I(z) && X.push(" ", le("trailingComment"))) : H && !I(H.head) && X.push(r, "---");
                  }, "children");
                  let oe = F(O);
                  return (!x(oe, ["blockLiteral", "blockFolded"]) || oe.chomping !== "keep") && X.push(r), X;
                }
                case "document": {
                  let W = K.children[se.getName() + 1], X = [];
                  return L(O, W, K, Q) === "head" && ((O.head.children.length > 0 || O.head.endComments.length > 0) && X.push(le("head")), I(O.head) ? X.push(["---", " ", le(["head", "trailingComment"])]) : X.push("---")), q(O) && X.push(le("body")), u(r, X);
                }
                case "documentHead":
                  return u(r, [...se.map(le, "children"), ...se.map(le, "endComments")]);
                case "documentBody": {
                  let { children: W, endComments: X } = O, oe = "";
                  if (W.length > 0 && X.length > 0) {
                    let ae = F(O);
                    x(ae, ["blockFolded", "blockLiteral"]) ? ae.chomping !== "keep" && (oe = [r, r]) : oe = r;
                  }
                  return [u(r, se.map(le, "children")), oe, u(r, se.map(le, "endComments"))];
                }
                case "directive":
                  return ["%", u(" ", [O.name, ...O.parameters])];
                case "comment":
                  return ["#", O.value];
                case "alias":
                  return ["*", O.value];
                case "tag":
                  return Q.originalText.slice(O.position.start.offset, O.position.end.offset);
                case "anchor":
                  return ["&", O.value];
                case "plain":
                  return Y(O.type, Q.originalText.slice(O.position.start.offset, O.position.end.offset), Q);
                case "quoteDouble":
                case "quoteSingle": {
                  let W = "'", X = '"', oe = Q.originalText.slice(O.position.start.offset + 1, O.position.end.offset - 1);
                  if (O.type === "quoteSingle" && oe.includes("\\") || O.type === "quoteDouble" && /\\[^"]/.test(oe)) {
                    let Ae = O.type === "quoteDouble" ? X : W;
                    return [Ae, Y(O.type, oe, Q), Ae];
                  }
                  if (oe.includes(X))
                    return [W, Y(O.type, O.type === "quoteDouble" ? oe.replace(/\\"/g, X).replace(/'/g, W.repeat(2)) : oe, Q), W];
                  if (oe.includes(W))
                    return [X, Y(O.type, O.type === "quoteSingle" ? oe.replace(/''/g, W) : oe, Q), X];
                  let ae = Q.singleQuote ? W : X;
                  return [ae, Y(O.type, oe, Q), ae];
                }
                case "blockFolded":
                case "blockLiteral":
                  return k(se, le, Q);
                case "mapping":
                case "sequence":
                  return u(r, se.map(le, "children"));
                case "sequenceItem":
                  return ["- ", o(2, O.content ? le("content") : "")];
                case "mappingKey":
                case "mappingValue":
                  return O.content ? le("content") : "";
                case "mappingItem":
                case "flowMappingItem":
                  return N(O, K, se, le, Q);
                case "flowMapping":
                  return _(se, le, Q);
                case "flowSequence":
                  return b(se, le, Q);
                case "flowSequenceItem":
                  return le("content");
                default:
                  throw new Error(`Unexpected node type ${O.type}`);
              }
            }
            function q(O) {
              return O.body.children.length > 0 || P2(O.body);
            }
            function J(O, K) {
              return I(O) || K && (K.head.children.length > 0 || P2(K.head));
            }
            function L(O, K, se, Q) {
              return se.children[0] === O && /---(?:\s|$)/.test(Q.originalText.slice(v(O), v(O) + 4)) || O.head.children.length > 0 || P2(O.head) || I(O.head) ? "head" : J(O, K) ? false : K ? "root" : false;
            }
            function Y(O, K, se) {
              let Q = T(O, K, se);
              return u(r, Q.map((le) => s(y(u(i, le)))));
            }
            function V(O, K) {
              if (x(K))
                switch (delete K.position, K.type) {
                  case "comment":
                    if (D(K.value))
                      return null;
                    break;
                  case "quoteDouble":
                  case "quoteSingle":
                    K.type = "quote";
                    break;
                }
            }
            n.exports = { preprocess: E, embed: w, print: $, massageAstNode: V, insertPragma: p };
          } }), yg = ee({ "src/language-yaml/options.js"(e, n) {
            "use strict";
            re();
            var t = qt();
            n.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
          } }), hg = ee({ "src/language-yaml/parsers.js"() {
            re();
          } }), vg = ee({ "node_modules/linguist-languages/data/YAML.json"(e, n) {
            n.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
          } }), Cg = ee({ "src/language-yaml/index.js"(e, n) {
            "use strict";
            re();
            var t = wt(), s = gg(), a = yg(), r = hg(), u = [t(vg(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((l) => l !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
            n.exports = { languages: u, printers: { yaml: s }, options: a, parsers: r };
          } }), Eg = ee({ "src/languages.js"(e, n) {
            "use strict";
            re(), n.exports = [td(), vd(), Td(), kd(), Vd(), og(), Cg()];
          } });
          re();
          var { version: Fg } = fa(), kt = vm(), { getSupportInfo: Ag } = Rn(), Sg = Cm(), xg = Eg(), bg = qe();
          function Bt(e) {
            let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return function() {
              for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++)
                s[a] = arguments[a];
              let r = s[n] || {}, u = r.plugins || [];
              return s[n] = Object.assign(Object.assign({}, r), {}, { plugins: [...xg, ...Array.isArray(u) ? u : Object.values(u)] }), e(...s);
            };
          }
          var Bn = Bt(kt.formatWithCursor);
          mo.exports = { formatWithCursor: Bn, format(e, n) {
            return Bn(e, n).formatted;
          }, check(e, n) {
            let { formatted: t } = Bn(e, n);
            return t === e;
          }, doc: bg, getSupportInfo: Bt(Ag, 0), version: Fg, util: Sg, __debug: { parse: Bt(kt.parse), formatAST: Bt(kt.formatAST), formatDoc: Bt(kt.formatDoc), printToDoc: Bt(kt.printToDoc), printDocToString: Bt(kt.printDocToString) } };
        });
        return Tg();
      });
    } });
    import_parser_html = __toESM2(require_parser_html());
    import_standalone = __toESM2(require_standalone());
    formatter = (0, import_memoizerific2.default)(2)((type, source) => type === false ? source : type === "dedent" || type === true ? dedent(source) : import_standalone.default.format(source, { parser: type, plugins: [import_parser_html.default], htmlWhitespaceSensitivity: "ignore" }).trim());
  }
});

// ../../node_modules/@storybook/components/dist/WithTooltip-52JYBAXX.mjs
var WithTooltip_52JYBAXX_exports = {};
__export(WithTooltip_52JYBAXX_exports, {
  WithToolTipState: () => WithToolTipState,
  WithTooltip: () => WithToolTipState,
  WithTooltipPure: () => WithTooltipPure
});
function Manager(_ref) {
  var children = _ref.children, _React$useState = React7.useState(null), referenceNode = _React$useState[0], setReferenceNode = _React$useState[1], hasUnmounted = React7.useRef(false);
  React7.useEffect(function() {
    return function() {
      hasUnmounted.current = true;
    };
  }, []);
  var handleSetReferenceNode = React7.useCallback(function(node) {
    hasUnmounted.current || setReferenceNode(node);
  }, []);
  return React7.createElement(ManagerReferenceNodeContext.Provider, { value: referenceNode }, React7.createElement(ManagerReferenceNodeSetterContext.Provider, { value: handleSetReferenceNode }, children));
}
function Popper(_ref) {
  var _ref$placement = _ref.placement, placement = _ref$placement === void 0 ? "bottom" : _ref$placement, _ref$strategy = _ref.strategy, strategy = _ref$strategy === void 0 ? "absolute" : _ref$strategy, _ref$modifiers = _ref.modifiers, modifiers = _ref$modifiers === void 0 ? EMPTY_MODIFIERS2 : _ref$modifiers, referenceElement = _ref.referenceElement, onFirstUpdate = _ref.onFirstUpdate, innerRef = _ref.innerRef, children = _ref.children, referenceNode = React42.useContext(ManagerReferenceNodeContext), _React$useState = React42.useState(null), popperElement = _React$useState[0], setPopperElement = _React$useState[1], _React$useState2 = React42.useState(null), arrowElement = _React$useState2[0], setArrowElement = _React$useState2[1];
  React42.useEffect(function() {
    setRef(innerRef, popperElement);
  }, [innerRef, popperElement]);
  var options = React42.useMemo(function() {
    return { placement, strategy, onFirstUpdate, modifiers: [].concat(modifiers, [{ name: "arrow", enabled: arrowElement != null, options: { element: arrowElement } }]) };
  }, [placement, strategy, onFirstUpdate, modifiers, arrowElement]), _usePopper = usePopper(referenceElement || referenceNode, popperElement, options), state = _usePopper.state, styles2 = _usePopper.styles, forceUpdate = _usePopper.forceUpdate, update = _usePopper.update, childrenProps = React42.useMemo(function() {
    return { ref: setPopperElement, style: styles2.popper, placement: state ? state.placement : placement, hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null, isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null, arrowProps: { style: styles2.arrow, ref: setArrowElement }, forceUpdate: forceUpdate || NOOP, update: update || NOOP_PROMISE };
  }, [setPopperElement, setArrowElement, placement, state, styles2, update, forceUpdate]);
  return unwrapArray(children)(childrenProps);
}
function Reference(_ref) {
  var children = _ref.children, innerRef = _ref.innerRef, setReferenceNode = React52.useContext(ManagerReferenceNodeSetterContext), refHandler = React52.useCallback(function(node) {
    setRef(innerRef, node), safeInvoke(setReferenceNode, node);
  }, [innerRef, setReferenceNode]);
  return React52.useEffect(function() {
    return function() {
      return setRef(innerRef, null);
    };
  }, []), React52.useEffect(function() {
    (0, import_warning.default)(Boolean(setReferenceNode), "`Reference` should not be used outside of a `Manager` component.");
  }, [setReferenceNode]), unwrapArray(children)({ ref: refHandler });
}
var import_react8, import_theming6, import_react9, import_react_dom, React42, React7, React23, React33, ReactDOM, React52, import_react10, import_memoizerific3, import_theming7, require_react_fast_compare, require_warning, import_global3, ManagerReferenceNodeContext, ManagerReferenceNodeSetterContext, unwrapArray, safeInvoke, setRef, fromEntries, useIsomorphicLayoutEffect, import_react_fast_compare, EMPTY_MODIFIERS, usePopper, NOOP, NOOP_PROMISE, EMPTY_MODIFIERS2, import_warning, TooltipContext, callAll, noop, canUseDOM, setRef3, Tooltip, DEFAULT_MUTATION_OBSERVER_CONFIG, TooltipTrigger, react_popper_tooltip_default, match, ArrowSpacing, Arrow, Wrapper2, Tooltip2, document22, TargetContainer, TargetSvgContainer, WithTooltipPure, WithToolTipState;
var init_WithTooltip_52JYBAXX = __esm({
  "../../node_modules/@storybook/components/dist/WithTooltip-52JYBAXX.mjs"() {
    init_chunk_4V2BRVWI();
    init_chunk_4REFJGR7();
    init_chunk_NNAAFZ4U();
    import_react8 = __toESM(require("react"), 1);
    import_theming6 = require("@storybook/theming");
    import_react9 = __toESM(require("react"), 1);
    import_react_dom = require("react-dom");
    React42 = __toESM(require("react"), 1);
    React7 = __toESM(require("react"), 1);
    React23 = __toESM(require("react"), 1);
    React33 = __toESM(require("react"), 1);
    ReactDOM = __toESM(require("react-dom"), 1);
    React52 = __toESM(require("react"), 1);
    import_react10 = __toESM(require("react"), 1);
    import_memoizerific3 = __toESM(require_memoizerific(), 1);
    import_theming7 = require("@storybook/theming");
    require_react_fast_compare = __commonJS2({ "../../node_modules/react-fast-compare/index.js"(exports, module2) {
      var hasElementType = typeof Element < "u", hasMap = typeof Map == "function", hasSet = typeof Set == "function", hasArrayBuffer = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
      function equal(a, b) {
        if (a === b)
          return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor)
            return false;
          var length2, i, keys;
          if (Array.isArray(a)) {
            if (length2 = a.length, length2 != b.length)
              return false;
            for (i = length2; i-- !== 0; )
              if (!equal(a[i], b[i]))
                return false;
            return true;
          }
          var it;
          if (hasMap && a instanceof Map && b instanceof Map) {
            if (a.size !== b.size)
              return false;
            for (it = a.entries(); !(i = it.next()).done; )
              if (!b.has(i.value[0]))
                return false;
            for (it = a.entries(); !(i = it.next()).done; )
              if (!equal(i.value[1], b.get(i.value[0])))
                return false;
            return true;
          }
          if (hasSet && a instanceof Set && b instanceof Set) {
            if (a.size !== b.size)
              return false;
            for (it = a.entries(); !(i = it.next()).done; )
              if (!b.has(i.value[0]))
                return false;
            return true;
          }
          if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
            if (length2 = a.length, length2 != b.length)
              return false;
            for (i = length2; i-- !== 0; )
              if (a[i] !== b[i])
                return false;
            return true;
          }
          if (a.constructor === RegExp)
            return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf)
            return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString)
            return a.toString() === b.toString();
          if (keys = Object.keys(a), length2 = keys.length, length2 !== Object.keys(b).length)
            return false;
          for (i = length2; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
              return false;
          if (hasElementType && a instanceof Element)
            return false;
          for (i = length2; i-- !== 0; )
            if (!((keys[i] === "_owner" || keys[i] === "__v" || keys[i] === "__o") && a.$$typeof) && !equal(a[keys[i]], b[keys[i]]))
              return false;
          return true;
        }
        return a !== a && b !== b;
      }
      module2.exports = function(a, b) {
        try {
          return equal(a, b);
        } catch (error) {
          if ((error.message || "").match(/stack|recursion/i))
            return console.warn("react-fast-compare cannot handle circular refs"), false;
          throw error;
        }
      };
    } });
    require_warning = __commonJS2({ "../../node_modules/warning/warning.js"(exports, module2) {
      "use strict";
      var __DEV__ = true, warning2 = function() {
      };
      __DEV__ && (printWarning = function(format3, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++)
          args[key - 1] = arguments[key];
        var argIndex = 0, message = "Warning: " + format3.replace(/%s/g, function() {
          return args[argIndex++];
        });
        typeof console < "u" && console.error(message);
        try {
          throw new Error(message);
        } catch {
        }
      }, warning2 = function(condition, format3, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++)
          args[key - 2] = arguments[key];
        if (format3 === void 0)
          throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
        condition || printWarning.apply(null, [format3].concat(args));
      });
      var printWarning;
      module2.exports = warning2;
    } });
    import_global3 = __toESM2(require_window());
    ManagerReferenceNodeContext = React7.createContext();
    ManagerReferenceNodeSetterContext = React7.createContext();
    unwrapArray = function(arg) {
      return Array.isArray(arg) ? arg[0] : arg;
    };
    safeInvoke = function(fn) {
      if (typeof fn == "function") {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
          args[_key - 1] = arguments[_key];
        return fn.apply(void 0, args);
      }
    };
    setRef = function(ref, node) {
      if (typeof ref == "function")
        return safeInvoke(ref, node);
      ref != null && (ref.current = node);
    };
    fromEntries = function(entries) {
      return entries.reduce(function(acc, _ref) {
        var key = _ref[0], value = _ref[1];
        return acc[key] = value, acc;
      }, {});
    };
    useIsomorphicLayoutEffect = typeof window < "u" && window.document && window.document.createElement ? React23.useLayoutEffect : React23.useEffect;
    import_react_fast_compare = __toESM2(require_react_fast_compare());
    EMPTY_MODIFIERS = [];
    usePopper = function(referenceElement, popperElement, options) {
      options === void 0 && (options = {});
      var prevOptions = React33.useRef(null), optionsWithDefaults = { onFirstUpdate: options.onFirstUpdate, placement: options.placement || "bottom", strategy: options.strategy || "absolute", modifiers: options.modifiers || EMPTY_MODIFIERS }, _React$useState = React33.useState({ styles: { popper: { position: optionsWithDefaults.strategy, left: "0", top: "0" }, arrow: { position: "absolute" } }, attributes: {} }), state = _React$useState[0], setState = _React$useState[1], updateStateModifier = React33.useMemo(function() {
        return { name: "updateState", enabled: true, phase: "write", fn: function(_ref) {
          var state2 = _ref.state, elements = Object.keys(state2.elements);
          ReactDOM.flushSync(function() {
            setState({ styles: fromEntries(elements.map(function(element) {
              return [element, state2.styles[element] || {}];
            })), attributes: fromEntries(elements.map(function(element) {
              return [element, state2.attributes[element]];
            })) });
          });
        }, requires: ["computeStyles"] };
      }, []), popperOptions = React33.useMemo(function() {
        var newOptions = { onFirstUpdate: optionsWithDefaults.onFirstUpdate, placement: optionsWithDefaults.placement, strategy: optionsWithDefaults.strategy, modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, { name: "applyStyles", enabled: false }]) };
        return (0, import_react_fast_compare.default)(prevOptions.current, newOptions) ? prevOptions.current || newOptions : (prevOptions.current = newOptions, newOptions);
      }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]), popperInstanceRef = React33.useRef();
      return useIsomorphicLayoutEffect(function() {
        popperInstanceRef.current && popperInstanceRef.current.setOptions(popperOptions);
      }, [popperOptions]), useIsomorphicLayoutEffect(function() {
        if (!(referenceElement == null || popperElement == null)) {
          var createPopper2 = options.createPopper || createPopper, popperInstance = createPopper2(referenceElement, popperElement, popperOptions);
          return popperInstanceRef.current = popperInstance, function() {
            popperInstance.destroy(), popperInstanceRef.current = null;
          };
        }
      }, [referenceElement, popperElement, options.createPopper]), { state: popperInstanceRef.current ? popperInstanceRef.current.state : null, styles: state.styles, attributes: state.attributes, update: popperInstanceRef.current ? popperInstanceRef.current.update : null, forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null };
    };
    NOOP = function() {
    };
    NOOP_PROMISE = function() {
      return Promise.resolve(null);
    };
    EMPTY_MODIFIERS2 = [];
    import_warning = __toESM2(require_warning());
    TooltipContext = import_react9.default.createContext({});
    callAll = function() {
      for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++)
        fns[_key] = arguments[_key];
      return function() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
          args[_key2] = arguments[_key2];
        return fns.forEach(function(fn) {
          return fn && fn.apply(void 0, args);
        });
      };
    };
    noop = function() {
    };
    canUseDOM = function() {
      return !!(typeof window < "u" && window.document && window.document.createElement);
    };
    setRef3 = function(ref, node) {
      if (typeof ref == "function")
        return ref(node);
      ref != null && (ref.current = node);
    };
    Tooltip = function(_Component) {
      _inheritsLoose(Tooltip3, _Component);
      function Tooltip3() {
        for (var _this, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _Component.call.apply(_Component, [this].concat(args)) || this, _this.observer = void 0, _this.tooltipRef = void 0, _this.handleOutsideClick = function(event) {
          if (_this.tooltipRef && !_this.tooltipRef.contains(event.target)) {
            var parentOutsideClickHandler = _this.context.parentOutsideClickHandler, _this$props = _this.props, hideTooltip = _this$props.hideTooltip, clearScheduled = _this$props.clearScheduled;
            clearScheduled(), hideTooltip(), parentOutsideClickHandler && parentOutsideClickHandler(event);
          }
        }, _this.handleOutsideRightClick = function(event) {
          if (_this.tooltipRef && !_this.tooltipRef.contains(event.target)) {
            var parentOutsideRightClickHandler = _this.context.parentOutsideRightClickHandler, _this$props2 = _this.props, hideTooltip = _this$props2.hideTooltip, clearScheduled = _this$props2.clearScheduled;
            clearScheduled(), hideTooltip(), parentOutsideRightClickHandler && parentOutsideRightClickHandler(event);
          }
        }, _this.addOutsideClickHandler = function() {
          document.body.addEventListener("touchend", _this.handleOutsideClick), document.body.addEventListener("click", _this.handleOutsideClick);
        }, _this.removeOutsideClickHandler = function() {
          document.body.removeEventListener("touchend", _this.handleOutsideClick), document.body.removeEventListener("click", _this.handleOutsideClick);
        }, _this.addOutsideRightClickHandler = function() {
          return document.body.addEventListener("contextmenu", _this.handleOutsideRightClick);
        }, _this.removeOutsideRightClickHandler = function() {
          return document.body.removeEventListener("contextmenu", _this.handleOutsideRightClick);
        }, _this.getTooltipRef = function(node) {
          _this.tooltipRef = node, setRef3(_this.props.innerRef, node);
        }, _this.getArrowProps = function(props) {
          return props === void 0 && (props = {}), _extends({}, props, { style: _extends({}, props.style, _this.props.arrowProps.style) });
        }, _this.getTooltipProps = function(props) {
          return props === void 0 && (props = {}), _extends({}, props, _this.isTriggeredBy("hover") && { onMouseEnter: callAll(_this.props.clearScheduled, props.onMouseEnter), onMouseLeave: callAll(_this.props.hideTooltip, props.onMouseLeave) }, { style: _extends({}, props.style, _this.props.style) });
        }, _this.contextValue = { isParentNoneTriggered: _this.props.trigger === "none", addParentOutsideClickHandler: _this.addOutsideClickHandler, addParentOutsideRightClickHandler: _this.addOutsideRightClickHandler, parentOutsideClickHandler: _this.handleOutsideClick, parentOutsideRightClickHandler: _this.handleOutsideRightClick, removeParentOutsideClickHandler: _this.removeOutsideClickHandler, removeParentOutsideRightClickHandler: _this.removeOutsideRightClickHandler }, _this;
      }
      var _proto = Tooltip3.prototype;
      return _proto.componentDidMount = function() {
        var _this2 = this, observer = this.observer = new MutationObserver(function() {
          _this2.props.update();
        });
        if (observer.observe(this.tooltipRef, this.props.mutationObserverOptions), this.isTriggeredBy("hover") || this.isTriggeredBy("click") || this.isTriggeredBy("right-click")) {
          var _this$context = this.context, removeParentOutsideClickHandler = _this$context.removeParentOutsideClickHandler, removeParentOutsideRightClickHandler = _this$context.removeParentOutsideRightClickHandler;
          this.addOutsideClickHandler(), this.addOutsideRightClickHandler(), removeParentOutsideClickHandler && removeParentOutsideClickHandler(), removeParentOutsideRightClickHandler && removeParentOutsideRightClickHandler();
        }
      }, _proto.componentDidUpdate = function() {
        this.props.closeOnReferenceHidden && this.props.isReferenceHidden && this.props.hideTooltip();
      }, _proto.componentWillUnmount = function() {
        if (this.observer && this.observer.disconnect(), this.isTriggeredBy("hover") || this.isTriggeredBy("click") || this.isTriggeredBy("right-click")) {
          var _this$context2 = this.context, isParentNoneTriggered = _this$context2.isParentNoneTriggered, addParentOutsideClickHandler = _this$context2.addParentOutsideClickHandler, addParentOutsideRightClickHandler = _this$context2.addParentOutsideRightClickHandler;
          this.removeOutsideClickHandler(), this.removeOutsideRightClickHandler(), this.handleOutsideClick = void 0, this.handleOutsideRightClick = void 0, !isParentNoneTriggered && addParentOutsideClickHandler && addParentOutsideClickHandler(), !isParentNoneTriggered && addParentOutsideRightClickHandler && addParentOutsideRightClickHandler();
        }
      }, _proto.render = function() {
        var _this$props3 = this.props, arrowProps = _this$props3.arrowProps, placement = _this$props3.placement, tooltip = _this$props3.tooltip;
        return import_react9.default.createElement(TooltipContext.Provider, { value: this.contextValue }, tooltip({ arrowRef: arrowProps.ref, getArrowProps: this.getArrowProps, getTooltipProps: this.getTooltipProps, placement, tooltipRef: this.getTooltipRef }));
      }, _proto.isTriggeredBy = function(event) {
        var trigger = this.props.trigger;
        return trigger === event || Array.isArray(trigger) && trigger.includes(event);
      }, Tooltip3;
    }(import_react9.Component);
    Tooltip.contextType = TooltipContext;
    DEFAULT_MUTATION_OBSERVER_CONFIG = { childList: true, subtree: true };
    TooltipTrigger = function(_Component) {
      _inheritsLoose(TooltipTrigger2, _Component);
      function TooltipTrigger2() {
        for (var _this, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _Component.call.apply(_Component, [this].concat(args)) || this, _this.state = { tooltipShown: _this.props.defaultTooltipShown }, _this.hideTimeout = void 0, _this.showTimeout = void 0, _this.popperOffset = void 0, _this.setTooltipState = function(state) {
          var cb = function() {
            return _this.props.onVisibilityChange(state.tooltipShown);
          };
          _this.isControlled() ? cb() : _this.setState(state, cb);
        }, _this.clearScheduled = function() {
          clearTimeout(_this.hideTimeout), clearTimeout(_this.showTimeout);
        }, _this.showTooltip = function(_ref) {
          var pageX = _ref.pageX, pageY = _ref.pageY;
          _this.clearScheduled();
          var state = { tooltipShown: true };
          _this.props.followCursor && (state = _extends({}, state, { pageX, pageY })), _this.showTimeout = window.setTimeout(function() {
            return _this.setTooltipState(state);
          }, _this.props.delayShow);
        }, _this.hideTooltip = function() {
          _this.clearScheduled(), _this.hideTimeout = window.setTimeout(function() {
            return _this.setTooltipState({ tooltipShown: false });
          }, _this.props.delayHide);
        }, _this.toggleTooltip = function(_ref2) {
          var pageX = _ref2.pageX, pageY = _ref2.pageY, action = _this.getState() ? "hideTooltip" : "showTooltip";
          _this[action]({ pageX, pageY });
        }, _this.clickToggle = function(event) {
          event.preventDefault();
          var pageX = event.pageX, pageY = event.pageY, action = _this.props.followCursor ? "showTooltip" : "toggleTooltip";
          _this[action]({ pageX, pageY });
        }, _this.contextMenuToggle = function(event) {
          event.preventDefault();
          var pageX = event.pageX, pageY = event.pageY, action = _this.props.followCursor ? "showTooltip" : "toggleTooltip";
          _this[action]({ pageX, pageY });
        }, _this.getTriggerProps = function(props) {
          return props === void 0 && (props = {}), _extends({}, props, _this.isTriggeredBy("click") && { onClick: callAll(_this.clickToggle, props.onClick), onTouchEnd: callAll(_this.clickToggle, props.onTouchEnd) }, _this.isTriggeredBy("right-click") && { onContextMenu: callAll(_this.contextMenuToggle, props.onContextMenu) }, _this.isTriggeredBy("hover") && _extends({ onMouseEnter: callAll(_this.showTooltip, props.onMouseEnter), onMouseLeave: callAll(_this.hideTooltip, props.onMouseLeave) }, _this.props.followCursor && { onMouseMove: callAll(_this.showTooltip, props.onMouseMove) }), _this.isTriggeredBy("focus") && { onFocus: callAll(_this.showTooltip, props.onFocus), onBlur: callAll(_this.hideTooltip, props.onBlur) });
        }, _this;
      }
      var _proto = TooltipTrigger2.prototype;
      return _proto.componentWillUnmount = function() {
        this.clearScheduled();
      }, _proto.render = function() {
        var _this2 = this, _this$props = this.props, children = _this$props.children, tooltip = _this$props.tooltip, placement = _this$props.placement, trigger = _this$props.trigger, getTriggerRef = _this$props.getTriggerRef, modifiers = _this$props.modifiers, closeOnReferenceHidden = _this$props.closeOnReferenceHidden, usePortal = _this$props.usePortal, portalContainer = _this$props.portalContainer, followCursor = _this$props.followCursor, getTooltipRef = _this$props.getTooltipRef, mutationObserverOptions = _this$props.mutationObserverOptions, restProps = _objectWithoutPropertiesLoose(_this$props, ["children", "tooltip", "placement", "trigger", "getTriggerRef", "modifiers", "closeOnReferenceHidden", "usePortal", "portalContainer", "followCursor", "getTooltipRef", "mutationObserverOptions"]), popper2 = import_react9.default.createElement(Popper, _extends({ innerRef: getTooltipRef, placement, modifiers: [{ name: "followCursor", enabled: followCursor, phase: "main", fn: function(data) {
          _this2.popperOffset = data.state.rects.popper;
        } }].concat(modifiers) }, restProps), function(_ref3) {
          var ref = _ref3.ref, style = _ref3.style, placement2 = _ref3.placement, arrowProps = _ref3.arrowProps, isReferenceHidden = _ref3.isReferenceHidden, update = _ref3.update;
          if (followCursor && _this2.popperOffset) {
            var _this2$state = _this2.state, pageX = _this2$state.pageX, pageY = _this2$state.pageY, _this2$popperOffset = _this2.popperOffset, width = _this2$popperOffset.width, height = _this2$popperOffset.height, x = pageX + width > window.pageXOffset + document.body.offsetWidth ? pageX - width : pageX, y = pageY + height > window.pageYOffset + document.body.offsetHeight ? pageY - height : pageY;
            style.transform = "translate3d(" + x + "px, " + y + "px, 0";
          }
          return import_react9.default.createElement(Tooltip, _extends({ arrowProps, closeOnReferenceHidden, isReferenceHidden, placement: placement2, update, style, tooltip, trigger, mutationObserverOptions }, { clearScheduled: _this2.clearScheduled, hideTooltip: _this2.hideTooltip, innerRef: ref }));
        });
        return import_react9.default.createElement(Manager, null, import_react9.default.createElement(Reference, { innerRef: getTriggerRef }, function(_ref4) {
          var ref = _ref4.ref;
          return children({ getTriggerProps: _this2.getTriggerProps, triggerRef: ref });
        }), this.getState() && (usePortal ? (0, import_react_dom.createPortal)(popper2, portalContainer) : popper2));
      }, _proto.isControlled = function() {
        return this.props.tooltipShown !== void 0;
      }, _proto.getState = function() {
        return this.isControlled() ? this.props.tooltipShown : this.state.tooltipShown;
      }, _proto.isTriggeredBy = function(event) {
        var trigger = this.props.trigger;
        return trigger === event || Array.isArray(trigger) && trigger.includes(event);
      }, TooltipTrigger2;
    }(import_react9.Component);
    TooltipTrigger.defaultProps = { closeOnReferenceHidden: true, defaultTooltipShown: false, delayHide: 0, delayShow: 0, followCursor: false, onVisibilityChange: noop, placement: "right", portalContainer: canUseDOM() ? document.body : null, trigger: "hover", usePortal: canUseDOM(), mutationObserverOptions: DEFAULT_MUTATION_OBSERVER_CONFIG, modifiers: [] };
    react_popper_tooltip_default = TooltipTrigger;
    match = (0, import_memoizerific3.default)(1e3)((requests, actual, value, fallback = 0) => actual.split("-")[0] === requests ? value : fallback);
    ArrowSpacing = 8;
    Arrow = import_theming7.styled.div({ position: "absolute", borderStyle: "solid" }, ({ placement }) => {
      let x = 0, y = 0;
      switch (true) {
        case (placement.startsWith("left") || placement.startsWith("right")): {
          y = 8;
          break;
        }
        case (placement.startsWith("top") || placement.startsWith("bottom")): {
          x = 8;
          break;
        }
        default:
      }
      return { transform: `translate3d(${x}px, ${y}px, 0px)` };
    }, ({ theme, color, placement }) => ({ bottom: `${match("top", placement, ArrowSpacing * -1, "auto")}px`, top: `${match("bottom", placement, ArrowSpacing * -1, "auto")}px`, right: `${match("left", placement, ArrowSpacing * -1, "auto")}px`, left: `${match("right", placement, ArrowSpacing * -1, "auto")}px`, borderBottomWidth: `${match("top", placement, "0", ArrowSpacing)}px`, borderTopWidth: `${match("bottom", placement, "0", ArrowSpacing)}px`, borderRightWidth: `${match("left", placement, "0", ArrowSpacing)}px`, borderLeftWidth: `${match("right", placement, "0", ArrowSpacing)}px`, borderTopColor: match("top", placement, theme.color[color] || color || theme.base === "light" ? (0, import_theming7.lighten)(theme.background.app) : theme.background.app, "transparent"), borderBottomColor: match("bottom", placement, theme.color[color] || color || theme.base === "light" ? (0, import_theming7.lighten)(theme.background.app) : theme.background.app, "transparent"), borderLeftColor: match("left", placement, theme.color[color] || color || theme.base === "light" ? (0, import_theming7.lighten)(theme.background.app) : theme.background.app, "transparent"), borderRightColor: match("right", placement, theme.color[color] || color || theme.base === "light" ? (0, import_theming7.lighten)(theme.background.app) : theme.background.app, "transparent") }));
    Wrapper2 = import_theming7.styled.div(({ hidden }) => ({ display: hidden ? "none" : "inline-block", zIndex: 2147483647 }), ({ theme, color, hasChrome }) => hasChrome ? { background: theme.color[color] || color || theme.base === "light" ? (0, import_theming7.lighten)(theme.background.app) : theme.background.app, filter: `
            drop-shadow(0px 5px 5px rgba(0,0,0,0.05))
            drop-shadow(0 1px 3px rgba(0,0,0,0.1))
          `, borderRadius: theme.appBorderRadius * 2, fontSize: theme.typography.size.s1 } : {});
    Tooltip2 = ({ placement, hasChrome, children, arrowProps, tooltipRef, arrowRef, color, ...props }) => import_react10.default.createElement(Wrapper2, { hasChrome, placement, ref: tooltipRef, ...props, color }, hasChrome && import_react10.default.createElement(Arrow, { placement, ref: arrowRef, ...arrowProps, color }), children);
    Tooltip2.defaultProps = { color: void 0, arrowRef: void 0, tooltipRef: void 0, hasChrome: true, placement: "top", arrowProps: {} };
    ({ document: document22 } = import_global3.default);
    TargetContainer = import_theming6.styled.div`
  display: inline-block;
  cursor: ${(props) => props.mode === "hover" ? "default" : "pointer"};
`;
    TargetSvgContainer = import_theming6.styled.g`
  cursor: ${(props) => props.mode === "hover" ? "default" : "pointer"};
`;
    WithTooltipPure = ({ svg, trigger, closeOnClick, placement, modifiers, hasChrome, tooltip, children, tooltipShown, onVisibilityChange, ...props }) => {
      let Container4 = svg ? TargetSvgContainer : TargetContainer;
      return import_react8.default.createElement(react_popper_tooltip_default, { placement, trigger, modifiers, tooltipShown, onVisibilityChange, tooltip: ({ getTooltipProps, getArrowProps, tooltipRef, arrowRef, placement: tooltipPlacement }) => import_react8.default.createElement(Tooltip2, { hasChrome, placement: tooltipPlacement, tooltipRef, arrowRef, arrowProps: getArrowProps(), ...getTooltipProps() }, typeof tooltip == "function" ? tooltip({ onHide: () => onVisibilityChange(false) }) : tooltip) }, ({ getTriggerProps, triggerRef }) => import_react8.default.createElement(Container4, { ref: triggerRef, ...getTriggerProps(), ...props }, children));
    };
    WithTooltipPure.defaultProps = { svg: false, trigger: "hover", closeOnClick: false, placement: "top", modifiers: [{ name: "preventOverflow", options: { padding: 8 } }, { name: "offset", options: { offset: [8, 8] } }, { name: "arrow", options: { padding: 8 } }], hasChrome: true, tooltipShown: false };
    WithToolTipState = ({ startOpen = false, onVisibilityChange: onChange, ...rest }) => {
      let [tooltipShown, setTooltipShown] = (0, import_react8.useState)(startOpen), onVisibilityChange = (0, import_react8.useCallback)((visibility) => {
        onChange && onChange(visibility) === false || setTooltipShown(visibility);
      }, [onChange]);
      return (0, import_react8.useEffect)(() => {
        let hide2 = () => onVisibilityChange(false);
        document22.addEventListener("keydown", hide2, false);
        let iframes = Array.from(document22.getElementsByTagName("iframe")), unbinders = [];
        return iframes.forEach((iframe) => {
          let bind = () => {
            try {
              iframe.contentWindow.document && (iframe.contentWindow.document.addEventListener("click", hide2), unbinders.push(() => {
                try {
                  iframe.contentWindow.document.removeEventListener("click", hide2);
                } catch {
                }
              }));
            } catch {
            }
          };
          bind(), iframe.addEventListener("load", bind), unbinders.push(() => {
            iframe.removeEventListener("load", bind);
          });
        }), () => {
          document22.removeEventListener("keydown", hide2), unbinders.forEach((unbind) => {
            unbind();
          });
        };
      }), import_react8.default.createElement(WithTooltipPure, { ...rest, tooltipShown, onVisibilityChange });
    };
  }
});

// src/panel/task-result/expanding-result.tsx
var expanding_result_exports = {};
__export(expanding_result_exports, {
  ExpandingResult: () => ExpandingResult
});
module.exports = __toCommonJS(expanding_result_exports);
var import_react45 = __toESM(require("react"));
var import_theming51 = require("@storybook/theming");

// src/panel/task-result/parts.tsx
var import_theming = require("@storybook/theming");
var Section = import_theming.styled.div`
  background-color: ${(props) => props.theme.background.content};
  padding: var(--grid);
  padding-top: 0;

  > * {
    margin-top: var(--grid);
  }

  &:last-of-type {
    border-bottom-left-radius: var(--result-border-radius);
    border-bottom-right-radius: var(--result-border-radius);
  }
`;
var Heading = import_theming.styled.h4`
  font-weight: bold;
`;
var Content = import_theming.styled.div``;
var Note = import_theming.styled.div`
  padding: calc(var(--grid) / 2);
  background-color: ${(props) => props.theme.background.hoverable};
  border-radius: var(--result-border-radius);
  font-size: small;

  &::before {
    margin-right: 1ch;
    content: '';
  }
`;
var ResultValue = import_theming.styled.code`
  /* font-family: 'Courier'; */
`;
var ResultScale = import_theming.styled.code`
  /* slightly smaller margin that other elements */
  margin-left: var(--halfGrid);
`;
var ValueLozenge = import_theming.styled.code`
  ${({ hasWarningIcon = true }) => !hasWarningIcon && `&:before {
      content: '\u26A0\uFE0F';
      margin-right: 1ch;
    }`};
  padding: calc(var(--grid) / 2) var(--grid);
  border-radius: var(--result-border-radius);
  color: ${(props) => props.theme.color.light};
  font-weight: bold;
  font-size: small;
  background-color: ${({ type, theme }) => {
  switch (type) {
    case "positive":
      return theme.color.positive;
    case "negative":
      return theme.color.negative;
    case "faint":
      return theme.color.medium;
    case "warning":
      return theme.color.warning;
    case "info":
      return theme.color.seafoam;
    default:
      return theme.color.purple;
  }
}};
`;
var Table = import_theming.styled.table`
  width: 100%;
`;
var TitleCell = import_theming.styled.td``;
var ValueCell = import_theming.styled.td`
  text-align: right;
`;

// ../../node_modules/@storybook/components/dist/index.mjs
init_chunk_XGEY5Y7J();
init_chunk_4V2BRVWI();
init_chunk_4REFJGR7();
init_chunk_NNAAFZ4U();
var import_react11 = require("react");
var import_react12 = __toESM(require("react"), 1);
var import_theming8 = require("@storybook/theming");
var import_react13 = __toESM(require("react"), 1);
var import_theming9 = require("@storybook/theming");
var import_theming10 = require("@storybook/theming");
var import_react14 = __toESM(require("react"), 1);
var import_theming11 = require("@storybook/theming");
var import_theming12 = require("@storybook/theming");
var import_theming13 = require("@storybook/theming");
var import_theming14 = require("@storybook/theming");
var import_theming15 = require("@storybook/theming");
var import_theming16 = require("@storybook/theming");
var import_theming17 = require("@storybook/theming");
var import_theming18 = require("@storybook/theming");
var import_theming19 = require("@storybook/theming");
var import_theming20 = require("@storybook/theming");
var import_theming21 = require("@storybook/theming");
var import_theming22 = require("@storybook/theming");
var import_theming23 = require("@storybook/theming");
var import_theming24 = require("@storybook/theming");
var import_theming25 = require("@storybook/theming");
var import_theming26 = require("@storybook/theming");
var import_theming27 = require("@storybook/theming");
var import_theming28 = require("@storybook/theming");
var import_theming29 = require("@storybook/theming");
var import_react15 = __toESM(require("react"), 1);
var import_theming30 = require("@storybook/theming");
var import_react16 = __toESM(require("react"), 1);
var import_theming31 = require("@storybook/theming");
var import_react17 = __toESM(require("react"), 1);
var import_theming32 = require("@storybook/theming");
var import_react18 = __toESM(require("react"), 1);
var import_theming33 = require("@storybook/theming");
var import_react19 = __toESM(require("react"), 1);
var import_react20 = __toESM(require("react"), 1);
var import_theming34 = require("@storybook/theming");
var import_react21 = __toESM(require("react"), 1);
var import_theming35 = require("@storybook/theming");
var import_react22 = __toESM(require("react"), 1);
var import_theming36 = require("@storybook/theming");
var import_react23 = require("react");
var import_react24 = __toESM(require("react"), 1);
var import_theming37 = require("@storybook/theming");
var import_theming38 = require("@storybook/theming");
var import_react25 = __toESM(require("react"), 1);
var import_theming39 = require("@storybook/theming");
var import_react26 = __toESM(require("react"), 1);
var import_theming40 = require("@storybook/theming");
var import_react27 = require("react");
var React14 = __toESM(require("react"), 1);
var import_react28 = require("react");
var import_react29 = require("react");
var import_react30 = __toESM(require("react"), 1);
var import_react31 = __toESM(require("react"), 1);
var import_theming41 = require("@storybook/theming");
var import_react32 = __toESM(require("react"), 1);
var import_theming42 = require("@storybook/theming");
var import_react33 = __toESM(require("react"), 1);
var import_theming43 = require("@storybook/theming");
var import_react34 = __toESM(require("react"), 1);
var import_theming44 = require("@storybook/theming");
var import_memoizerific4 = __toESM(require_memoizerific(), 1);
var import_react35 = __toESM(require("react"), 1);
var import_theming45 = require("@storybook/theming");

// ../../node_modules/@storybook/csf/dist/index.mjs
var import_startCase = __toESM(require_startCase(), 1);
var import_isEqual = __toESM(require_isEqual(), 1);
var sanitize = (string) => {
  return string.toLowerCase().replace(/[ '`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
};

// ../../node_modules/@storybook/components/dist/index.mjs
var import_react36 = __toESM(require("react"), 1);
var import_theming46 = require("@storybook/theming");
var import_react37 = __toESM(require("react"), 1);
var import_theming47 = require("@storybook/theming");
var import_react38 = __toESM(require("react"), 1);
var import_theming48 = require("@storybook/theming");
var import_react39 = __toESM(require("react"), 1);
var import_react40 = __toESM(require("react"), 1);
var import_react41 = __toESM(require("react"), 1);
var import_react42 = __toESM(require("react"), 1);
var import_theming49 = require("@storybook/theming");
var import_theming50 = require("@storybook/theming");
var nameSpaceClassNames = ({ ...props }, key) => {
  let classes = [props.class, props.className];
  return delete props.class, props.className = ["sbdocs", `sbdocs-${key}`, ...classes].filter(Boolean).join(" "), props;
};
function _assertThisInitialized(self2) {
  if (self2 === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self2;
}
function _getPrototypeOf(o) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, _getPrototypeOf(o);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return false;
  if (typeof Proxy == "function")
    return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch {
    return false;
  }
}
function _construct(Parent, args, Class) {
  return _isNativeReflectConstruct() ? _construct = Reflect.construct.bind() : _construct = function(Parent2, args2, Class2) {
    var a = [null];
    a.push.apply(a, args2);
    var Constructor = Function.bind.apply(Parent2, a), instance = new Constructor();
    return Class2 && _setPrototypeOf(instance, Class2.prototype), instance;
  }, _construct.apply(null, arguments);
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof _cache < "u") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper32);
    }
    function Wrapper32() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper32.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper32, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper32, Class2);
  }, _wrapNativeSuper(Class);
}
var ERRORS = { 1: `Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).

`, 2: `Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).

`, 3: `Passed an incorrect argument to a color function, please pass a string representation of a color.

`, 4: `Couldn't generate valid rgb string from %s, it returned %s.

`, 5: `Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.

`, 6: `Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).

`, 7: `Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).

`, 8: `Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.

`, 9: `Please provide a number of steps to the modularScale helper.

`, 10: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`, 11: `Invalid value passed as base to modularScale, expected number or em string but got "%s"

`, 12: `Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.

`, 13: `Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.

`, 14: `Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.

`, 15: `Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.

`, 16: `You must provide a template to this method.

`, 17: `You passed an unsupported selector state to this method.

`, 18: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`, 19: `fromSize and toSize must be provided as stringified numbers with the same units.

`, 20: `expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`, 21: "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n", 22: "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n", 23: `fontFace expects a name of a font-family.

`, 24: `fontFace expects either the path to the font file(s) or a name of a local copy.

`, 25: `fontFace expects localFonts to be an array.

`, 26: `fontFace expects fileFormats to be an array.

`, 27: `radialGradient requries at least 2 color-stops to properly render.

`, 28: `Please supply a filename to retinaImage() as the first argument.

`, 29: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`, 30: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n", 31: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation

`, 32: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])
To pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')

`, 33: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation

`, 34: `borderRadius expects a radius value as a string or number as the second argument.

`, 35: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`, 36: `Property must be a string value.

`, 37: `Syntax Error at %s.

`, 38: `Formula contains a function that needs parentheses at %s.

`, 39: `Formula is missing closing parenthesis at %s.

`, 40: `Formula has too many closing parentheses at %s.

`, 41: `All values in a formula must have the same unit or be unitless.

`, 42: `Please provide a number of steps to the modularScale helper.

`, 43: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`, 44: `Invalid value passed as base to modularScale, expected number or em/rem string but got %s.

`, 45: `Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.

`, 46: `Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.

`, 47: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`, 48: `fromSize and toSize must be provided as stringified numbers with the same units.

`, 49: `Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`, 50: `Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.

`, 51: `Expects the first argument object to have the properties prop, fromSize, and toSize.

`, 52: `fontFace expects either the path to the font file(s) or a name of a local copy.

`, 53: `fontFace expects localFonts to be an array.

`, 54: `fontFace expects fileFormats to be an array.

`, 55: `fontFace expects a name of a font-family.

`, 56: `linearGradient requries at least 2 color-stops to properly render.

`, 57: `radialGradient requries at least 2 color-stops to properly render.

`, 58: `Please supply a filename to retinaImage() as the first argument.

`, 59: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`, 60: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n", 61: `Property must be a string value.

`, 62: `borderRadius expects a radius value as a string or number as the second argument.

`, 63: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`, 64: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.

`, 65: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').

`, 66: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.

`, 67: `You must provide a template to this method.

`, 68: `You passed an unsupported selector state to this method.

`, 69: `Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.

`, 70: `Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.

`, 71: `Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.

`, 72: `Passed invalid base value %s to %s(), please pass a value like "12px" or 12.

`, 73: `Please provide a valid CSS variable.

`, 74: `CSS variable not found and no default was provided.

`, 75: `important requires a valid style object, got a %s instead.

`, 76: `fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.

`, 77: `remToPx expects a value in "rem" but you provided it in "%s".

`, 78: `base must be set in "px" or "%" but you set it in "%s".
` };
function format2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
    args[_key] = arguments[_key];
  var a = args[0], b = [], c;
  for (c = 1; c < args.length; c += 1)
    b.push(args[c]);
  return b.forEach(function(d) {
    a = a.replace(/%[a-z]/, d);
  }), a;
}
var PolishedError = function(_Error) {
  _inheritsLoose(PolishedError2, _Error);
  function PolishedError2(code) {
    var _this;
    if (false)
      _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code + " for more information.") || this;
    else {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
        args[_key2 - 1] = arguments[_key2];
      _this = _Error.call(this, format2.apply(void 0, [ERRORS[code]].concat(args))) || this;
    }
    return _assertThisInitialized(_this);
  }
  return PolishedError2;
}(_wrapNativeSuper(Error));
function colorToInt(color) {
  return Math.round(color * 255);
}
function convertToInt(red, green, blue) {
  return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
}
function hslToRgb(hue, saturation, lightness, convert) {
  if (convert === void 0 && (convert = convertToInt), saturation === 0)
    return convert(lightness, lightness, lightness);
  var huePrime = (hue % 360 + 360) % 360 / 60, chroma = (1 - Math.abs(2 * lightness - 1)) * saturation, secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1)), red = 0, green = 0, blue = 0;
  huePrime >= 0 && huePrime < 1 ? (red = chroma, green = secondComponent) : huePrime >= 1 && huePrime < 2 ? (red = secondComponent, green = chroma) : huePrime >= 2 && huePrime < 3 ? (green = chroma, blue = secondComponent) : huePrime >= 3 && huePrime < 4 ? (green = secondComponent, blue = chroma) : huePrime >= 4 && huePrime < 5 ? (red = secondComponent, blue = chroma) : huePrime >= 5 && huePrime < 6 && (red = chroma, blue = secondComponent);
  var lightnessModification = lightness - chroma / 2, finalRed = red + lightnessModification, finalGreen = green + lightnessModification, finalBlue = blue + lightnessModification;
  return convert(finalRed, finalGreen, finalBlue);
}
var namedColorMap = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "639", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" };
function nameToHex(color) {
  if (typeof color != "string")
    return color;
  var normalizedColorName = color.toLowerCase();
  return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
}
var hexRegex = /^#[a-fA-F0-9]{6}$/;
var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
function parseToRgb(color) {
  if (typeof color != "string")
    throw new PolishedError(3);
  var normalizedColor = nameToHex(color);
  if (normalizedColor.match(hexRegex))
    return { red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16), green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16), blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16) };
  if (normalizedColor.match(hexRgbaRegex)) {
    var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
    return { red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16), green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16), blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16), alpha };
  }
  if (normalizedColor.match(reducedHexRegex))
    return { red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16), green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16), blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16) };
  if (normalizedColor.match(reducedRgbaHexRegex)) {
    var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
    return { red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16), green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16), blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16), alpha: _alpha };
  }
  var rgbMatched = rgbRegex.exec(normalizedColor);
  if (rgbMatched)
    return { red: parseInt("" + rgbMatched[1], 10), green: parseInt("" + rgbMatched[2], 10), blue: parseInt("" + rgbMatched[3], 10) };
  var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
  if (rgbaMatched)
    return { red: parseInt("" + rgbaMatched[1], 10), green: parseInt("" + rgbaMatched[2], 10), blue: parseInt("" + rgbaMatched[3], 10), alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4]) };
  var hslMatched = hslRegex.exec(normalizedColor);
  if (hslMatched) {
    var hue = parseInt("" + hslMatched[1], 10), saturation = parseInt("" + hslMatched[2], 10) / 100, lightness = parseInt("" + hslMatched[3], 10) / 100, rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")", hslRgbMatched = rgbRegex.exec(rgbColorString);
    if (!hslRgbMatched)
      throw new PolishedError(4, normalizedColor, rgbColorString);
    return { red: parseInt("" + hslRgbMatched[1], 10), green: parseInt("" + hslRgbMatched[2], 10), blue: parseInt("" + hslRgbMatched[3], 10) };
  }
  var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
  if (hslaMatched) {
    var _hue = parseInt("" + hslaMatched[1], 10), _saturation = parseInt("" + hslaMatched[2], 10) / 100, _lightness = parseInt("" + hslaMatched[3], 10) / 100, _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")", _hslRgbMatched = rgbRegex.exec(_rgbColorString);
    if (!_hslRgbMatched)
      throw new PolishedError(4, normalizedColor, _rgbColorString);
    return { red: parseInt("" + _hslRgbMatched[1], 10), green: parseInt("" + _hslRgbMatched[2], 10), blue: parseInt("" + _hslRgbMatched[3], 10), alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4]) };
  }
  throw new PolishedError(5);
}
function rgbToHsl(color) {
  var red = color.red / 255, green = color.green / 255, blue = color.blue / 255, max2 = Math.max(red, green, blue), min2 = Math.min(red, green, blue), lightness = (max2 + min2) / 2;
  if (max2 === min2)
    return color.alpha !== void 0 ? { hue: 0, saturation: 0, lightness, alpha: color.alpha } : { hue: 0, saturation: 0, lightness };
  var hue, delta = max2 - min2, saturation = lightness > 0.5 ? delta / (2 - max2 - min2) : delta / (max2 + min2);
  switch (max2) {
    case red:
      hue = (green - blue) / delta + (green < blue ? 6 : 0);
      break;
    case green:
      hue = (blue - red) / delta + 2;
      break;
    default:
      hue = (red - green) / delta + 4;
      break;
  }
  return hue *= 60, color.alpha !== void 0 ? { hue, saturation, lightness, alpha: color.alpha } : { hue, saturation, lightness };
}
function parseToHsl(color) {
  return rgbToHsl(parseToRgb(color));
}
var reduceHexValue = function(value) {
  return value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6] ? "#" + value[1] + value[3] + value[5] : value;
};
var reduceHexValue$1 = reduceHexValue;
function numberToHex(value) {
  var hex = value.toString(16);
  return hex.length === 1 ? "0" + hex : hex;
}
function colorToHex(color) {
  return numberToHex(Math.round(color * 255));
}
function convertToHex(red, green, blue) {
  return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
}
function hslToHex(hue, saturation, lightness) {
  return hslToRgb(hue, saturation, lightness, convertToHex);
}
function hsl(value, saturation, lightness) {
  if (typeof value == "number" && typeof saturation == "number" && typeof lightness == "number")
    return hslToHex(value, saturation, lightness);
  if (typeof value == "object" && saturation === void 0 && lightness === void 0)
    return hslToHex(value.hue, value.saturation, value.lightness);
  throw new PolishedError(1);
}
function hsla(value, saturation, lightness, alpha) {
  if (typeof value == "number" && typeof saturation == "number" && typeof lightness == "number" && typeof alpha == "number")
    return alpha >= 1 ? hslToHex(value, saturation, lightness) : "rgba(" + hslToRgb(value, saturation, lightness) + "," + alpha + ")";
  if (typeof value == "object" && saturation === void 0 && lightness === void 0 && alpha === void 0)
    return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
  throw new PolishedError(2);
}
function rgb(value, green, blue) {
  if (typeof value == "number" && typeof green == "number" && typeof blue == "number")
    return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
  if (typeof value == "object" && green === void 0 && blue === void 0)
    return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
  throw new PolishedError(6);
}
function rgba(firstValue, secondValue, thirdValue, fourthValue) {
  if (typeof firstValue == "string" && typeof secondValue == "number") {
    var rgbValue = parseToRgb(firstValue);
    return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
  } else {
    if (typeof firstValue == "number" && typeof secondValue == "number" && typeof thirdValue == "number" && typeof fourthValue == "number")
      return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
    if (typeof firstValue == "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0)
      return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
  }
  throw new PolishedError(7);
}
var isRgb = function(color) {
  return typeof color.red == "number" && typeof color.green == "number" && typeof color.blue == "number" && (typeof color.alpha != "number" || typeof color.alpha > "u");
};
var isRgba = function(color) {
  return typeof color.red == "number" && typeof color.green == "number" && typeof color.blue == "number" && typeof color.alpha == "number";
};
var isHsl = function(color) {
  return typeof color.hue == "number" && typeof color.saturation == "number" && typeof color.lightness == "number" && (typeof color.alpha != "number" || typeof color.alpha > "u");
};
var isHsla = function(color) {
  return typeof color.hue == "number" && typeof color.saturation == "number" && typeof color.lightness == "number" && typeof color.alpha == "number";
};
function toColorString(color) {
  if (typeof color != "object")
    throw new PolishedError(8);
  if (isRgba(color))
    return rgba(color);
  if (isRgb(color))
    return rgb(color);
  if (isHsla(color))
    return hsla(color);
  if (isHsl(color))
    return hsl(color);
  throw new PolishedError(8);
}
function curried(f, length2, acc) {
  return function() {
    var combined = acc.concat(Array.prototype.slice.call(arguments));
    return combined.length >= length2 ? f.apply(this, combined) : curried(f, length2, combined);
  };
}
function curry(f) {
  return curried(f, f.length, []);
}
function guard(lowerBoundary, upperBoundary, value) {
  return Math.max(lowerBoundary, Math.min(upperBoundary, value));
}
function darken(amount, color) {
  if (color === "transparent")
    return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends({}, hslColor, { lightness: guard(0, 1, hslColor.lightness - parseFloat(amount)) }));
}
var curriedDarken = curry(darken);
var curriedDarken$1 = curriedDarken;
function lighten2(amount, color) {
  if (color === "transparent")
    return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends({}, hslColor, { lightness: guard(0, 1, hslColor.lightness + parseFloat(amount)) }));
}
var curriedLighten = curry(lighten2);
var curriedLighten$1 = curriedLighten;
function transparentize(amount, color) {
  if (color === "transparent")
    return color;
  var parsedColor = parseToRgb(color), alpha = typeof parsedColor.alpha == "number" ? parsedColor.alpha : 1, colorWithAlpha = _extends({}, parsedColor, { alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100) });
  return rgba(colorWithAlpha);
}
var curriedTransparentize = curry(transparentize);
var curriedTransparentize$1 = curriedTransparentize;
var headerCommon = ({ theme }) => ({ margin: "20px 0 8px", padding: 0, cursor: "text", position: "relative", color: theme.color.defaultText, "&:first-of-type": { marginTop: 0, paddingTop: 0 }, "&:hover a.anchor": { textDecoration: "none" }, "& tt, & code": { fontSize: "inherit" } });
var codeCommon = ({ theme }) => ({ lineHeight: 1, margin: "0 2px", padding: "3px 5px", whiteSpace: "nowrap", borderRadius: 3, fontSize: theme.typography.size.s2 - 1, border: theme.base === "light" ? `1px solid ${theme.color.mediumlight}` : `1px solid ${theme.color.darker}`, color: theme.base === "light" ? curriedTransparentize$1(0.1, theme.color.defaultText) : curriedTransparentize$1(0.3, theme.color.defaultText), backgroundColor: theme.base === "light" ? theme.color.lighter : theme.color.border });
var withReset = ({ theme }) => ({ fontFamily: theme.typography.fonts.base, fontSize: theme.typography.size.s3, margin: 0, WebkitFontSmoothing: "antialiased", MozOsxFontSmoothing: "grayscale", WebkitTapHighlightColor: "rgba(0, 0, 0, 0)", WebkitOverflowScrolling: "touch" });
var withMargin = { margin: "16px 0" };
var Link = ({ href: input, children, ...props }) => {
  let isStorybookPath = /^\//.test(input), isAnchorUrl = /^#.*/.test(input), href = isStorybookPath ? `?path=${input}` : input;
  return import_react13.default.createElement("a", { href, target: isAnchorUrl ? "_self" : "_top", ...props }, children);
};
var A = (0, import_theming8.styled)(Link)(withReset, ({ theme }) => ({ fontSize: "inherit", lineHeight: "24px", color: theme.color.secondary, textDecoration: "none", "&.absent": { color: "#cc0000" }, "&.anchor": { display: "block", paddingLeft: 30, marginLeft: -30, cursor: "pointer", position: "absolute", top: 0, left: 0, bottom: 0 } }));
var Blockquote = import_theming9.styled.blockquote(withReset, withMargin, ({ theme }) => ({ borderLeft: `4px solid ${theme.color.medium}`, padding: "0 15px", color: theme.color.dark, "& > :first-of-type": { marginTop: 0 }, "& > :last-child": { marginBottom: 0 } }));
var isReactChildString = (child) => typeof child == "string";
var isInlineCodeRegex = /[\n\r]/g;
var DefaultCodeBlock = import_theming10.styled.code(({ theme }) => ({ fontFamily: theme.typography.fonts.mono, WebkitFontSmoothing: "antialiased", MozOsxFontSmoothing: "grayscale", display: "inline-block", paddingLeft: 2, paddingRight: 2, verticalAlign: "baseline", color: "inherit" }), codeCommon);
var StyledSyntaxHighlighter = (0, import_theming10.styled)(SyntaxHighlighter2)(({ theme }) => ({ fontFamily: theme.typography.fonts.mono, fontSize: `${theme.typography.size.s2 - 1}px`, lineHeight: "19px", margin: "25px 0 40px", borderRadius: theme.appBorderRadius, boxShadow: theme.base === "light" ? "rgba(0, 0, 0, 0.10) 0 1px 3px 0" : "rgba(0, 0, 0, 0.20) 0 2px 5px 0", "pre.prismjs": { padding: 20, background: "inherit" } }));
var Code2 = ({ className, children, ...props }) => {
  var _a;
  let language = (className || "").match(/lang-(\S+)/), childrenArray = import_react14.Children.toArray(children);
  return childrenArray.filter(isReactChildString).some((child) => child.match(isInlineCodeRegex)) ? import_react14.default.createElement(StyledSyntaxHighlighter, { bordered: true, copyable: true, language: (_a = language == null ? void 0 : language[1]) != null ? _a : "plaintext", format: false, ...props }, children) : import_react14.default.createElement(DefaultCodeBlock, { ...props, className }, childrenArray);
};
var Div = import_theming11.styled.div(withReset);
var DL = import_theming12.styled.dl(withReset, { ...withMargin, padding: 0, "& dt": { fontSize: "14px", fontWeight: "bold", fontStyle: "italic", padding: 0, margin: "16px 0 4px" }, "& dt:first-of-type": { padding: 0 }, "& dt > :first-of-type": { marginTop: 0 }, "& dt > :last-child": { marginBottom: 0 }, "& dd": { margin: "0 0 16px", padding: "0 15px" }, "& dd > :first-of-type": { marginTop: 0 }, "& dd > :last-child": { marginBottom: 0 } });
var H1 = import_theming13.styled.h1(withReset, headerCommon, ({ theme }) => ({ fontSize: `${theme.typography.size.l1}px`, fontWeight: theme.typography.weight.black }));
var H2 = import_theming14.styled.h2(withReset, headerCommon, ({ theme }) => ({ fontSize: `${theme.typography.size.m2}px`, paddingBottom: 4, borderBottom: `1px solid ${theme.appBorderColor}` }));
var H3 = import_theming15.styled.h3(withReset, headerCommon, ({ theme }) => ({ fontSize: `${theme.typography.size.m1}px` }));
var H4 = import_theming16.styled.h4(withReset, headerCommon, ({ theme }) => ({ fontSize: `${theme.typography.size.s3}px` }));
var H5 = import_theming17.styled.h5(withReset, headerCommon, ({ theme }) => ({ fontSize: `${theme.typography.size.s2}px` }));
var H6 = import_theming18.styled.h6(withReset, headerCommon, ({ theme }) => ({ fontSize: `${theme.typography.size.s2}px`, color: theme.color.dark }));
var HR = import_theming19.styled.hr(({ theme }) => ({ border: "0 none", borderTop: `1px solid ${theme.appBorderColor}`, height: 4, padding: 0 }));
var Img = import_theming20.styled.img({ maxWidth: "100%" });
var LI = import_theming21.styled.li(withReset, ({ theme }) => ({ fontSize: theme.typography.size.s2, color: theme.color.defaultText, lineHeight: "24px", "& + li": { marginTop: ".25em" }, "& ul, & ol": { marginTop: ".25em", marginBottom: 0 }, "& code": codeCommon({ theme }) }));
var listCommon = { paddingLeft: 30, "& :first-of-type": { marginTop: 0 }, "& :last-child": { marginBottom: 0 } };
var OL = import_theming22.styled.ol(withReset, withMargin, { ...listCommon, listStyle: "decimal" });
var P = import_theming23.styled.p(withReset, withMargin, ({ theme }) => ({ fontSize: theme.typography.size.s2, lineHeight: "24px", color: theme.color.defaultText, "& code": codeCommon({ theme }) }));
var Pre2 = import_theming24.styled.pre(withReset, withMargin, ({ theme }) => ({ fontFamily: theme.typography.fonts.mono, WebkitFontSmoothing: "antialiased", MozOsxFontSmoothing: "grayscale", lineHeight: "18px", padding: "11px 1rem", whiteSpace: "pre-wrap", color: "inherit", borderRadius: 3, margin: "1rem 0", "&:not(.prismjs)": { background: "transparent", border: "none", borderRadius: 0, padding: 0, margin: 0 }, "& pre, &.prismjs": { padding: 15, margin: 0, whiteSpace: "pre-wrap", color: "inherit", fontSize: "13px", lineHeight: "19px", code: { color: "inherit", fontSize: "inherit" } }, "& code": { whiteSpace: "pre" }, "& code, & tt": { border: "none" } }));
var Span = import_theming25.styled.span(withReset, ({ theme }) => ({ "&.frame": { display: "block", overflow: "hidden", "& > span": { border: `1px solid ${theme.color.medium}`, display: "block", float: "left", overflow: "hidden", margin: "13px 0 0", padding: 7, width: "auto" }, "& span img": { display: "block", float: "left" }, "& span span": { clear: "both", color: theme.color.darkest, display: "block", padding: "5px 0 0" } }, "&.align-center": { display: "block", overflow: "hidden", clear: "both", "& > span": { display: "block", overflow: "hidden", margin: "13px auto 0", textAlign: "center" }, "& span img": { margin: "0 auto", textAlign: "center" } }, "&.align-right": { display: "block", overflow: "hidden", clear: "both", "& > span": { display: "block", overflow: "hidden", margin: "13px 0 0", textAlign: "right" }, "& span img": { margin: 0, textAlign: "right" } }, "&.float-left": { display: "block", marginRight: 13, overflow: "hidden", float: "left", "& span": { margin: "13px 0 0" } }, "&.float-right": { display: "block", marginLeft: 13, overflow: "hidden", float: "right", "& > span": { display: "block", overflow: "hidden", margin: "13px auto 0", textAlign: "right" } } }));
var Table2 = import_theming26.styled.table(withReset, withMargin, ({ theme }) => ({ fontSize: theme.typography.size.s2, lineHeight: "24px", padding: 0, borderCollapse: "collapse", "& tr": { borderTop: `1px solid ${theme.appBorderColor}`, backgroundColor: theme.appContentBg, margin: 0, padding: 0 }, "& tr:nth-of-type(2n)": { backgroundColor: theme.base === "dark" ? theme.color.darker : theme.color.lighter }, "& tr th": { fontWeight: "bold", color: theme.color.defaultText, border: `1px solid ${theme.appBorderColor}`, margin: 0, padding: "6px 13px" }, "& tr td": { border: `1px solid ${theme.appBorderColor}`, color: theme.color.defaultText, margin: 0, padding: "6px 13px" }, "& tr th :first-of-type, & tr td :first-of-type": { marginTop: 0 }, "& tr th :last-child, & tr td :last-child": { marginBottom: 0 } }));
var TT = import_theming27.styled.title(codeCommon);
var listCommon2 = { paddingLeft: 30, "& :first-of-type": { marginTop: 0 }, "& :last-child": { marginBottom: 0 } };
var UL = import_theming28.styled.ul(withReset, withMargin, { ...listCommon2, listStyle: "disc" });
var ResetWrapper = import_theming29.styled.div(withReset);
var components = { h1: (props) => import_react12.default.createElement(H1, { ...nameSpaceClassNames(props, "h1") }), h2: (props) => import_react12.default.createElement(H2, { ...nameSpaceClassNames(props, "h2") }), h3: (props) => import_react12.default.createElement(H3, { ...nameSpaceClassNames(props, "h3") }), h4: (props) => import_react12.default.createElement(H4, { ...nameSpaceClassNames(props, "h4") }), h5: (props) => import_react12.default.createElement(H5, { ...nameSpaceClassNames(props, "h5") }), h6: (props) => import_react12.default.createElement(H6, { ...nameSpaceClassNames(props, "h6") }), pre: (props) => import_react12.default.createElement(Pre2, { ...nameSpaceClassNames(props, "pre") }), a: (props) => import_react12.default.createElement(A, { ...nameSpaceClassNames(props, "a") }), hr: (props) => import_react12.default.createElement(HR, { ...nameSpaceClassNames(props, "hr") }), dl: (props) => import_react12.default.createElement(DL, { ...nameSpaceClassNames(props, "dl") }), blockquote: (props) => import_react12.default.createElement(Blockquote, { ...nameSpaceClassNames(props, "blockquote") }), table: (props) => import_react12.default.createElement(Table2, { ...nameSpaceClassNames(props, "table") }), img: (props) => import_react12.default.createElement(Img, { ...nameSpaceClassNames(props, "img") }), div: (props) => import_react12.default.createElement(Div, { ...nameSpaceClassNames(props, "div") }), span: (props) => import_react12.default.createElement(Span, { ...nameSpaceClassNames(props, "span") }), li: (props) => import_react12.default.createElement(LI, { ...nameSpaceClassNames(props, "li") }), ul: (props) => import_react12.default.createElement(UL, { ...nameSpaceClassNames(props, "ul") }), ol: (props) => import_react12.default.createElement(OL, { ...nameSpaceClassNames(props, "ol") }), p: (props) => import_react12.default.createElement(P, { ...nameSpaceClassNames(props, "p") }), code: (props) => import_react12.default.createElement(Code2, { ...nameSpaceClassNames(props, "code") }), tt: (props) => import_react12.default.createElement(TT, { ...nameSpaceClassNames(props, "tt") }), resetwrapper: (props) => import_react12.default.createElement(ResetWrapper, { ...nameSpaceClassNames(props, "resetwrapper") }) };
var BadgeWrapper = import_theming30.styled.div(({ theme }) => ({ display: "inline-block", fontSize: 11, lineHeight: "12px", alignSelf: "center", padding: "4px 12px", borderRadius: "3em", fontWeight: theme.typography.weight.bold }), { svg: { height: 12, width: 12, marginRight: 4, marginTop: -2, path: { fill: "currentColor" } } }, ({ theme, status }) => {
  switch (status) {
    case "critical":
      return { color: theme.color.critical, background: theme.background.critical };
    case "negative":
      return { color: theme.color.negativeText, background: theme.background.negative, boxShadow: theme.base === "light" ? `inset 0 0 0 1px ${curriedTransparentize$1(0.9, theme.color.negativeText)}` : "none" };
    case "warning":
      return { color: theme.color.warningText, background: theme.background.warning, boxShadow: theme.base === "light" ? `inset 0 0 0 1px ${curriedTransparentize$1(0.9, theme.color.warningText)}` : "none" };
    case "neutral":
      return { color: theme.color.dark, background: theme.color.mediumlight, boxShadow: theme.base === "light" ? `inset 0 0 0 1px ${curriedTransparentize$1(0.9, theme.color.dark)}` : "none" };
    case "positive":
      return { color: theme.color.positiveText, background: theme.background.positive, boxShadow: theme.base === "light" ? `inset 0 0 0 1px ${curriedTransparentize$1(0.9, theme.color.positiveText)}` : "none" };
    default:
      return {};
  }
});
var icons = { user: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0ZM2.67 11.15c.7-1 2.6-1.81 3.2-1.9.22-.04.23-.66.23-.66s-.67-.66-.81-1.55c-.4 0-.63-.94-.24-1.27l-.02-.13c-.06-.6-.28-2.6 1.97-2.6s2.03 2 1.97 2.6l-.02.13c.4.33.15 1.27-.24 1.27-.14.89-.8 1.55-.8 1.55s0 .62.22.66c.6.09 2.5.9 3.2 1.9a6 6 0 1 0-8.66 0Z" })), useralt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7.27 13.16a11.39 11.39 0 0 0 5.18-1.23v-.25c0-1.57-3.24-3-4.1-3.13-.27-.05-.28-.79-.28-.79s.8-.78.96-1.83c.47 0 .75-1.12.29-1.52.02-.41.6-3.25-2.32-3.25S4.65 4 4.67 4.41c-.46.4-.17 1.52.29 1.52.17 1.05.96 1.83.96 1.83s0 .74-.27.79c-.86.13-4.04 1.53-4.1 3.08a11.44 11.44 0 0 0 5.72 1.53Z" })), useradd: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1.18 11.9c-.4-.17-.8-.36-1.18-.58.06-1.44 3.02-2.74 3.82-2.87.25-.04.26-.73.26-.73s-.74-.73-.9-1.7c-.43 0-.7-1.05-.27-1.42l-.01-.14c-.07-.67-.31-2.88 2.18-2.88 2.48 0 2.24 2.2 2.17 2.88l-.01.14c.43.37.16 1.41-.27 1.41-.16.98-.9 1.71-.9 1.71s.01.69.26.73c.8.13 3.82 1.46 3.82 2.91v.24a10.63 10.63 0 0 1-8.97.3ZM11.5 2.16c.28 0 .5.22.5.5v1.5h1.5a.5.5 0 0 1 0 1H12v1.5a.5.5 0 0 1-1 0v-1.5H9.5a.5.5 0 1 1 0-1H11v-1.5c0-.28.22-.5.5-.5Z" })), users: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M9.21 11.62A10.59 10.59 0 0 1 0 11.07c.06-1.35 2.93-2.58 3.7-2.7.25-.03.26-.68.26-.68s-.72-.69-.87-1.6c-.42 0-.68-.99-.26-1.33 0-.03 0-.08-.02-.14-.07-.63-.3-2.71 2.12-2.71 2.41 0 2.18 2.08 2.11 2.71l-.01.14c.42.34.16 1.32-.26 1.32-.16.92-.87 1.6-.87 1.6s0 .66.25.7c.78.11 3.7 1.36 3.7 2.73v.22l-.64.3Z" }), import_react18.default.createElement("path", { d: "M8.81 8.42a9.64 9.64 0 0 0-.74-.4 5.2 5.2 0 0 1 1.7-.76c.17-.02.17-.47.17-.47s-.49-.47-.6-1.1c-.28 0-.46-.68-.17-.91l-.01-.1c-.05-.43-.2-1.86 1.45-1.86 1.66 0 1.5 1.43 1.45 1.86v.1c.28.23.1.9-.18.9-.11.64-.6 1.11-.6 1.11s0 .45.17.47c.54.08 2.55.94 2.55 1.89v.62a10.6 10.6 0 0 1-3.3.56 2.97 2.97 0 0 0-.58-.88c-.37-.41-.85-.76-1.31-1.03Z" })), profile: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M9.1 7.35a5.06 5.06 0 0 1-4.52-.28C4.6 6.4 6.02 5.77 6.4 5.7c.12-.02.12-.35.12-.35s-.35-.34-.43-.81c-.2 0-.33-.5-.12-.67l-.01-.07C5.93 3.48 5.81 2.42 7 2.42S8.07 3.48 8.04 3.8v.07c.2.17.07.67-.13.67-.08.47-.43.81-.43.81s0 .33.12.35c.38.06 1.82.7 1.82 1.4v.1c-.1.06-.2.1-.31.15Zm-5.35 3.9c0-.14.11-.25.25-.25h6a.25.25 0 1 1 0 .5H4a.25.25 0 0 1-.25-.25ZM4 9a.25.25 0 0 0 0 .5h6a.25.25 0 1 0 0-.5H4Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1 .5c0-.28.22-.5.5-.5h11c.28 0 .5.22.5.5v13a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5V.5ZM2 13V1h10v12H2Z" })), facehappy: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M3.97 8.75a.5.5 0 0 0-.87.5 4.5 4.5 0 0 0 7.8 0 .5.5 0 1 0-.87-.5 3.5 3.5 0 0 1-6.06 0ZM5.5 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM9.5 6a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0Zm-1 0A6 6 0 1 1 1 7a6 6 0 0 1 12 0Z" })), faceneutral: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M4.5 9a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1h-5ZM5.5 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM9.5 6a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0Zm-1 0A6 6 0 1 1 1 7a6 6 0 0 1 12 0Z" })), facesad: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M3.97 10.25a.5.5 0 0 1-.87-.5 4.5 4.5 0 0 1 7.8 0 .5.5 0 1 1-.87.5 3.5 3.5 0 0 0-6.06 0ZM5.5 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM9.5 6a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0Zm-1 0A6 6 0 1 1 1 7a6 6 0 0 1 12 0Z" })), accessibility: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M3.53 4.84a.5.5 0 0 1 .63-.31l2.05.68a2.5 2.5 0 0 0 1.58 0l2.05-.68a.5.5 0 0 1 .32.94L7.7 6.3a.3.3 0 0 0-.21.29v.24c0 .7.16 1.39.48 2.01l.97 1.95a.5.5 0 1 1-.9.44L7 9.12l-1.05 2.1a.5.5 0 1 1-.9-.44l.97-1.95a4.5 4.5 0 0 0 .48-2.01v-.24a.3.3 0 0 0-.2-.29l-2.46-.82a.5.5 0 0 1-.31-.63Z" }), import_react18.default.createElement("path", { d: "M7 4.5a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M7 14A7 7 0 1 0 7 0a7 7 0 0 0 0 14Zm0-1A6 6 0 1 0 7 1a6 6 0 0 0 0 12Z" })), accessibilityalt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7 14A7 7 0 1 0 7 0a7 7 0 0 0 0 14ZM8 3.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM3.53 4.84a.5.5 0 0 1 .63-.31l2.05.68a2.5 2.5 0 0 0 1.58 0l2.05-.68a.5.5 0 0 1 .32.94L7.7 6.3a.3.3 0 0 0-.21.29v.24c0 .7.16 1.39.48 2.01l.97 1.95a.5.5 0 1 1-.9.44L7 9.12l-1.05 2.1a.5.5 0 1 1-.9-.44l.97-1.95a4.5 4.5 0 0 0 .48-2.01v-.24a.3.3 0 0 0-.2-.29l-2.46-.82a.5.5 0 0 1-.31-.63Z" })), arrowup: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "m7.35 2.9 5.5 5.5a.5.5 0 0 1-.7.7L7 3.96 1.85 9.1a.5.5 0 1 1-.7-.7l5.5-5.5c.2-.2.5-.2.7 0Z" })), arrowdown: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "m1.15 5.6 5.5 5.5c.2.2.5.2.7 0l5.5-5.5a.5.5 0 0 0-.7-.7L7 10.04 1.85 4.9a.5.5 0 1 0-.7.7Z" })), arrowleft: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M2.76 7.1c.02.09.06.18.14.25l5.5 5.5a.5.5 0 0 0 .7-.7L3.96 7 9.1 1.85a.5.5 0 1 0-.7-.7l-5.5 5.5a.5.5 0 0 0-.14.45Z" })), arrowright: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "m11.1 7.35-5.5 5.5a.5.5 0 0 1-.7-.7L10.04 7 4.9 1.85a.5.5 0 1 1 .7-.7l5.5 5.5c.2.2.2.5 0 .7Z" })), arrowupalt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M11.85 4.65 7.35.15a.5.5 0 0 0-.7 0l-4.5 4.5a.5.5 0 1 0 .7.7L6.5 1.71V13.5a.5.5 0 0 0 1 0V1.7l3.65 3.65a.5.5 0 0 0 .7-.7Z" })), arrowdownalt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7.5.5a.5.5 0 0 0-1 0v11.8L2.85 8.64a.5.5 0 1 0-.7.7l4.5 4.5A.5.5 0 0 0 7 14a.5.5 0 0 0 .35-.15l4.5-4.5a.5.5 0 0 0-.7-.7L7.5 12.29V.5Z" })), arrowleftalt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5.35 2.15c.2.2.2.5 0 .7L1.71 6.5H13.5a.5.5 0 0 1 0 1H1.7l3.65 3.65a.5.5 0 0 1-.7.7l-4.5-4.5a.5.5 0 0 1 0-.7l4.5-4.5c.2-.2.5-.2.7 0Z" })), arrowrightalt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M8.65 2.15c.2-.2.5-.2.7 0l4.5 4.5c.2.2.2.5 0 .7l-4.5 4.5a.5.5 0 0 1-.7-.7l3.64-3.65H.5a.5.5 0 0 1 0-1h11.8L8.64 2.85a.5.5 0 0 1 0-.7Z" })), expandalt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "m7.35.15 4 4a.5.5 0 0 1-.7.7L7 1.21 3.35 4.85a.5.5 0 1 1-.7-.7l4-4c.2-.2.5-.2.7 0ZM11.35 9.15c.2.2.2.5 0 .7l-4 4a.5.5 0 0 1-.7 0l-4-4a.5.5 0 1 1 .7-.7L7 12.79l3.65-3.64c.2-.2.5-.2.7 0Z" })), collapse: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M3.354.146a.5.5 0 1 0-.708.708l4 4a.5.5 0 0 0 .708 0l4-4a.5.5 0 0 0-.708-.708L7 3.793 3.354.146Zm3.292 9a.5.5 0 0 1 .708 0l4 4a.5.5 0 0 1-.708.708L7 10.207l-3.646 3.647a.5.5 0 0 1-.708-.708l4-4Z" })), expand: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1.5 1h2a.5.5 0 0 1 0 1h-.8l3.15 3.15a.5.5 0 1 1-.7.7L2 2.71v.79a.5.5 0 0 1-1 0v-2c0-.28.22-.5.5-.5ZM10 1.5c0-.28.22-.5.5-.5h2c.28 0 .5.22.5.5v2a.5.5 0 0 1-1 0v-.8L8.85 5.86a.5.5 0 1 1-.7-.7L11.29 2h-.79a.5.5 0 0 1-.5-.5ZM12.5 10c.28 0 .5.22.5.5v2a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h.8L8.14 8.85a.5.5 0 1 1 .7-.7L12 11.29v-.79c0-.28.22-.5.5-.5ZM2 11.3v-.8a.5.5 0 0 0-1 0v2c0 .28.22.5.5.5h2a.5.5 0 0 0 0-1h-.8l3.15-3.15a.5.5 0 1 0-.7-.7L2 11.29Z" })), unfold: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "m6.65.15-1.5 1.5a.5.5 0 1 0 .7.7l.65-.64V5a.5.5 0 0 0 1 0V1.7l.65.65a.5.5 0 1 0 .7-.7L7.35.15a.5.5 0 0 0-.7 0Z" }), import_react18.default.createElement("path", { d: "M1.3 4.04a.5.5 0 0 0-.16.82L3.3 7 1.15 9.15a.5.5 0 0 0 .35.85h3a.5.5 0 0 0 0-1H2.7l1.5-1.5h5.6l2.35 2.35a.5.5 0 0 0 .7-.7L10.71 7l2.14-2.15.11-.54-.1.54A.5.5 0 0 0 13 4.5a.5.5 0 0 0-.14-.35.5.5 0 0 0-.36-.15h-3a.5.5 0 0 0 0 1h1.8L9.8 6.5H4.2L2.7 5h1.8a.5.5 0 0 0 0-1h-3a.5.5 0 0 0-.2.04Z" }), import_react18.default.createElement("path", { d: "M7 8.5c.28 0 .5.22.5.5v3.3l.65-.65a.5.5 0 0 1 .7.7l-1.5 1.5a.5.5 0 0 1-.7 0l-1.5-1.5a.5.5 0 0 1 .7-.7l.65.64V9c0-.28.22-.5.5-.5ZM9 9.5c0-.28.22-.5.5-.5h3a.5.5 0 0 1 0 1h-3a.5.5 0 0 1-.5-.5Z" })), transfer: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M10.65 2.65c.2-.2.5-.2.7 0l1.5 1.5c.2.2.2.5 0 .7l-1.5 1.5a.5.5 0 0 1-.7-.7l.64-.65H1.5a.5.5 0 0 1 0-1h9.8l-.65-.65a.5.5 0 0 1 0-.7ZM3.35 8.35 2.71 9h9.79a.5.5 0 0 1 0 1H2.7l.65.65a.5.5 0 0 1-.7.7l-1.5-1.5a.5.5 0 0 1 0-.7l1.5-1.5a.5.5 0 1 1 .7.7Z" })), redirect: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1.5 1c.28 0 .5.22.5.5V10a2 2 0 0 0 4 0V4a3 3 0 0 1 6 0v7.8l1.15-1.15a.5.5 0 0 1 .7.7l-2 2a.5.5 0 0 1-.7 0l-2-2a.5.5 0 0 1 .7-.7L11 11.79V4a2 2 0 1 0-4 0v6a3 3 0 0 1-6 0V1.5c0-.28.22-.5.5-.5Z" })), undo: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1.15 3.85a.5.5 0 0 1 0-.7l2-2a.5.5 0 1 1 .7.7L2.71 3H9a4 4 0 0 1 0 8H3a.5.5 0 0 1 0-1h6a3 3 0 1 0 0-6H2.7l1.15 1.15a.5.5 0 1 1-.7.7l-2-2Z" })), reply: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M4.35 2.15c.2.2.2.5 0 .7L1.71 5.5H9.5A4.5 4.5 0 0 1 14 10v1.5a.5.5 0 0 1-1 0V10a3.5 3.5 0 0 0-3.5-3.5H1.7l2.65 2.65a.5.5 0 1 1-.7.7l-3.5-3.5a.5.5 0 0 1 0-.7l3.5-3.5c.2-.2.5-.2.7 0Z" })), sync: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5.5 1A.5.5 0 0 0 5 .5H2a.5.5 0 0 0 0 1h1.53a6.5 6.5 0 0 0 2.39 11.91.5.5 0 1 0 .16-.99A5.5 5.5 0 0 1 4.5 2.1V4a.5.5 0 0 0 1 0V1ZM7.5 1a.5.5 0 0 1 .58-.41 6.5 6.5 0 0 1 2.39 11.91H12a.5.5 0 0 1 0 1H9a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 1 0v1.9A5.5 5.5 0 0 0 7.92 1.58.5.5 0 0 1 7.5 1Z" })), upload: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M8.65 5.85 7.5 4.71v5.79a.5.5 0 0 1-1 0V4.7L5.35 5.86a.5.5 0 1 1-.7-.7l2-2c.2-.2.5-.2.7 0l2 2a.5.5 0 1 1-.7.7Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0Zm-1 0A6 6 0 1 1 1 7a6 6 0 0 1 12 0Z" })), download: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5.35 8.15 6.5 9.29V3.5a.5.5 0 0 1 1 0v5.8l1.15-1.15a.5.5 0 1 1 .7.7l-2 2a.5.5 0 0 1-.7 0l-2-2a.5.5 0 1 1 .7-.7Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M0 7a7 7 0 1 1 14 0A7 7 0 0 1 0 7Zm1 0a6 6 0 1 1 12 0A6 6 0 0 1 1 7Z" })), back: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5.85 5.35 4.71 6.5h5.79a.5.5 0 0 1 0 1H4.7l1.15 1.15a.5.5 0 1 1-.7.7l-2-2a.5.5 0 0 1 0-.7l2-2a.5.5 0 1 1 .7.7Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M7 0a7 7 0 1 1 0 14A7 7 0 0 1 7 0Zm0 1a6 6 0 1 1 0 12A6 6 0 0 1 7 1Z" })), proceed: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M3.5 6.5h5.8L8.14 5.35a.5.5 0 1 1 .7-.7l2 2c.2.2.2.5 0 .7l-2 2a.5.5 0 1 1-.7-.7L9.29 7.5H3.5a.5.5 0 0 1 0-1Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M7 14A7 7 0 1 1 7 0a7 7 0 0 1 0 14Zm0-1A6 6 0 1 1 7 1a6 6 0 0 1 0 12Z" })), refresh: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7.1.5H7a6.5 6.5 0 1 0 6.41 7.58.5.5 0 1 0-.99-.16A5.47 5.47 0 0 1 7 12.5a5.5 5.5 0 0 1 0-11 5.5 5.5 0 0 1 4.9 3H10a.5.5 0 0 0 0 1h3a.5.5 0 0 0 .5-.5V2a.5.5 0 0 0-1 0v1.53A6.5 6.5 0 0 0 7.1.5Z" })), globe: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M14 7A7 7 0 1 0 0 7a7 7 0 0 0 14 0Zm-6.53 5.74c-.24.23-.4.26-.47.26-.08 0-.23-.03-.47-.26-.23-.24-.5-.62-.73-1.18A11.57 11.57 0 0 1 5 7.5h4a11.57 11.57 0 0 1-.8 4.06c-.24.56-.5.94-.73 1.18ZM8.99 6.5H5.01c.05-1.62.35-3.04.79-4.06.24-.56.5-.94.73-1.18.24-.23.4-.26.47-.26.08 0 .23.03.47.26.23.24.5.62.73 1.18.44 1.02.74 2.44.8 4.06Zm1 1c-.06 2.18-.56 4.08-1.28 5.25a6 6 0 0 0 4.27-5.25H9.99Zm2.99-1H9.99c-.06-2.18-.56-4.08-1.28-5.25a6 6 0 0 1 4.27 5.25ZM4 6.5c.06-2.18.56-4.08 1.28-5.25A6 6 0 0 0 1.02 6.5h2.99Zm-2.99 1a6 6 0 0 0 4.27 5.25c-.72-1.17-1.22-3.07-1.28-5.25H1.02Z" })), compass: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M10.09 3.4 5.95 5.8a.37.37 0 0 0-.11.09.38.38 0 0 0-.04.05l-2.4 4.15a.37.37 0 0 0 0 .38c.1.18.33.24.5.14l4.15-2.4a.37.37 0 0 0 .15-.15l2.4-4.15a.37.37 0 0 0-.03-.44.37.37 0 0 0-.48-.07ZM4.75 9.25 7.6 7.6 6.4 6.4 4.75 9.25Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0Zm-1 0A6 6 0 1 1 1 7a6 6 0 0 1 12 0Z" })), location: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M0 7a7 7 0 1 1 14 0A7 7 0 0 1 0 7Zm6.5 3.5v2.48A6 6 0 0 1 1.02 7.5H3.5a.5.5 0 0 0 0-1H1.02A6 6 0 0 1 6.5 1.02V3.5a.5.5 0 0 0 1 0V1.02a6 6 0 0 1 5.48 5.48H10.5a.5.5 0 0 0 0 1h2.48a6 6 0 0 1-5.48 5.48V10.5a.5.5 0 0 0-1 0Z" })), pin: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M9 5a2 2 0 1 1-4 0 2 2 0 0 1 4 0ZM8 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M12 5A5 5 0 0 0 2 5c0 2.63 2.27 6.15 4.65 8.64.2.2.5.2.7 0C9.73 11.15 12 7.64 12 5ZM7 1a4 4 0 0 1 4 4c0 1.06-.47 2.42-1.3 3.88A21.23 21.23 0 0 1 7 12.55c-1-1.1-1.97-2.39-2.7-3.67A8.46 8.46 0 0 1 3 5a4 4 0 0 1 4-4Z" })), time: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7 2c.28 0 .5.22.5.5v4H10a.5.5 0 0 1 0 1H7a.5.5 0 0 1-.5-.5V2.5c0-.28.22-.5.5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M7 14A7 7 0 1 0 7 0a7 7 0 0 0 0 14Zm0-1A6 6 0 1 0 7 1a6 6 0 0 0 0 12Z" })), dashboard: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M9.8 4.1a.5.5 0 0 1 .1.7L7.92 7.58A1 1 0 1 1 7.1 7l2-2.8a.5.5 0 0 1 .7-.12Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M2.07 12.97a7 7 0 1 1 9.86 0 12.96 12.96 0 0 0-9.86 0Zm9.58-1.18a6 6 0 1 0-9.3 0 13.98 13.98 0 0 1 9.3 0Z" })), timer: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7.5 4.5a.5.5 0 0 0-1 0v2.63a1 1 0 1 0 1 0V4.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M5.5.5c0-.28.22-.5.5-.5h2a.5.5 0 0 1 0 1h-.5v1.02c1.28.1 2.45.61 3.37 1.4l.78-.77a.5.5 0 0 1 .7.7l-.77.78a6 6 0 1 1-5.08-2.1V1H6a.5.5 0 0 1-.5-.5ZM7 3a5 5 0 1 0 0 10A5 5 0 0 0 7 3Z" })), home: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "m7.35 1.15 5.5 5.5a.5.5 0 0 1-.7.7L12 7.21v5.29a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V9H6v3.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V7.2l-.15.15a.5.5 0 1 1-.7-.7l1-1 4.5-4.5c.2-.2.5-.2.7 0ZM3 6.2V12h2V8.5c0-.28.22-.5.5-.5h3c.28 0 .5.22.5.5V12h2V6.2l-4-4-4 4Z" })), admin: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1.21 4.1a.5.5 0 0 1 .06-.04l5.48-3a.5.5 0 0 1 .5 0l5.48 3a.5.5 0 0 1 .27.39.5.5 0 0 1-.51.55H1.51a.5.5 0 0 1-.3-.9ZM3.46 4h7.08L7 2.07 3.46 4Z" }), import_react18.default.createElement("path", { d: "M4 6a.5.5 0 1 0-1 0v5a.5.5 0 0 0 1 0V6ZM11 6a.5.5 0 0 0-1 0v5a.5.5 0 0 0 1 0V6ZM5.75 5.5c.28 0 .5.22.5.5v5a.5.5 0 0 1-1 0V6c0-.28.22-.5.5-.5ZM8.75 6a.5.5 0 1 0-1 0v5a.5.5 0 0 0 1 0V6ZM1.5 12.5c0-.27.22-.5.5-.5h10a.5.5 0 0 1 0 1H2a.5.5 0 0 1-.5-.5Z" })), info: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7 5.5c.28 0 .5.22.5.5v4a.5.5 0 0 1-1 0V6c0-.28.22-.5.5-.5ZM7 4.5A.75.75 0 1 0 7 3a.75.75 0 0 0 0 1.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M7 14A7 7 0 1 0 7 0a7 7 0 0 0 0 14Zm0-1A6 6 0 1 0 7 1a6 6 0 0 0 0 12Z" })), question: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5.25 5.25A1.75 1.75 0 1 1 7 7a.5.5 0 0 0-.5.5V9a.5.5 0 0 0 1 0V7.95a2.75 2.75 0 1 0-3.25-2.7.5.5 0 0 0 1 0ZM7 11.5A.75.75 0 1 0 7 10a.75.75 0 0 0 0 1.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0Zm-1 0A6 6 0 1 1 1 7a6 6 0 0 1 12 0Z" })), support: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0Zm-3.52 4.9a5.97 5.97 0 0 1-6.96 0l1.45-1.45a3.98 3.98 0 0 0 4.06 0l1.45 1.44Zm-.03-2.87 1.44 1.45a5.97 5.97 0 0 0 0-6.96l-1.44 1.45a3.98 3.98 0 0 1 0 4.06ZM9.03 3.55l1.45-1.44a5.97 5.97 0 0 0-6.96 0l1.45 1.44a3.98 3.98 0 0 1 4.06 0ZM3.55 4.97 2.11 3.52a5.97 5.97 0 0 0 0 6.96l1.44-1.45a3.98 3.98 0 0 1 0-4.06ZM10 7a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" })), alert: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7 4.5c.28 0 .5.22.5.5v3.5a.5.5 0 0 1-1 0V5c0-.28.22-.5.5-.5ZM7.75 10.5a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M7.2 1.04a.5.5 0 0 1 .24.21l6.49 11a.5.5 0 0 1-.44.75H.51a.5.5 0 0 1-.5-.45.5.5 0 0 1 .06-.31l6.5-10.99a.5.5 0 0 1 .64-.2ZM7 2.48 1.38 12h11.24L7 2.48Z" })), email: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M0 2.5c0-.27.22-.5.5-.5h13c.28 0 .5.23.5.5v9a.5.5 0 0 1-.5.5H.5a.5.5 0 0 1-.5-.5v-9Zm1 1.02V11h12V3.52L7.31 7.89a.5.5 0 0 1-.52.07.5.5 0 0 1-.1-.07L1 3.52ZM12.03 3H1.97L7 6.87 12.03 3Z" })), phone: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "m7.76 8.13-.05.05a.2.2 0 0 1-.28.03A6.76 6.76 0 0 1 5.8 6.56a.21.21 0 0 1 .04-.27l.05-.05c.23-.2.54-.47.71-.96.17-.47-.02-1.04-.66-1.94-.26-.38-.72-.96-1.22-1.46-.68-.69-1.2-1-1.65-1a.98.98 0 0 0-.51.13A3.23 3.23 0 0 0 .9 3.42c-.13 1.1.26 2.37 1.17 3.78a16.68 16.68 0 0 0 4.55 4.6 6.57 6.57 0 0 0 3.53 1.32A3.2 3.2 0 0 0 13 11.46c.14-.24.24-.64-.07-1.18a7.8 7.8 0 0 0-1.73-1.8c-.64-.5-1.52-1.12-2.13-1.12a.97.97 0 0 0-.34.06c-.47.17-.74.46-.95.69l-.02.02Zm4.32 2.68a6.8 6.8 0 0 0-1.48-1.54h-.02c-.3-.25-.64-.49-.95-.67a2.7 2.7 0 0 0-.56-.24h-.01c-.23.09-.34.21-.56.45l-.02.02-.04.04a1.2 1.2 0 0 1-1.6.15 7.76 7.76 0 0 1-1.86-1.89l-.01-.01-.02-.02a1.21 1.21 0 0 1 .2-1.53l.06-.06.02-.02c.22-.2.35-.31.43-.53v-.02c0-.02 0-.06-.03-.14a3.7 3.7 0 0 0-.5-.88h-.01V3.9c-.23-.33-.65-.87-1.1-1.32H4c-.31-.32-.55-.5-.72-.6a.6.6 0 0 0-.22-.1h-.03a2.23 2.23 0 0 0-1.15 1.66c-.09.78.18 1.8 1.02 3.1a15.68 15.68 0 0 0 4.27 4.33l.02.01.02.02a5.57 5.57 0 0 0 2.97 1.11 2.2 2.2 0 0 0 1.93-1.14h.01v-.05a.57.57 0 0 0-.05-.12Z" })), link: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M11.84 2.16a2.25 2.25 0 0 0-3.18 0l-2.5 2.5c-.88.88-.88 2.3 0 3.18a.5.5 0 0 1-.7.7 3.25 3.25 0 0 1 0-4.59l2.5-2.5a3.25 3.25 0 0 1 4.59 4.6L10.48 8.1c.04-.44.01-.89-.09-1.32l1.45-1.45c.88-.88.88-2.3 0-3.18Z" }), import_react18.default.createElement("path", { d: "M3.6 7.2c-.1-.42-.12-.87-.08-1.31L1.45 7.95a3.25 3.25 0 1 0 4.6 4.6l2.5-2.5a3.25 3.25 0 0 0 0-4.6.5.5 0 0 0-.7.7c.87.89.87 2.31 0 3.2l-2.5 2.5a2.25 2.25 0 1 1-3.2-3.2l1.46-1.44Z" })), unlink: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "m1.45 7.95 1.3-1.3.71.7-1.3 1.3a2.25 2.25 0 1 0 3.18 3.2l1.3-1.31.71.7-1.3 1.3a3.25 3.25 0 0 1-4.6-4.59ZM12.55 6.05l-1.3 1.3-.71-.7 1.3-1.3a2.25 2.25 0 1 0-3.18-3.2l-1.3 1.31-.71-.7 1.3-1.3a3.25 3.25 0 0 1 4.6 4.59ZM1.85 1.15a.5.5 0 1 0-.7.7l11 11a.5.5 0 0 0 .7-.7l-11-11Z" })), bell: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M8 1.11a1 1 0 1 0-1.99 0A4.5 4.5 0 0 0 2.5 5.5v3.88l-.94 1.89a.5.5 0 0 0-.06.3.5.5 0 0 0 .51.43h3.58a1.5 1.5 0 1 0 2.82 0H12a.5.5 0 0 0 .45-.73l-.94-1.89V5.5A4.5 4.5 0 0 0 8 1.11ZM2.8 11h8.4l-.5-1H3.3l-.5 1Zm7.7-2V5.5a3.5 3.5 0 1 0-7 0V9h7Zm-4 3.5a.5.5 0 1 1 1 0 .5.5 0 0 1-1 0Z" })), rss: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1.5.5c0-.28.22-.5.5-.5a12 12 0 0 1 12 12 .5.5 0 0 1-1 0A11 11 0 0 0 2 1a.5.5 0 0 1-.5-.5Z" }), import_react18.default.createElement("path", { d: "M1.5 4.5c0-.28.22-.5.5-.5a8 8 0 0 1 8 8 .5.5 0 0 1-1 0 7 7 0 0 0-7-7 .5.5 0 0 1-.5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M5 11a2 2 0 1 1-4 0 2 2 0 0 1 4 0Zm-1 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z" })), sharealt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M2 1a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V7.5a.5.5 0 0 0-1 0V12H2V2h4.5a.5.5 0 0 0 0-1H2Z" }), import_react18.default.createElement("path", { d: "M7.35 7.36 12 2.7v1.8a.5.5 0 0 0 1 0v-3a.5.5 0 0 0-.5-.5h-3a.5.5 0 1 0 0 1h1.8L6.64 6.64a.5.5 0 1 0 .7.7Z" })), share: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M6.65.15c.2-.2.5-.2.7 0l2 2a.5.5 0 1 1-.7.7L7.5 1.72v6.8a.5.5 0 0 1-1 0V1.7L5.35 2.86a.5.5 0 1 1-.7-.71l2-2Z" }), import_react18.default.createElement("path", { d: "M2 4a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H9.5a.5.5 0 1 0 0 1H12v7H2V5h2.5a.5.5 0 0 0 0-1H2Z" })), circlehollow: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M7 13A6 6 0 1 0 7 1a6 6 0 0 0 0 12Zm0 1A7 7 0 1 0 7 0a7 7 0 0 0 0 14Z" })), circle: import_react18.default.createElement("path", { d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0Z" }), bookmarkhollow: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3.5 0h7c.28 0 .5.22.5.5v13a.5.5 0 0 1-.45.5.46.46 0 0 1-.38-.12L7 11.16l-3.17 2.72a.46.46 0 0 1-.38.12.5.5 0 0 1-.45-.5V.5c0-.28.22-.5.5-.5ZM4 12.41l2.66-2.28a.45.45 0 0 1 .38-.13c.1.01.2.05.29.12l2.67 2.3V1H4v11.41Z" })), bookmark: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3.5 0h7c.28 0 .5.22.5.5v13a.5.5 0 0 1-.45.5.46.46 0 0 1-.38-.12L7 11.16l-3.17 2.72a.46.46 0 0 1-.38.12.5.5 0 0 1-.45-.5V.5c0-.28.22-.5.5-.5Z" })), hearthollow: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M12.81 1.85 13 2a2.97 2.97 0 0 1 .75 1.17 4.39 4.39 0 0 1 .12 2.51 6.26 6.26 0 0 1-1.65 2.55l-4.78 4.6A.59.59 0 0 1 7 13a.67.67 0 0 1-.44-.17L1.78 8.22a7.84 7.84 0 0 1-1.25-1.6C.37 6.31.24 6 .14 5.67a4.32 4.32 0 0 1 .12-2.51 3.2 3.2 0 0 1 1.95-1.9c.47-.18 1-.27 1.57-.27.3 0 .61.04.91.14.3.09.59.21.86.36s.52.33.77.52c.24.19.47.38.68.58a7.56 7.56 0 0 1 1.46-1.1c.27-.15.55-.27.84-.36.3-.1.6-.14.9-.14.59 0 1.12.09 1.59.26.39.15.73.34 1.02.59ZM1.2 3.53A2.2 2.2 0 0 1 2.57 2.2M1.2 3.53c-.13.33-.2.72-.2 1.18 0 .22.03.45.1.68a3.97 3.97 0 0 0 .79 1.46c.19.23.38.45.59.65l4.51 4.36 4.52-4.35c.2-.2.4-.4.59-.65.18-.23.34-.47.49-.73.13-.23.23-.48.3-.73.08-.23.11-.46.11-.7 0-.45-.07-.84-.2-1.18-.12-.33-.3-.6-.51-.8v-.01c-.22-.2-.5-.38-.85-.51-.34-.13-.75-.2-1.24-.2-.2 0-.4.03-.6.09a4.95 4.95 0 0 0-1.9 1.22l-.68.67-.7-.65a9.97 9.97 0 0 0-.62-.53c-.2-.16-.42-.3-.63-.42h-.01c-.21-.12-.43-.22-.66-.29C4.2 2.03 4 2 3.77 2c-.48 0-.88.07-1.21.2" })), heart: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M12.81 1.85 13 2a2.97 2.97 0 0 1 .75 1.17 4.39 4.39 0 0 1 .12 2.51 6.26 6.26 0 0 1-1.65 2.55l-4.78 4.6A.59.59 0 0 1 7 13a.67.67 0 0 1-.44-.17L1.78 8.22a7.84 7.84 0 0 1-1.25-1.6C.37 6.31.24 6 .14 5.67a4.32 4.32 0 0 1 .12-2.51 3.2 3.2 0 0 1 1.95-1.9c.47-.18 1-.27 1.57-.27.3 0 .61.04.91.14.3.09.59.21.86.36s.52.33.77.52c.24.19.47.38.68.58a7.56 7.56 0 0 1 1.46-1.1c.27-.15.55-.27.84-.36.3-.1.6-.14.9-.14.59 0 1.12.09 1.59.26.39.15.73.34 1.02.59Z" })), starhollow: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M6.32.78a.75.75 0 0 1 1.36 0l1.63 3.54 3.87.46c.63.07.89.86.42 1.3l-2.86 2.64.76 3.81a.75.75 0 0 1-1.1.8L7 11.43l-3.4 1.9a.75.75 0 0 1-1.1-.8l.76-3.81L.4 6.07a.75.75 0 0 1 .42-1.3l3.87-.45L6.32.78ZM7 1.7 5.54 4.86c-.11.24-.34.4-.6.43l-3.46.42 2.56 2.37c.2.17.28.44.23.7l-.68 3.42 3.04-1.7c.23-.14.5-.14.74 0l3.04 1.7-.68-3.43a.75.75 0 0 1 .23-.7l2.56-2.36-3.47-.42a.75.75 0 0 1-.59-.43L7 1.7Z" })), star: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7.68.78a.75.75 0 0 0-1.36 0L4.69 4.32l-3.87.46a.75.75 0 0 0-.42 1.3l2.86 2.64-.76 3.81a.75.75 0 0 0 1.1.8l3.4-1.9 3.4 1.9a.75.75 0 0 0 1.1-.8l-.76-3.81 2.86-2.65a.75.75 0 0 0-.42-1.3L9.3 4.33 7.68.78Z" })), certificate: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M10 7.85A4.49 4.49 0 0 0 7 0a4.5 4.5 0 0 0-3 7.85V13a.5.5 0 0 0 .5.5.5.5 0 0 0 .35-.15L7 11.21l2.15 2.14A.5.5 0 0 0 10 13V7.85ZM7 8a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7Zm-.35 2.15c.2-.2.5-.2.7 0L9 11.79V8.53a4.48 4.48 0 0 1-4 0v3.26l1.65-1.64Z" })), verified: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M6.56 13.12a1 1 0 0 1 .88 0l.98.49a1 1 0 0 0 1.31-.43l.52-.97a1 1 0 0 1 .7-.51l1.08-.2a1 1 0 0 0 .81-1.1l-.15-1.1a1 1 0 0 1 .27-.82l.76-.8a1 1 0 0 0 0-1.37l-.76-.79a1 1 0 0 1-.27-.83l.15-1.08a1 1 0 0 0-.8-1.12l-1.09-.19a1 1 0 0 1-.7-.5L9.73.81A1 1 0 0 0 8.43.4l-1 .49a1 1 0 0 1-.87 0L5.58.39a1 1 0 0 0-1.31.43l-.52.97a1 1 0 0 1-.7.51l-1.08.2a1 1 0 0 0-.81 1.1l.15 1.1a1 1 0 0 1-.27.82l-.76.8a1 1 0 0 0 0 1.37l.76.79a1 1 0 0 1 .27.83l-.15 1.08a1 1 0 0 0 .8 1.12l1.09.19a1 1 0 0 1 .7.5l.52.98a1 1 0 0 0 1.3.43l1-.49Zm4.3-8.47c.19.2.19.5 0 .7l-4.5 4.5a.5.5 0 0 1-.71 0l-2.5-2.5a.5.5 0 1 1 .7-.7L6 8.79l4.15-4.14c.2-.2.5-.2.7 0Z" })), thumbsup: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M11 12.02c-.4.37-.91.56-1.56.56h-.88a5.5 5.5 0 0 1-1.3-.16c-.42-.1-.91-.25-1.47-.45-.3-.12-.63-.21-.95-.27H2.88a.84.84 0 0 1-.62-.26.84.84 0 0 1-.26-.61V6.45c0-.24.09-.45.26-.62a.84.84 0 0 1 .62-.25h1.87c.16-.11.47-.47.93-1.06.27-.35.51-.64.74-.88.1-.11.19-.3.24-.58.05-.28.12-.57.2-.87.1-.3.24-.55.43-.74a.87.87 0 0 1 .62-.25c.38 0 .72.07 1.03.22.3.15.54.38.7.7a2.94 2.94 0 0 1 .21 1.58 3 3 0 0 1-.3 1h1.2c.47 0 .88.17 1.23.52s.52.8.52 1.22c0 .29-.04.66-.34 1.12.05.15.07.3.07.47 0 .35-.09.68-.26.98.07.54-.07 1.08-.4 1.51a1.9 1.9 0 0 1-.57 1.5Zm.47-5.33a.96.96 0 0 0 .03-.25.74.74 0 0 0-.23-.51.68.68 0 0 0-.52-.23H7.93l.73-1.45a2 2 0 0 0 .21-.87c0-.44-.07-.7-.13-.82a.53.53 0 0 0-.24-.24 1.3 1.3 0 0 0-.54-.12.99.99 0 0 0-.14.28c-.08.27-.13.52-.18.76-.06.38-.2.77-.48 1.07v.01l-.02.01c-.2.2-.4.46-.67.8l-.61.76c-.15.17-.35.38-.54.51l-.26.18H5v4.13h.02c.38.08.76.18 1.12.32.53.2.98.33 1.35.42.36.09.71.13 1.07.13h.88c.43 0 .68-.11.87-.29a.9.9 0 0 0 .26-.7l-.02-.37.22-.3c.17-.23.25-.5.2-.78l-.04-.33.17-.3a.97.97 0 0 0 .13-.48c0-.09 0-.13-.02-.15l-.15-.46.26-.4c.1-.15.13-.25.15-.33ZM3.5 10.8a.5.5 0 1 0 0-1 .5.5 0 0 0 0 1Z" })), shield: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M11.76 2.08a.5.5 0 0 1 .24.42v6a.5.5 0 0 1-.17.38l-4.5 3.99a.5.5 0 0 1-.67 0l-4.49-4A.5.5 0 0 1 2 8.5V2.5c0-.18.1-.34.24-.42l.01-.02a2.5 2.5 0 0 1 .3-.16c.22-.1.52-.24.92-.37C4.27 1.26 5.44 1 7 1c1.56 0 2.73.26 3.53.53a6.97 6.97 0 0 1 1.22.53l.01.02ZM3 2.79v5.49l1.07.94 6.59-6.58-.44-.17C9.52 2.24 8.44 2 7 2c-1.44 0-2.52.24-3.22.47-.35.12-.6.24-.78.32Zm4 9.04L4.82 9.9 11 3.71v4.57l-4 3.55Z" })), basket: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M10.35 2.85a.5.5 0 1 0-.7-.7l-3 3a.5.5 0 1 0 .7.7l3-3Z" }), import_react18.default.createElement("path", { d: "M2.09 6H4.5a.5.5 0 0 0 0-1H1.8a.75.75 0 0 0-.74.87l.8 4.88A1.5 1.5 0 0 0 3.36 12h7.3a1.5 1.5 0 0 0 1.48-1.25l.81-4.88A.75.75 0 0 0 12.2 5H10a.5.5 0 0 0 0 1h1.91l-.76 4.58a.5.5 0 0 1-.5.42h-7.3a.5.5 0 0 1-.5-.42L2.1 6Z" }), import_react18.default.createElement("path", { d: "M4.5 7c.28 0 .5.22.5.5v2a.5.5 0 0 1-1 0v-2c0-.28.22-.5.5-.5ZM10 7.5a.5.5 0 0 0-1 0v2a.5.5 0 0 0 1 0v-2ZM6.5 9.5v-2a.5.5 0 0 1 1 0v2a.5.5 0 0 1-1 0Z" })), beaker: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M4.5 2h.75v3.87l-3.03 5.26c-.48.83.12 1.87 1.08 1.87h7.4c.96 0 1.57-1.04 1.08-1.87L8.75 5.87V2h.75a.5.5 0 0 0 0-1h-5a.5.5 0 0 0 0 1Zm1.75 4V2h1.5v4.13l.07.12 1 1.75H5.18l1.01-1.75.07-.12V6ZM4.6 9l-1.52 2.63c-.1.16.03.37.22.37h7.4c.2 0 .31-.2.22-.37L9.4 9H4.6Z" })), hourglass: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7.5 10.5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3.5 1a.5.5 0 0 0-.5.5c0 1.06.14 1.9.68 2.97.34.7.86 1.5 1.6 2.53a16.53 16.53 0 0 0-1.8 2.96A6 6 0 0 0 3 12.49v.01a.5.5 0 0 0 .5.5h7a.5.5 0 0 0 .5-.5 6 6 0 0 0-.48-2.54c-.34-.8-.9-1.71-1.8-2.96a19.78 19.78 0 0 0 1.6-2.53c.54-1.08.68-1.9.68-2.97a.5.5 0 0 0-.5-.5h-7Zm6.49 11a4.68 4.68 0 0 0-.39-1.65c-.27-.65-.73-1.4-1.5-2.5a133 133 0 0 1-.75 1 .5.5 0 0 1-.56.1.5.5 0 0 1-.2-.16l-.7-.94a14.36 14.36 0 0 0-1.5 2.5A4.68 4.68 0 0 0 4.02 12H10ZM6.3 6.72l.7.94a90.06 90.06 0 0 0 .7-.96c.49-.67.87-1.22 1.17-1.7H5.13A32.67 32.67 0 0 0 6.3 6.72ZM4.56 4h4.88c.36-.73.5-1.31.55-2H4c.04.69.19 1.27.55 2Z" })), flag: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M11.5 1h-9a.5.5 0 0 0-.5.5v11a.5.5 0 0 0 1 0V8h8.5a.5.5 0 0 0 .35-.85L9.21 4.5l2.64-2.65A.5.5 0 0 0 11.5 1ZM8.15 4.15 10.29 2H3v5h7.3L8.14 4.85a.5.5 0 0 1 0-.7Z" })), cloudhollow: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M10 7V6a3 3 0 0 0-5.9-.74l-.18.68-.7.07A2.5 2.5 0 0 0 3.5 11h3.19l.07-.01h.08L7 11h4a2 2 0 1 0 0-4h-1ZM3.12 5.02A3.5 3.5 0 0 0 3.5 12H11a3 3 0 1 0 0-6 4 4 0 0 0-7.88-.98Z" })), cloud: import_react18.default.createElement("path", { d: "M7 2a4 4 0 0 1 4 4 3 3 0 1 1 0 6H3.5a3.5 3.5 0 0 1-.38-6.98A4 4 0 0 1 7 2Z" }), edit: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "m13.85 2.15-2-2a.5.5 0 0 0-.7 0l-1.5 1.5-9 9a.5.5 0 0 0-.14.26L0 13.39a.5.5 0 0 0 .14.46.5.5 0 0 0 .46.14l2.48-.5a.5.5 0 0 0 .27-.14l9-9 1.5-1.5a.5.5 0 0 0 0-.7ZM12 3.29l.8-.79-1.3-1.3-.8.8L12 3.3Zm-2-.58L1.7 11 3 12.3 11.3 4 10 2.7ZM1.14 12.86l.17-.85.68.68-.85.17Z" })), cog: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5.59 5.59a2 2 0 0 1 3.27 2.14.5.5 0 1 0 .93.37 3 3 0 1 0-1.7 1.7.5.5 0 1 0-.36-.94A2 2 0 0 1 5.6 5.6Z", fill: "#333" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M.94 6.53c.13.12.19.3.18.46 0 .17-.05.34-.18.47L0 8.39c.19.94.55 1.81 1.07 2.58h1.32c.18 0 .34.07.46.2.12.11.2.27.2.45v1.32c.76.51 1.62.88 2.55 1.06l.94-.94a.63.63 0 0 1 .45-.19h.03c.16 0 .33.07.45.19l.94.94a7.1 7.1 0 0 0 2.55-1.06v-1.33c0-.18.07-.35.2-.46.11-.12.27-.2.45-.2h1.33A7.1 7.1 0 0 0 14 8.4l-.95-.94a.64.64 0 0 1-.18-.47c0-.17.06-.34.18-.46l.95-.95a7.1 7.1 0 0 0-1.05-2.52h-1.34a.63.63 0 0 1-.46-.2.64.64 0 0 1-.2-.46V1.06A7.1 7.1 0 0 0 8.42 0l-.94.94a.63.63 0 0 1-.45.19H7a.63.63 0 0 1-.45-.19L5.6 0a7.1 7.1 0 0 0-2.56 1.06v1.33c0 .18-.07.34-.2.46a.63.63 0 0 1-.45.2H1.06A7.1 7.1 0 0 0 0 5.59l.94.94Zm.7 1.63c.33-.32.49-.75.48-1.17 0-.42-.15-.85-.47-1.17l-.54-.54c.12-.43.3-.85.51-1.23h.77c.46 0 .87-.2 1.17-.5.3-.29.48-.7.48-1.16v-.77c.4-.22.81-.39 1.25-.52l.54.55c.33.32.75.48 1.16.48h.03c.42 0 .84-.16 1.16-.48l.54-.54c.44.12.85.3 1.24.5v.8c0 .45.19.87.49 1.16.3.3.7.5 1.16.5h.78c.2.37.38.78.5 1.2l-.54.55c-.33.32-.49.75-.48 1.17 0 .42.15.85.48 1.17l.55.55c-.13.44-.3.85-.52 1.24h-.77c-.45 0-.87.2-1.16.5-.3.29-.5.7-.5 1.16v.77c-.38.21-.8.39-1.23.51l-.54-.54a1.64 1.64 0 0 0-1.16-.48H7c-.41 0-.83.16-1.16.48l-.54.55a6.1 6.1 0 0 1-1.25-.52v-.76c0-.45-.19-.87-.48-1.16-.3-.3-.71-.5-1.17-.5h-.76a6.1 6.1 0 0 1-.53-1.25l.55-.55Z" })), nut: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5.59 8.41a2 2 0 1 1 3.27-.68.5.5 0 1 0 .93.37 3 3 0 1 0-1.7 1.7.5.5 0 0 0-.36-.94 2 2 0 0 1-2.14-.45Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M6.5.29a1 1 0 0 1 1 0l5.06 2.92c.31.18.5.51.5.87v5.84a1 1 0 0 1-.5.87L7.5 13.7a1 1 0 0 1-1 0L1.44 10.8a1 1 0 0 1-.5-.87V4.08a1 1 0 0 1 .5-.87L6.5.3Zm.5.86 5.06 2.93v5.84L7 12.85 1.94 9.92V4.08L7 1.15Z" })), wrench: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M10.5 1c.44 0 .56.52.25.83l-.8.81c-.2.2-.2.52 0 .72l.69.7c.2.2.52.2.72 0l.8-.81c.32-.31.84-.2.84.25a2.5 2.5 0 0 1-3.41 2.33L2.7 12.7a1 1 0 0 1-1.42-1.42l6.88-6.88A2.5 2.5 0 0 1 10.5 1ZM2 12.5a.5.5 0 1 0 0-1 .5.5 0 0 0 0 1Z" })), ellipsis: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M4 7a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0ZM13 7a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0ZM7 8.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z" })), check: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M13.85 3.35a.5.5 0 0 0-.7-.7L5 10.79.85 6.65a.5.5 0 1 0-.7.7l4.5 4.5c.2.2.5.2.7 0l8.5-8.5Z" })), form: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M2 1a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V6.4a.5.5 0 0 0-1 0V12H2V2h7.5a.5.5 0 0 0 0-1H2Z" }), import_react18.default.createElement("path", { d: "m6.35 9.86 7.5-7.5a.5.5 0 0 0-.7-.71L6 8.8 3.85 6.65a.5.5 0 1 0-.7.7l2.5 2.5c.2.2.5.2.7 0Z" })), batchdeny: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M11.5 2a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2Zm-2.646.646a.5.5 0 0 1 0 .708L5.207 7l3.647 3.646a.5.5 0 0 1-.708.708L4.5 7.707.854 11.354a.5.5 0 0 1-.708-.708L3.793 7 .146 3.354a.5.5 0 1 1 .708-.708L4.5 6.293l3.646-3.647a.5.5 0 0 1 .708 0ZM11 7a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1h-2A.5.5 0 0 1 11 7Zm.5 4a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2Z" })), batchaccept: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M11.5 2a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2Zm-2.2.6a.5.5 0 0 1 .1.7l-5.995 7.993a.505.505 0 0 1-.37.206.5.5 0 0 1-.395-.152L.146 8.854a.5.5 0 1 1 .708-.708l2.092 2.093L8.6 2.7a.5.5 0 0 1 .7-.1ZM11 7a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1h-2A.5.5 0 0 1 11 7Zm.5 4a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2Z" })), controls: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M10.5 1c.28 0 .5.22.5.5V2h1.5a.5.5 0 0 1 0 1H11v.5a.5.5 0 0 1-1 0V3H1.5a.5.5 0 0 1 0-1H10v-.5c0-.28.22-.5.5-.5ZM1.5 11a.5.5 0 0 0 0 1H10v.5a.5.5 0 0 0 1 0V12h1.5a.5.5 0 0 0 0-1H11v-.5a.5.5 0 0 0-1 0v.5H1.5ZM1 7c0-.28.22-.5.5-.5H3V6a.5.5 0 0 1 1 0v.5h8.5a.5.5 0 0 1 0 1H4V8a.5.5 0 0 1-1 0v-.5H1.5A.5.5 0 0 1 1 7Z" })), plus: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7.5.5a.5.5 0 0 0-1 0v6h-6a.5.5 0 0 0 0 1h6v6a.5.5 0 0 0 1 0v-6h6a.5.5 0 0 0 0-1h-6v-6Z" })), closeAlt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M2.03.97A.75.75 0 0 0 .97 2.03L5.94 7 .97 11.97a.75.75 0 1 0 1.06 1.06L7 8.06l4.97 4.97a.75.75 0 1 0 1.06-1.06L8.06 7l4.97-4.97A.75.75 0 0 0 11.97.97L7 5.94 2.03.97Z" })), cross: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1.85 1.15a.5.5 0 1 0-.7.7L6.29 7l-5.14 5.15a.5.5 0 0 0 .7.7L7 7.71l5.15 5.14a.5.5 0 0 0 .7-.7L7.71 7l5.14-5.15a.5.5 0 0 0-.7-.7L7 6.29 1.85 1.15Z" })), trash: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5.5 4.5c.28 0 .5.22.5.5v5a.5.5 0 0 1-1 0V5c0-.28.22-.5.5-.5ZM9 5a.5.5 0 0 0-1 0v5a.5.5 0 0 0 1 0V5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M4.5.5c0-.28.22-.5.5-.5h4c.28 0 .5.22.5.5V2h3a.5.5 0 0 1 0 1H12v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V3h-.5a.5.5 0 0 1 0-1h3V.5ZM3 3v8a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V3H3Zm2.5-2h3v1h-3V1Z" })), pinalt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M13.44 4.44 9.56.56a1.5 1.5 0 0 0-2.12 0L7 1a1.41 1.41 0 0 0 0 2L5 5H3.66A4 4 0 0 0 .83 6.17l-.48.48a.5.5 0 0 0 0 .7l2.8 2.8-3 3a.5.5 0 0 0 .7.7l3-3 2.8 2.8c.2.2.5.2.7 0l.48-.48A4 4 0 0 0 9 10.34V9l2-2c.55.55 1.45.55 2 0l.44-.44a1.5 1.5 0 0 0 0-2.12ZM11 5.59l-3 3v1.75a3 3 0 0 1-.88 2.12L7 12.6 1.41 7l.13-.12A3 3 0 0 1 3.66 6H5.4l3-3-.7-.7a.41.41 0 0 1 0-.6l.44-.43c.2-.2.5-.2.7 0l3.88 3.88c.2.2.2.5 0 .7l-.44.44a.41.41 0 0 1-.58 0L11 5.6Z" })), unpin: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M13.44 4.44 9.56.56a1.5 1.5 0 0 0-2.12 0L7 1a1.41 1.41 0 0 0 0 2L5.7 4.3l.71.7 2-2-.7-.7a.41.41 0 0 1 0-.6l.44-.43c.2-.2.5-.2.7 0l3.88 3.88c.2.2.2.5 0 .7l-.44.44a.41.41 0 0 1-.58 0L11 5.6l-2 2 .7.7L11 7c.55.55 1.45.55 2 0l.44-.44a1.5 1.5 0 0 0 0-2.12ZM.83 6.17A4 4 0 0 1 3.59 5l1 1h-.93a3 3 0 0 0-2.12.88L1.4 7 7 12.59l.12-.13A3 3 0 0 0 8 10.34v-.93l1 1a4 4 0 0 1-1.17 2.76l-.48.48a.5.5 0 0 1-.7 0l-2.8-2.8-3 3a.5.5 0 0 1-.7-.7l3-3-2.8-2.8a.5.5 0 0 1 0-.7l.48-.48Zm1.02-5.02a.5.5 0 1 0-.7.7l11 11a.5.5 0 0 0 .7-.7l-11-11Z" })), add: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7 3c.28 0 .5.22.5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3c0-.28.22-.5.5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M7 14A7 7 0 1 0 7 0a7 7 0 0 0 0 14Zm0-1A6 6 0 1 0 7 1a6 6 0 0 0 0 12Z" })), subtract: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M3.5 6.5a.5.5 0 0 0 0 1h7a.5.5 0 0 0 0-1h-7Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0Zm-1 0A6 6 0 1 1 1 7a6 6 0 0 1 12 0Z" })), close: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M9.85 4.15c.2.2.2.5 0 .7L7.71 7l2.14 2.15a.5.5 0 0 1-.7.7L7 7.71 4.85 9.85a.5.5 0 0 1-.7-.7L6.29 7 4.15 4.85a.5.5 0 1 1 .7-.7L7 6.29l2.15-2.14c.2-.2.5-.2.7 0Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M7 14A7 7 0 1 0 7 0a7 7 0 0 0 0 14Zm0-1A6 6 0 1 0 7 1a6 6 0 0 0 0 12Z" })), delete: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0Zm-1 0a6 6 0 0 1-9.87 4.58l8.45-8.45A5.98 5.98 0 0 1 13 7ZM2.42 10.87l8.45-8.45a6 6 0 0 0-8.46 8.46Z" })), passed: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7 14A7 7 0 1 0 7 0a7 7 0 0 0 0 14Zm3.85-9.35c.2.2.2.5 0 .7l-4.5 4.5a.5.5 0 0 1-.7 0l-2.5-2.5a.5.5 0 1 1 .7-.7L6 8.79l4.15-4.14c.2-.2.5-.2.7 0Z" })), changed: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M7 14A7 7 0 1 0 7 0a7 7 0 0 0 0 14ZM3.5 6.5a.5.5 0 0 0 0 1h7a.5.5 0 0 0 0-1h-7Z" })), failed: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7 14A7 7 0 1 0 7 0a7 7 0 0 0 0 14Zm2.85-9.85c.2.2.2.5 0 .7L7.71 7l2.14 2.15a.5.5 0 0 1-.7.7L7 7.71 4.85 9.85a.5.5 0 0 1-.7-.7L6.29 7 4.15 4.85a.5.5 0 1 1 .7-.7L7 6.29l2.15-2.14c.2-.2.5-.2.7 0Z" })), clear: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M5 2h7a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H5a2 2 0 0 1-1.41-.59l-3-3a2 2 0 0 1 0-2.82l3-3A2 2 0 0 1 5 2Zm1.15 3.15c.2-.2.5-.2.7 0L8 6.29l1.15-1.14a.5.5 0 1 1 .7.7L8.71 7l1.14 1.15a.5.5 0 0 1-.7.7L8 7.71 6.85 8.85a.5.5 0 1 1-.7-.7L7.29 7 6.15 5.85a.5.5 0 0 1 0-.7Z" })), comment: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M3.5 5a.5.5 0 1 0 0 1h7a.5.5 0 0 0 0-1h-7ZM3 8.5c0-.27.22-.5.5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M12.5 12H5.7l-1.85 1.86a.5.5 0 0 1-.35.14.5.5 0 0 1-.5-.5V12H1.5a.5.5 0 0 1-.5-.5v-9c0-.27.22-.5.5-.5h11c.28 0 .5.23.5.5v9a.5.5 0 0 1-.5.5ZM2 11V3h10v8H2Z" })), commentadd: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7.5 5a.5.5 0 1 0-1 0v1.5H5a.5.5 0 1 0 0 1h1.5V9a.5.5 0 0 0 1 0V7.5H9a.5.5 0 0 0 0-1H7.5V5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3.7 13.97a.5.5 0 0 1-.7-.46V12H1.5a.5.5 0 0 1-.5-.5v-9c0-.28.22-.5.5-.5h11c.28 0 .5.22.5.5v9a.5.5 0 0 1-.5.5H5.7l-1.85 1.85a.5.5 0 0 1-.16.1ZM2 3v8h10V3H2Z" })), requestchange: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M9.85 6.65c.2.2.2.51 0 .7l-2 2a.5.5 0 1 1-.7-.7L8.3 7.5H4.5a.5.5 0 0 1 0-1h3.79L7.15 5.36a.5.5 0 1 1 .7-.71l2 2Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3.7 13.97a.5.5 0 0 1-.7-.46V12H1.5a.5.5 0 0 1-.5-.5v-9c0-.28.22-.5.5-.5h11c.28 0 .5.22.5.5v9a.5.5 0 0 1-.5.5H5.7l-1.85 1.85a.5.5 0 0 1-.16.1ZM2 3v8h10V3H2Z" })), comments: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M8.5 7a.5.5 0 0 0 0-1h-5a.5.5 0 1 0 0 1h5ZM9 8.5a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1 0-1h5c.28 0 .5.23.5.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M12 11.5V10h1.5a.5.5 0 0 0 .5-.5v-8a.5.5 0 0 0-.5-.5h-11a.5.5 0 0 0-.5.5V3H.5a.5.5 0 0 0-.5.5v8c0 .28.22.5.5.5H2v1.5a.5.5 0 0 0 .5.5.5.5 0 0 0 .35-.14L4.71 12h6.79a.5.5 0 0 0 .5-.5ZM3 3V2h10v7h-1V3.5a.5.5 0 0 0-.5-.5H3Zm-2 8V4h10v7H1Z" })), lock: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M8 8a1 1 0 0 1-.5.87v1.63a.5.5 0 0 1-1 0V8.87A1 1 0 1 1 8 8Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3 4a4 4 0 1 1 8 0v1h1.5c.28 0 .5.23.5.5v8a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-8c0-.27.22-.5.5-.5H3V4Zm7 1V4a3 3 0 1 0-6 0v1h6Zm2 1H2v7h10V6Z" })), unlock: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M6.5 8.87a1 1 0 1 1 1 0v1.63a.5.5 0 0 1-1 0V8.87Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7 1a3 3 0 0 0-3 3v1h8.5c.28 0 .5.23.5.5v8a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-8c0-.27.22-.5.5-.5H3V4a4 4 0 0 1 7.76-1.38.5.5 0 0 1-.94.34A3 3 0 0 0 7 1ZM2 6h10v7H2V6Z" })), key: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M11 4a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M7.5 8.53v.97a.5.5 0 0 1-.5.5H5.5v1.5a.5.5 0 0 1-.5.5H3.5v1.5a.5.5 0 0 1-.5.5H.5a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .15-.36l5.12-5.11a4.5 4.5 0 1 1 2.23 2.5ZM6 4.5a3.5 3.5 0 1 1 1.5 2.87c-.29-.2-1-.37-1 .48V9H5a.5.5 0 0 0-.5.5V11H3a.5.5 0 0 0-.5.5V13H1v-1.3l5.2-5.19c.15-.16.18-.4.1-.6A3.47 3.47 0 0 1 6 4.5Z" })), outbox: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7.35.15a.5.5 0 0 0-.7 0l-2 2a.5.5 0 1 0 .7.7L6.5 1.72v6.8a.5.5 0 0 0 1 0V1.7l1.15 1.15a.5.5 0 1 0 .7-.71l-2-2Z" }), import_react18.default.createElement("path", { d: "M2 7.5a.5.5 0 1 0-1 0v5c0 .28.22.5.5.5h11a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-1 0V12H2V7.5Z" })), credit: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M2.5 8a.5.5 0 1 0 0 1h3a.5.5 0 0 0 0-1h-3Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M0 11.5c0 .28.22.5.5.5h13a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5H.5a.5.5 0 0 0-.5.5v9ZM1 3v1h12V3H1Zm0 8h12V6H1v5Z" })), button: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1 3a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h3.5a.5.5 0 1 0 0-1H1V4h12v5h-1a.5.5 0 0 0 0 1h1a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1H1Z" }), import_react18.default.createElement("path", { d: "M6.45 7a.5.5 0 0 1 .3.08l3.48 2.02a.5.5 0 0 1 0 .87l-1.08.62.75 1.3a.75.75 0 0 1-1.3.75l-.75-1.3-1.07.62a.5.5 0 0 1-.67-.13.5.5 0 0 1-.1-.3L6 7.5a.5.5 0 0 1 .45-.5Z" })), type: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M4 1.5c0-.27.22-.5.5-.5h5a.5.5 0 1 1 0 1h-2v10h2a.5.5 0 0 1 0 1h-5a.5.5 0 0 1 0-1h2V2h-2a.5.5 0 0 1-.5-.5Z" }), import_react18.default.createElement("path", { d: "M0 4.5c0-.27.22-.5.5-.5h4a.5.5 0 1 1 0 1H1v4h3.5a.5.5 0 1 1 0 1h-4a.5.5 0 0 1-.5-.5v-5ZM9.5 4a.5.5 0 1 0 0 1H13v4H9.5a.5.5 0 1 0 0 1h4a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-.5-.5h-4Z" })), pointerdefault: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5.94 12.46c.11 0 .2-.06.25-.15l1.58-3.16 2.54 2.54c.04.05.1.07.19.07a.3.3 0 0 0 .2-.07l.8-.8a.27.27 0 0 0 0-.38L8.9 7.9l3.4-1.7c.06-.03.1-.07.12-.11a.22.22 0 0 0 .04-.14.33.33 0 0 0-.06-.16.17.17 0 0 0-.09-.07h-.02L1.91 1.55a.27.27 0 0 0-.35.36l4.15 10.37c.04.09.12.16.23.17Zm-.03 1h-.02a1.28 1.28 0 0 1-1.1-.8L.62 2.29A1.27 1.27 0 0 1 2.3.63l10.35 4.15c.52.18.79.65.81 1.11.04.53-.27.98-.7 1.2l-2.17 1.08L12.2 9.8c.5.5.5 1.3 0 1.8l-.8.8v.01c-.5.46-1.3.48-1.8-.01l-1.56-1.56-.95 1.92c-.23.45-.68.7-1.15.7h-.03Z" })), pointerhand: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M11.87 6v-.02c-.03-.27-.23-.48-.47-.5a.5.5 0 0 0-.53.5v1.41c0 .25-.22.47-.47.47a.48.48 0 0 1-.47-.47V5.17a.6.6 0 0 0 0-.05c-.02-.27-.23-.5-.47-.5a.5.5 0 0 0-.52.5v1.65l-.01.1a.49.49 0 0 1-.46.37.48.48 0 0 1-.47-.47V4.62a.6.6 0 0 0 0-.05c-.03-.27-.23-.48-.47-.5a.5.5 0 0 0-.53.5v2.2c0 .25-.22.47-.47.47a.49.49 0 0 1-.47-.47V1.75c-.02-.27-.22-.5-.47-.5a.5.5 0 0 0-.52.5v6.78c0 .25-.22.47-.47.47a.48.48 0 0 1-.47-.47v-.26a.78.78 0 0 0-.06-.31.65.65 0 0 0-.16-.22l-.2-.19A6.37 6.37 0 0 0 3.06 7h-.02c-.43-.34-.62-.25-.69-.2-.26.14-.29.5-.13.74l1.73 2.6v.01h-.01l-.04.02.05-.02s1.21 2.6 3.57 2.6c3.54 0 4.2-1.9 4.31-4.42.04-.6.04-1.19.03-1.78V6Zm.97 2.38c-.06 1.29-.26 2.67-1.08 3.72-.88 1.12-2.29 1.65-4.23 1.65a4.64 4.64 0 0 1-3.4-1.62 6.96 6.96 0 0 1-1.05-1.5v-.02L1.4 8.1A1.6 1.6 0 0 1 1.15 7c.05-.38.26-.8.69-1.04.2-.13.48-.23.85-.19.36.05.68.22.98.45.14.1.27.22.4.33v-4.8A1.5 1.5 0 0 1 5.63.25c.93.04 1.43.86 1.43 1.55v1.33c.17-.05.35-.07.53-.06h.02c.5.04.91.33 1.15.71a1.5 1.5 0 0 1 .74-.16c.66.03 1.12.46 1.32.97a1.5 1.5 0 0 1 .64-.1h.02c.85.06 1.39.8 1.39 1.55v.48c0 .6 0 1.24-.03 1.86Z" })), browser: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M.5 13a.5.5 0 0 1-.5-.5v-11c0-.27.22-.5.5-.5h13c.28 0 .5.23.5.5v11a.5.5 0 0 1-.5.5H.5Zm.5-1V4h12v8H1Zm1-9.5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Zm2 0a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Zm2 0a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Z" })), tablet: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3.5 0C2.67 0 2 .68 2 1.5v11c0 .83.67 1.5 1.5 1.5h7c.83 0 1.5-.67 1.5-1.5v-11c0-.82-.67-1.5-1.5-1.5h-7Zm0 1h7c.28 0 .5.23.5.5V11H3V1.5c0-.27.22-.5.5-.5ZM6 12a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1H6Z" })), mobile: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3 1.5C3 .68 3.67 0 4.5 0h5c.83 0 1.5.68 1.5 1.5v11c0 .83-.67 1.5-1.5 1.5h-5A1.5 1.5 0 0 1 3 12.5v-11ZM4 12V2h6v10H4Z" })), watch: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { key: "watch", fillRule: "evenodd", d: "M4 .5c0-.27.22-.5.5-.5h5a.5.5 0 0 1 0 1h-5A.5.5 0 0 1 4 .5ZM9.5 3h-5a.5.5 0 0 0-.5.5v7c0 .28.22.5.5.5h5a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.5-.5Zm-5-1C3.67 2 3 2.68 3 3.5v7c0 .83.67 1.5 1.5 1.5h5c.83 0 1.5-.67 1.5-1.5v-7c0-.82-.67-1.5-1.5-1.5h-5ZM7 4c.28 0 .5.23.5.5v2h1a.5.5 0 1 1 0 1H7a.5.5 0 0 1-.5-.5V4.5c0-.27.22-.5.5-.5Zm-2.5 9a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1h-5Z" })), sidebar: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M2.5 4.5c0-.27.22-.5.5-.5h1a.5.5 0 1 1 0 1H3a.5.5 0 0 1-.5-.5ZM3 6a.5.5 0 1 0 0 1h1a.5.5 0 0 0 0-1H3Zm-.5 2.5c0-.27.22-.5.5-.5h1a.5.5 0 1 1 0 1H3a.5.5 0 0 1-.5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1.5 13a.5.5 0 0 1-.5-.5v-11c0-.27.22-.5.5-.5h11c.28 0 .5.23.5.5v11a.5.5 0 0 1-.5.5h-11Zm.5-1V2h3v10H2ZM6 2h6v10H6V2Z" })), sidebaralt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M9.5 4.5c0-.27.22-.5.5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5ZM10 6a.5.5 0 1 0 0 1h1a.5.5 0 0 0 0-1h-1Zm-.5 2.5c0-.27.22-.5.5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1.5 13a.5.5 0 0 1-.5-.5v-11c0-.27.22-.5.5-.5h11c.28 0 .5.23.5.5v11a.5.5 0 0 1-.5.5h-11Zm.5-1V2h6v10H2ZM9 2h3v10H9V2Z" })), sidebaralttoggle: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M11.5 4.5A.5.5 0 0 0 11 4h-1a.5.5 0 1 0 0 1h1a.5.5 0 0 0 .5-.5ZM11 6a.5.5 0 0 1 0 1h-1a.5.5 0 0 1 0-1h1Zm.5 2.5A.5.5 0 0 0 11 8h-1a.5.5 0 1 0 0 1h1a.5.5 0 0 0 .5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1.5 13a.5.5 0 0 1-.5-.5v-11c0-.27.22-.5.5-.5h11c.28 0 .5.23.5.5v11a.5.5 0 0 1-.5.5h-11ZM9 12h3V2H9v10Zm-1 0H2V2h6v4.5H5.2l.66-.65a.5.5 0 1 0-.71-.7l-1.5 1.5a.5.5 0 0 0 0 .7l1.5 1.5a.5.5 0 1 0 .7-.7l-.64-.65H8V12Z" })), sidebartoggle: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M2.5 4.5c0-.27.22-.5.5-.5h1a.5.5 0 1 1 0 1H3a.5.5 0 0 1-.5-.5ZM3 6a.5.5 0 1 0 0 1h1a.5.5 0 0 0 0-1H3Zm-.5 2.5c0-.27.22-.5.5-.5h1a.5.5 0 1 1 0 1H3a.5.5 0 0 1-.5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1.5 13a.5.5 0 0 1-.5-.5v-11c0-.27.22-.5.5-.5h11c.28 0 .5.23.5.5v11a.5.5 0 0 1-.5.5h-11Zm.5-1V2h3v10H2Zm4 0V7.5h2.8l-.65.65a.5.5 0 1 0 .7.7l1.5-1.5a.5.5 0 0 0 0-.7l-1.5-1.5a.5.5 0 1 0-.7.7l.64.65H6V2h6v10H6Z" })), bottombar: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M3 10.5c0-.27.22-.5.5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5Zm3.5-.5a.5.5 0 0 0 0 1h1a.5.5 0 0 0 0-1h-1Zm2.5.5c0-.27.22-.5.5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1 1.5c0-.27.22-.5.5-.5h11c.28 0 .5.23.5.5v11a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11ZM2 8V2h10v6H2Zm10 1v3H2V9h10Z" })), bottombartoggle: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M3.5 10a.5.5 0 0 0 0 1h1a.5.5 0 0 0 0-1h-1Zm2.5.5c0-.27.22-.5.5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5Zm3.5-.5a.5.5 0 0 0 0 1h1a.5.5 0 0 0 0-1h-1Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1 12.5v-11c0-.27.22-.5.5-.5h11c.28 0 .5.23.5.5v11a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5Zm1-.5V9h10v3H2Zm4.5-4H2V2h10v6H7.5V5.21l.65.65a.5.5 0 1 0 .7-.71l-1.5-1.5a.5.5 0 0 0-.7 0l-1.5 1.5a.5.5 0 1 0 .7.7l.65-.64v2.8Z" })), cpu: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M5 5.5c0-.27.22-.5.5-.5h3c.28 0 .5.23.5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3ZM6 8V6h2v2H6Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M5.5 0c.28 0 .5.23.5.5V2h2V.5a.5.5 0 0 1 1 0V2h2.5c.28 0 .5.23.5.5V5h1.5a.5.5 0 0 1 0 1H12v2h1.5a.5.5 0 0 1 0 1H12v2.5a.5.5 0 0 1-.5.5H9v1.5a.5.5 0 0 1-1 0V12H6v1.5a.5.5 0 0 1-1 0V12H2.5a.5.5 0 0 1-.5-.5V9H.5a.5.5 0 0 1 0-1H2V6H.5a.5.5 0 0 1 0-1H2V2.5c0-.27.22-.5.5-.5H5V.5c0-.27.22-.5.5-.5ZM11 3H3v8h8V3Z" })), database: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M12 3c0-1.1-2.24-2-5-2s-5 .9-5 2v8c0 .43.26.75.54.98.3.23.68.41 1.12.55.88.3 2.06.47 3.34.47 1.28 0 2.46-.17 3.34-.46.44-.15.83-.33 1.12-.56.28-.23.54-.55.54-.98V3Zm-1.03 0a2.45 2.45 0 0 0-.8-.49A8.88 8.88 0 0 0 7 2c-1.29 0-2.4.21-3.16.51a2.45 2.45 0 0 0-.81.49l.05.05c.13.13.37.28.76.44C4.6 3.79 5.7 4 7 4s2.4-.21 3.16-.51a2.45 2.45 0 0 0 .81-.49ZM11 5.75V4.2A8.9 8.9 0 0 1 7 5a8.98 8.98 0 0 1-4-.8v1.55l.02.04c.02.04.06.09.14.15.17.13.44.27.82.4A10 10 0 0 0 7 6.75a10 10 0 0 0 3.02-.41c.38-.13.65-.27.82-.4a.62.62 0 0 0 .14-.15.15.15 0 0 0 .02-.03v-.01ZM3 7.01c.2.1.42.2.66.28.88.29 2.06.46 3.34.46 1.28 0 2.46-.17 3.34-.46.24-.08.46-.17.66-.28V8.5l-.02.04a.62.62 0 0 1-.14.15c-.17.13-.44.27-.82.4A10 10 0 0 1 7 9.5a10 10 0 0 1-3.02-.41 2.76 2.76 0 0 1-.82-.4.62.62 0 0 1-.14-.15.15.15 0 0 1-.02-.03V7Zm0 2.75V11l.02.04c.02.04.06.09.14.15.17.13.44.27.82.4A10 10 0 0 0 7 12a10 10 0 0 0 3.02-.41c.38-.13.65-.27.82-.4a.62.62 0 0 0 .14-.15.15.15 0 0 0 .02-.03V9.76c-.2.1-.42.2-.66.28-.88.29-2.06.46-3.34.46-1.28 0-2.46-.17-3.34-.46A4.77 4.77 0 0 1 3 9.76Z" })), memory: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5 3a.5.5 0 0 0-1 0v3a.5.5 0 0 0 1 0V3Zm2-.5c.28 0 .5.22.5.5v3a.5.5 0 0 1-1 0V3c0-.28.22-.5.5-.5Zm3 2a.5.5 0 1 0-1 0V6a.5.5 0 0 0 1 0V4.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M12 3.54a.5.5 0 0 0-.15-.39l-3-3a.5.5 0 0 0-.38-.14H2.5a.5.5 0 0 0-.5.5v13c0 .27.22.5.5.5h9a.5.5 0 0 0 .5-.5V3.53ZM3 1h5.3L11 3.71v5.3H3V1Zm0 9v3h8v-3H3Z" })), structure: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M8.16 3.45a1.5 1.5 0 1 0-2.33 0l-4.02 6.58A1.5 1.5 0 1 0 2.91 12h8.18a1.5 1.5 0 1 0 1.1-1.97L8.16 3.45Zm-1.47.52a1.5 1.5 0 0 0 .62 0l4.03 6.58c-.11.14-.2.29-.25.45H2.9a1.5 1.5 0 0 0-.25-.45L6.7 3.97Z" })), box: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "m7.21.05 6.49 2.99a.5.5 0 0 1 .3.47v6.98a.5.5 0 0 1-.3.47l-6.47 2.98a.5.5 0 0 1-.46 0L.3 10.96a.5.5 0 0 1-.3-.47V3.5a.5.5 0 0 1 .3-.47L6.79.05a.5.5 0 0 1 .43 0ZM1 4.28v5.9l5.5 2.54v-5.9L1 4.28Zm6.5 8.44 5.5-2.54v-5.9L7.5 6.82v5.9Zm4.8-9.22L7 5.95 1.7 3.5 7 1.05l5.3 2.45Z" })), power: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7.5.5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0v-6Z" }), import_react18.default.createElement("path", { d: "M4.27 2.8a.5.5 0 0 0-.54-.83 6 6 0 1 0 6.54 0 .5.5 0 0 0-.54.84 5 5 0 1 1-5.46 0Z" })), photo: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M6.25 4.25a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0Zm-.5 0a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M13 1.5v11a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11c0-.27.22-.5.5-.5h11c.28 0 .5.23.5.5ZM2 9.3V2h10v5.3L9.85 5.15a.5.5 0 0 0-.7 0L6.5 7.8 5.35 6.65a.5.5 0 0 0-.7 0L2 9.3Zm7.5-3.1L12 8.7V12H2v-1.3l3-3 3.15 3.15a.5.5 0 0 0 .7-.71L7.21 8.5 9.5 6.21Z" })), component: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3.5 1A2.5 2.5 0 0 0 1 3.5v7A2.5 2.5 0 0 0 3.5 13h7a2.5 2.5 0 0 0 2.5-2.5v-7A2.5 2.5 0 0 0 10.5 1h-7ZM12 6.5H7.5V2h3c.83 0 1.5.68 1.5 1.5v3Zm0 1v3c0 .83-.67 1.5-1.5 1.5h-3V7.5H12ZM6.5 12V7.5H2v3c0 .83.67 1.5 1.5 1.5h3ZM2 6.5h4.5V2h-3C2.67 2 2 2.68 2 3.5v3Z" })), grid: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1 1.5c0-.27.22-.5.5-.5H6c.28 0 .5.23.5.5V6a.5.5 0 0 1-.5.5H1.5A.5.5 0 0 1 1 6V1.5Zm1 4V2h3.5v3.5H2Zm5.5-4c0-.27.22-.5.5-.5h4.5c.28 0 .5.23.5.5V6a.5.5 0 0 1-.5.5H8a.5.5 0 0 1-.5-.5V1.5Zm1 4V2H12v3.5H8.5Zm-7 2A.5.5 0 0 0 1 8v4.5c0 .28.22.5.5.5H6a.5.5 0 0 0 .5-.5V8a.5.5 0 0 0-.5-.5H1.5Zm.5 1V12h3.5V8.5H2ZM7.5 8c0-.27.22-.5.5-.5h4.5c.28 0 .5.23.5.5v4.5a.5.5 0 0 1-.5.5H8a.5.5 0 0 1-.5-.5V8Zm1 4V8.5H12V12H8.5Z" })), outline: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M2 2v2H1V1.5c0-.27.22-.5.5-.5H4v1H2ZM1 9V5h1v4H1Zm0 1v2.5c0 .28.22.5.5.5H4v-1H2v-2H1Zm9 3h2.5a.5.5 0 0 0 .5-.5V10h-1v2h-2v1Zm2-9h1V1.5a.5.5 0 0 0-.5-.5H10v1h2v2Zm-3 8v1H5v-1h4ZM9 1v1H5V1h4Zm4 8h-1V5h1v4ZM7 8a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" })), photodrag: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M8.25 3.25a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0Zm-.5 0a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M14 7V.5a.5.5 0 0 0-.5-.5h-10a.5.5 0 0 0-.5.5V3H.5a.5.5 0 0 0-.5.5V6h1V4h2v6.5c0 .28.22.5.5.5H10v2H8v1h2.5a.5.5 0 0 0 .5-.5V11h2.5a.5.5 0 0 0 .5-.5V7ZM4 1v5.8l1.65-1.65c.2-.2.5-.2.7 0L7.5 6.3l2.65-2.65c.2-.2.5-.2.7 0L13 5.8V1H4Zm9 6.21-2.5-2.5-2.3 2.3 1.15 1.14a.5.5 0 1 1-.7.7L6 6.22l-2 2v1.8h9V7.2Z" }), import_react18.default.createElement("path", { d: "M0 10V7h1v3H0Zm0 3.5V11h1v2h2v1H.5a.5.5 0 0 1-.5-.5Zm7 .5H4v-1h3v1Z" })), search: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M9.54 10.2a5.5 5.5 0 1 1 .66-.66c.06.03.11.06.15.1l3 3a.5.5 0 0 1-.7.71l-3-3a.5.5 0 0 1-.1-.14ZM10.5 6a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0Z" })), zoom: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M6 3.5c.28 0 .5.22.5.5v1.5H8a.5.5 0 0 1 0 1H6.5V8a.5.5 0 0 1-1 0V6.5H4a.5.5 0 0 1 0-1h1.5V4c0-.28.22-.5.5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M9.54 10.2a5.5 5.5 0 1 1 .66-.66c.06.03.11.06.15.1l3 3a.5.5 0 0 1-.7.71l-3-3a.5.5 0 0 1-.1-.14ZM10.5 6a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0Z" })), zoomout: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M4 5.5a.5.5 0 0 0 0 1h4a.5.5 0 0 0 0-1H4Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M6 11.5c1.35 0 2.59-.49 3.54-1.3.03.06.06.11.1.15l3 3a.5.5 0 0 0 .71-.7l-3-3a.5.5 0 0 0-.14-.1A5.5 5.5 0 1 0 6 11.5Zm0-1a4.5 4.5 0 1 0 0-9 4.5 4.5 0 0 0 0 9Z" })), zoomreset: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1.5 2.84V1.5a.5.5 0 0 0-1 0V4c0 .28.22.5.5.5h2.5a.5.5 0 0 0 0-1H2.26a4.5 4.5 0 1 1-.5 4.02.5.5 0 1 0-.94.33 5.5 5.5 0 0 0 8.72 2.36l.1.14 3 3a.5.5 0 0 0 .71-.7l-3-3a.5.5 0 0 0-.14-.1 5.5 5.5 0 1 0-8.7-6.7Z" })), eye: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7 9.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "m14 7-.2.3c-.13.16-3.06 4.2-6.8 4.2C3.26 11.5.33 7.46.2 7.3L0 7l.2-.3C.34 6.55 3.27 2.5 7 2.5c3.74 0 6.67 4.04 6.8 4.2l.2.3ZM2.9 5.3A13 13 0 0 0 1.24 7 13 13 0 0 0 2.9 8.7c1.14.97 2.58 1.8 4.1 1.8 1.52 0 2.96-.83 4.1-1.8A13 13 0 0 0 12.76 7a13 13 0 0 0-1.66-1.7C9.96 4.33 8.52 3.5 7 3.5c-1.52 0-2.96.83-4.1 1.8Z" })), eyeclose: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1.85 1.15a.5.5 0 1 0-.7.7l11 11a.5.5 0 0 0 .7-.7l-11-11ZM11.1 8.7c-.17.15-.36.3-.55.44l.72.71a13.25 13.25 0 0 0 2.52-2.56L14 7l-.2-.3c-.13-.16-3.06-4.2-6.8-4.2-.89 0-1.73.23-2.5.58l.76.76A4.86 4.86 0 0 1 7 3.5c1.52 0 2.96.83 4.1 1.8A13 13 0 0 1 12.76 7a13 13 0 0 1-1.66 1.7ZM.2 6.7c.08-.09 1.04-1.41 2.53-2.55l.72.71c-.2.14-.38.3-.55.44A13 13 0 0 0 1.24 7 13 13 0 0 0 2.9 8.7c1.14.97 2.58 1.8 4.1 1.8.6 0 1.18-.13 1.74-.34l.77.76c-.78.35-1.62.58-2.51.58C3.26 11.5.33 7.46.2 7.3L0 7l.2-.3Z" }), import_react18.default.createElement("path", { d: "M4.5 7c0-.32.06-.63.17-.91l3.24 3.24A2.5 2.5 0 0 1 4.5 7Zm4.83.91L6.09 4.67a2.5 2.5 0 0 1 3.24 3.24Z" })), lightning: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M2.52 6.6a.57.57 0 0 0-.17.54c.04.2.19.37.38.41l2.78.73-1.5 5c-.06.24.02.5.22.63a.5.5 0 0 0 .28.09.5.5 0 0 0 .35-.14L11.5 7.4c.14-.13.2-.34.15-.54a.53.53 0 0 0-.38-.4l-2.7-.7L10.79.78c.1-.23.04-.5-.15-.66a.5.5 0 0 0-.65 0L2.52 6.6Zm7.72.63-3.07-.8 1.85-4.14-5.2 4.51 2.94.77-1.27 4.28 4.75-4.62Zm-5.73 6.2.04.02Z" })), lightningoff: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M10.14 8.72 11.5 7.4c.14-.13.2-.34.15-.54a.53.53 0 0 0-.38-.4l-2.7-.7L10.79.78c.1-.23.04-.5-.15-.66a.5.5 0 0 0-.65 0L5.46 4.05l.71.7L9.02 2.3 7.38 5.97l.7.7 2.16.56-.8.79.7.7ZM2.52 6.6a.57.57 0 0 0-.17.54c.04.2.19.37.38.41l2.78.73-1.5 5c-.06.24.02.5.22.63a.5.5 0 0 0 .63-.05l3.84-3.74-.7-.7-2.51 2.43 1.13-3.81-.68-.69L3.8 6.8l.85-.73-.71-.7L2.52 6.6Zm-.67-5.45a.5.5 0 1 0-.7.7l11 11a.5.5 0 0 0 .7-.7l-11-11Z" })), contrast: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3 3H.5a.5.5 0 0 0-.5.5v10c0 .28.22.5.5.5h10a.5.5 0 0 0 .5-.5V11h2.5a.5.5 0 0 0 .5-.5V.5a.5.5 0 0 0-.5-.5h-10a.5.5 0 0 0-.5.5V3Zm1 1v2.3L6.3 4H4ZM3 4v6.5a.5.5 0 0 0 .5.5H10v2H1V4h2Zm1-1h6.5a.5.5 0 0 1 .5.5V10h2V1H4v2Zm6 7V7.71l-2.3 2.3H10Zm0-3.7V4.7L4.7 10h1.6L10 6.3ZM9.3 4H7.7L4 7.71V9.3L9.3 4Z" })), switchalt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3 3V.5c0-.27.22-.5.5-.5h10c.28 0 .5.23.5.5v10a.5.5 0 0 1-.5.5H11v2.5a.5.5 0 0 1-.5.5H.5a.5.5 0 0 1-.5-.5v-10c0-.27.22-.5.5-.5H3Zm1 0V1h9v9h-2V3.5a.5.5 0 0 0-.5-.5H4Zm6 8v2H1V4h2v6.5c0 .28.22.5.5.5H10Zm0-1H4V4h6v6Z" })), mirror: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1 1.5c0-.27.22-.5.5-.5h11c.28 0 .5.23.5.5v11a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11ZM2 12h10V2L2 12Z" })), grow: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1.5 1a.5.5 0 1 0 0 1H12v10.5a.5.5 0 0 0 1 0V2a1 1 0 0 0-1-1H1.5Z" }), import_react18.default.createElement("path", { d: "M1 3.5c0-.27.22-.5.5-.5H10a1 1 0 0 1 1 1v8.5a.5.5 0 0 1-1 0V4H1.5a.5.5 0 0 1-.5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1.5 5a.5.5 0 0 0-.5.5v7c0 .28.22.5.5.5h7a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.5-.5h-7ZM2 6v6h6V6H2Z" })), paintbrush: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M11.8535.1464a.5.5 0 0 0-.7071 0L2.9827 8.3102a2.2396 2.2396 0 0 0-1.0737.599C.6772 10.141.2402 11.903.0852 12.9978 0 13.5998 0 14.0002 0 14.0002s.4004 0 1.0023-.0853c1.095-.155 2.8569-.5919 4.0887-1.8237.307-.307.5067-.6806.5992-1.0743l8.1633-8.1633a.5.5 0 0 0 0-.7071l-2-2Zm-6.253 9.546L6.543 8.75l-1.293-1.2929-.9424.9424a2.242 2.242 0 0 1 .7835.5097c.23.2302.4.4977.5095.7831ZM7.25 8.0428 12.7929 2.5 11.5 1.2071 5.957 6.75 7.25 8.0429ZM4.3839 9.6163c.4881.4882.4881 1.2796 0 1.7678-.7665.7664-1.832 1.1845-2.7791 1.403a8.6972 8.6972 0 0 1-.49.0982 8.7151 8.7151 0 0 1 .0982-.4899c.2186-.9471.6367-2.0126 1.403-2.779.4882-.4882 1.2797-.4882 1.7679 0Z" })), ruler: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1.5 1c.28 0 .5.23.5.5V2h10v-.5a.5.5 0 0 1 1 0v2a.5.5 0 0 1-1 0V3H2v.5a.5.5 0 0 1-1 0v-2c0-.27.22-.5.5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1.5 6a.5.5 0 0 0-.5.5v6c0 .28.22.5.5.5h11a.5.5 0 0 0 .5-.5v-6a.5.5 0 0 0-.5-.5h-11ZM2 7v5h10V7h-1v2.5a.5.5 0 0 1-1 0V7h-.75v1a.5.5 0 0 1-1 0V7H7.5v2.5a.5.5 0 0 1-1 0V7h-.75v1a.5.5 0 0 1-1 0V7H4v2.5a.5.5 0 0 1-1 0V7H2Z" })), stop: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M4.5 4a.5.5 0 0 0-.5.5v5c0 .28.22.5.5.5h5a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-.5-.5h-5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0Zm-1 0A6 6 0 1 1 1 7a6 6 0 0 1 12 0Z" })), camera: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M10 7a3 3 0 1 1-6 0 3 3 0 0 1 6 0ZM9 7a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M2.5 1a.5.5 0 0 0-.5.5V2H.5a.5.5 0 0 0-.5.5v9c0 .28.22.5.5.5h13a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5H6v-.5a.5.5 0 0 0-.5-.5h-3ZM1 3v8h12V3H1Z" })), video: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M2.5 10a.5.5 0 1 0 0-1 .5.5 0 0 0 0 1Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M0 4c0-1.1.9-2 2-2h6a2 2 0 0 1 2 2v.5l3.19-2.4a.5.5 0 0 1 .81.4v9a.5.5 0 0 1-.8.4L10 9.5v.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V4Zm9 0v1.5a.5.5 0 0 0 .8.4L13 3.5v7L9.8 8.1a.5.5 0 0 0-.8.4V10a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1Z" })), speaker: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1 4.50004V9.50004C1 9.77618 1.22386 10 1.5 10H4L7.17075 12.7744C7.49404 13.0573 8 12.8277 8 12.3982V1.60192C8 1.17235 7.49404 0.942757 7.17075 1.22564L4 4.00004H1.5C1.22386 4.00004 1 4.2239 1 4.50004ZM4 9.00004V5.00004H2V9.00004H4ZM4.99804 9.54456C4.99934 9.52989 5 9.51505 5 9.50004V4.50004C5 4.48504 4.99934 4.47019 4.99804 4.45552L7 2.70381V11.2963L4.99804 9.54456Z" }), import_react18.default.createElement("path", { d: "M10.1498 1.75202C9.88637 1.66927 9.60572 1.81577 9.52297 2.07922C9.44023 2.34267 9.58672 2.62332 9.85017 2.70607C11.6763 3.27963 13 4.98596 13 7.00014C13 9.01433 11.6763 10.7207 9.85017 11.2942C9.58672 11.377 9.44023 11.6576 9.52297 11.9211C9.60572 12.1845 9.88637 12.331 10.1498 12.2483C12.3808 11.5476 14 9.4636 14 7.00014C14 4.53669 12.3808 2.45272 10.1498 1.75202Z" }), import_react18.default.createElement("path", { d: "M10.2504 3.96861C10.0113 3.83033 9.70547 3.91201 9.5672 4.15105C9.42893 4.39008 9.51061 4.69594 9.74964 4.83421C10.4982 5.26723 11 6.07534 11 7.00006C11 7.92479 10.4982 8.7329 9.74964 9.16591C9.51061 9.30418 9.42893 9.61005 9.5672 9.84908C9.70547 10.0881 10.0113 10.1698 10.2504 10.0315C11.2952 9.42711 12 8.29619 12 7.00006C12 5.70394 11.2952 4.57302 10.2504 3.96861Z" })), play: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "m12.81 7.43-9.05 5.6A.5.5 0 0 1 3 12.6V1.4c0-.4.43-.63.76-.43l9.05 5.6a.5.5 0 0 1 0 .86Z" })), playback: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M11.24 12.04 3.7 7.42a.5.5 0 0 1-.2-.23v4.05a.75.75 0 0 1-1.5 0v-8.5a.75.75 0 0 1 1.5 0V6.8a.5.5 0 0 1 .2-.23l7.54-4.6a.5.5 0 0 1 .76.42v9.22a.5.5 0 0 1-.76.43Z" })), playnext: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "m2.76 12.04 7.54-4.61a.5.5 0 0 0 .2-.23v4.05a.75.75 0 0 0 1.5 0v-8.5a.75.75 0 0 0-1.5 0V6.8a.5.5 0 0 0-.2-.23l-7.54-4.6a.5.5 0 0 0-.76.42v9.22c0 .39.43.63.76.43Z" })), rewind: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M9 2.42v2.32L13.23 2a.5.5 0 0 1 .77.42v9.16a.5.5 0 0 1-.77.42L9 9.26v2.32a.5.5 0 0 1-.77.42L1.5 7.65v3.6a.75.75 0 0 1-1.5 0v-8.5a.75.75 0 0 1 1.5 0v3.6L8.23 2a.5.5 0 0 1 .77.42Z" })), fastforward: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5 2.42v2.32L.77 2a.5.5 0 0 0-.77.42v9.16c0 .4.44.64.77.42L5 9.26v2.32c0 .4.44.64.77.42l6.73-4.35v3.6a.75.75 0 0 0 1.5 0v-8.5a.75.75 0 0 0-1.5 0v3.6L5.77 2a.5.5 0 0 0-.77.42Z" })), stopalt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1 1.5c0-.27.22-.5.5-.5h11c.28 0 .5.23.5.5v11a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11Z" })), book: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M13 2a2 2 0 0 0-2-2H1.5a.5.5 0 0 0-.5.5v13c0 .28.22.5.5.5H11a2 2 0 0 0 2-2V2ZM3 13h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H7v6a.5.5 0 0 1-.86.36L5.5 6.7l-.65.65A.5.5 0 0 1 4 7V1H3v12ZM5 1v4.8l.15-.15a.5.5 0 0 1 .74.04l.11.1V1H5Z" })), document: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M4 5.5c0-.28.22-.5.5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5ZM4.5 7.5a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1h-5ZM4 10.5c0-.28.22-.5.5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1.5 0a.5.5 0 0 0-.5.5v13c0 .28.22.5.5.5h11a.5.5 0 0 0 .5-.5V3.2a.5.5 0 0 0-.15-.35l-2.7-2.7A.5.5 0 0 0 9.79 0H1.5ZM2 1h7.5v2c0 .28.22.5.5.5h2V13H2V1Z" })), copy: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M11.75.07A.5.5 0 0 0 11.5 0h-6a.5.5 0 0 0-.5.5V3H.5a.5.5 0 0 0-.5.5v10c0 .28.22.5.5.5h8a.5.5 0 0 0 .5-.5V11h4.5a.5.5 0 0 0 .5-.5V2.51a.5.5 0 0 0-.15-.36l-2-2a.5.5 0 0 0-.1-.08ZM9 10h4V3h-1.5a.5.5 0 0 1-.5-.5V1H6v2h.5a.5.5 0 0 1 .36.15l1.99 2c.1.09.15.21.15.35v4.51ZM1 4v9h7V6H6.5a.5.5 0 0 1-.5-.5V4H1Z" })), category: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M3 1.5c0-.28.22-.5.5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5Zm-1 2c0-.27.22-.5.5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1 5.5c0-.28.22-.5.5-.5h11c.28 0 .5.22.5.5v7a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-7ZM2 12V6h10v6H2Z" })), folder: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M6.59 3.5 5.09 2H1v9h12V3.5H6.59Zm.41-1L5.8 1.3a1 1 0 0 0-.71-.3H.5a.5.5 0 0 0-.5.5v10c0 .28.22.5.5.5h13a.5.5 0 0 0 .5-.5V3a.5.5 0 0 0-.5-.5H7Z" })), print: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M4.5 8a.5.5 0 1 0 0 1h5a.5.5 0 0 0 0-1h-5Zm0 2a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1h-5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M2 1.5c0-.27.22-.5.5-.5h8a.5.5 0 0 1 .36.15l.99 1c.1.09.15.21.15.35v1.51h1.5c.28 0 .5.22.5.5v5a.5.5 0 0 1-.5.5H12v2.5a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5V10H.5a.5.5 0 0 1-.5-.5v-5c0-.28.22-.5.5-.5H2V1.5ZM13 9h-1V6.5a.5.5 0 0 0-.5-.5h-9a.5.5 0 0 0-.5.5V9H1V5h12v4Zm-2-6v1H3V2h7v.5c0 .28.22.5.5.5h.5Zm-8 9h8V7H3v5Z" })), graphline: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5.15 6.15c.2-.2.5-.2.7 0L7 7.3l2.15-2.15c.2-.2.5-.2.7 0l1 1a.5.5 0 0 1-.7.7l-.65-.64-2.15 2.15a.5.5 0 0 1-.7 0L5.5 7.2 3.85 8.86a.5.5 0 1 1-.7-.71l2-2Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1.5 1a.5.5 0 0 0-.5.5v11c0 .28.22.5.5.5h11a.5.5 0 0 0 .5-.5v-11a.5.5 0 0 0-.5-.5h-11ZM2 2v10h10V2H2Z" })), calendar: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3.5 0c.28 0 .5.22.5.5V1h6V.5a.5.5 0 0 1 1 0V1h1.5c.28 0 .5.22.5.5v11a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11c0-.28.22-.5.5-.5H3V.5c0-.28.22-.5.5-.5ZM2 4v2.3h3V4H2Zm0 5.2V6.8h3v2.4H2Zm0 .5V12h3V9.7H2Zm3.5 0V12h3V9.7h-3Zm3.5 0V12h3V9.7H9Zm3-.5H9V6.8h3v2.4Zm-3.5 0h-3V6.8h3v2.4ZM9 4v2.3h3V4H9ZM5.5 6.3h3V4h-3v2.3Z" })), graphbar: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M12 2.5a.5.5 0 0 0-1 0v10a.5.5 0 0 0 1 0v-10Zm-3 2a.5.5 0 0 0-1 0v8a.5.5 0 0 0 1 0v-8ZM5.5 7c.28 0 .5.22.5.5v5a.5.5 0 0 1-1 0v-5c0-.28.22-.5.5-.5ZM3 10.5a.5.5 0 0 0-1 0v2a.5.5 0 0 0 1 0v-2Z" })), menu: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M13 2a.5.5 0 0 1 0 1H1a.5.5 0 0 1 0-1h12Zm-3 3a.5.5 0 0 1 0 1H1a.5.5 0 0 1 0-1h9Zm1.5 3.5A.5.5 0 0 0 11 8H1a.5.5 0 0 0 0 1h10a.5.5 0 0 0 .5-.5Zm-4 2.5a.5.5 0 0 1 0 1H1a.5.5 0 0 1 0-1h6.5Z" })), menualt: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1 2a.5.5 0 0 0 0 1h12a.5.5 0 0 0 0-1H1Zm3 3a.5.5 0 0 0 0 1h9a.5.5 0 0 0 0-1H4ZM2.5 8.5c0-.28.22-.5.5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5Zm4 2.5a.5.5 0 0 0 0 1H13a.5.5 0 0 0 0-1H6.5Z" })), filter: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1 2a.5.5 0 0 0 0 1h12a.5.5 0 0 0 0-1H1Zm2 3a.5.5 0 0 0 0 1h8a.5.5 0 0 0 0-1H3Zm1.5 3.5c0-.28.22-.5.5-.5h4a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5Zm2 2.5a.5.5 0 0 0 0 1h1a.5.5 0 0 0 0-1h-1Z" })), docchart: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1 1.5C1 1.22386 1.22386 1 1.5 1H12.5C12.7761 1 13 1.22386 13 1.5V12.5C13 12.7761 12.7761 13 12.5 13H1.5C1.22386 13 1 12.7761 1 12.5V1.5ZM2 4V6.2998H5V4H2ZM2 9.2002V6.7998H5V9.2002H2ZM2 9.7002V12H5V9.7002H2ZM5.5 9.7002V12H8.5V9.7002H5.5ZM9 9.7002V12H12V9.7002H9ZM12 9.2002H9V6.7998H12V9.2002ZM8.5 9.2002H5.5V6.7998H8.5V9.2002ZM9 6.2998H12V4H9V6.2998ZM5.5 6.2998H8.5V4H5.5V6.2998Z" })), doclist: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M3.5 6.5c0-.28.22-.5.5-.5h6a.5.5 0 0 1 0 1H4a.5.5 0 0 1-.5-.5ZM4 9a.5.5 0 0 0 0 1h6a.5.5 0 0 0 0-1H4Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M1 1.5c0-.28.22-.5.5-.5h11c.28 0 .5.22.5.5v11a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11ZM2 4v8h10V4H2Z" })), markup: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M8.98 1.63a.5.5 0 0 0-.96-.26l-3 11a.5.5 0 1 0 .96.26l3-11ZM3.32 3.62a.5.5 0 0 1 .06.7L1.15 7l2.23 2.68a.5.5 0 1 1-.76.64l-2.5-3a.5.5 0 0 1 0-.64l2.5-3a.5.5 0 0 1 .7-.06Zm7.36 0a.5.5 0 0 0-.06.7L12.85 7l-2.23 2.68a.5.5 0 0 0 .76.64l2.5-3a.5.5 0 0 0 0-.64l-2.5-3a.5.5 0 0 0-.7-.06Z" })), bold: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3 2v1.5h1v7H3V12h5a3 3 0 0 0 1.8-5.4A2.74 2.74 0 0 0 8 2H3Zm5 5.5H5.5v3H8a1.5 1.5 0 1 0 0-3Zm-.25-4H5.5V6h2.25a1.25 1.25 0 1 0 0-2.5Z" })), italic: import_react18.default.createElement("path", { d: "M5 2h6v1H8.5l-2 8H9v1H3v-1h2.5l2-8H5V2Z" }), paperclip: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M10.55 2.27a1.5 1.5 0 0 0-2.12 0L2.78 7.92a2.5 2.5 0 0 0 3.53 3.54l3.54-3.54a.5.5 0 1 1 .7.71l-3.53 3.54a3.5 3.5 0 0 1-4.96-4.94v-.01l5.66-5.66h.01a2.5 2.5 0 0 1 3.53 3.53L5.6 10.76a1.5 1.5 0 0 1-2.12-2.12L7.02 5.1a.5.5 0 1 1 .7.7L4.2 9.34a.5.5 0 0 0 .7.7l5.66-5.65a1.5 1.5 0 0 0 0-2.12Z" })), listordered: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5 2.5c0-.28.22-.5.5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5ZM5 7c0-.28.22-.5.5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 5 7Zm.5 4a.5.5 0 0 0 0 1h7a.5.5 0 0 0 0-1h-7Zm-3-9H1v1h1v3h1V2.5a.5.5 0 0 0-.5-.5ZM3 8.5v1a.5.5 0 0 1-1 0V9h-.5a.5.5 0 0 1 0-1h1c.28 0 .5.22.5.5Zm-1 2a.5.5 0 0 0-1 0V12h2v-1H2v-.5Z" })), listunordered: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M2.75 2.5a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM5.5 2a.5.5 0 0 0 0 1h7a.5.5 0 0 0 0-1h-7Zm0 9a.5.5 0 0 0 0 1h7a.5.5 0 0 0 0-1h-7ZM2 12.25a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5ZM5 7c0-.28.22-.5.5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 5 7Zm-3 .75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z" })), paragraph: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M6 7a3 3 0 1 1 0-6h5.5a.5.5 0 0 1 0 1H10v10.5a.5.5 0 0 1-1 0V2H7v10.5a.5.5 0 0 1-1 0V7Z" })), markdown: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M2 4.5h1.5L5 6.38 6.5 4.5H8v5H6.5V7L5 8.88 3.5 7v2.5H2v-5Zm7.75 0h1.5V7h1.25l-2 2.5-2-2.5h1.25V4.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M.5 2a.5.5 0 0 0-.5.5v9c0 .28.22.5.5.5h13a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5H.5ZM1 3v8h12V3H1Z" })), repository: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M5 2.5C5 2.77614 4.77614 3 4.5 3C4.22386 3 4 2.77614 4 2.5C4 2.22386 4.22386 2 4.5 2C4.77614 2 5 2.22386 5 2.5Z" }), import_react18.default.createElement("path", { d: "M4.5 5C4.77614 5 5 4.77614 5 4.5C5 4.22386 4.77614 4 4.5 4C4.22386 4 4 4.22386 4 4.5C4 4.77614 4.22386 5 4.5 5Z" }), import_react18.default.createElement("path", { d: "M5 6.5C5 6.77614 4.77614 7 4.5 7C4.22386 7 4 6.77614 4 6.5C4 6.22386 4.22386 6 4.5 6C4.77614 6 5 6.22386 5 6.5Z" }), import_react18.default.createElement("path", { fillRule: "evenodd", d: "M11 0C12.1046 0 13 0.895431 13 2V12C13 13.1046 12.1046 14 11 14H1.5C1.22386 14 1 13.7761 1 13.5V0.5C1 0.223857 1.22386 0 1.5 0H11ZM11 1H3V13H11C11.5523 13 12 12.5523 12 12V2C12 1.44772 11.5523 1 11 1Z" })), commit: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M3.03 7.5a4 4 0 0 0 7.94 0h2.53a.5.5 0 0 0 0-1h-2.53a4 4 0 0 0-7.94 0H.5a.5.5 0 0 0 0 1h2.53ZM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" })), branch: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M6 2.5c0 .65-.42 1.2-1 1.41v4.06A3.36 3.36 0 0 1 7.5 7a2.7 2.7 0 0 0 1.81-.56c.22-.18.38-.4.48-.62a1.5 1.5 0 1 1 1.03.15c-.16.42-.43.87-.86 1.24-.57.47-1.37.79-2.46.79-1.04 0-1.64.42-2 .92-.26.37-.4.8-.47 1.18A1.5 1.5 0 1 1 4 10.09V3.9a1.5 1.5 0 1 1 2-1.4Zm-2 9a.5.5 0 1 1 1 0 .5.5 0 0 1-1 0Zm1-9a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Zm6 2a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Z" })), pullrequest: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M8.35 1.35 7.71 2h.79A2.5 2.5 0 0 1 11 4.5v5.59a1.5 1.5 0 1 1-1 0V4.5C10 3.67 9.33 3 8.5 3h-.8l.65.65a.5.5 0 1 1-.7.7l-1.5-1.5a.5.5 0 0 1 0-.7l1.5-1.5a.5.5 0 1 1 .7.7ZM11 11.5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0ZM4 3.91a1.5 1.5 0 1 0-1 0v6.18a1.5 1.5 0 1 0 1 0V3.9ZM3.5 11a.5.5 0 1 0 0 1 .5.5 0 0 0 0-1Zm0-8a.5.5 0 1 0 0-1 .5.5 0 0 0 0 1Z" })), merge: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M4.1 3.87a1.5 1.5 0 1 0-1.1.04v6.18a1.5 1.5 0 1 0 1 0V6.4c.26.4.57.77.93 1.08A6.57 6.57 0 0 0 9.08 9a1.5 1.5 0 1 0 0-1 5.57 5.57 0 0 1-3.5-1.25 4.74 4.74 0 0 1-1.47-2.87ZM3.5 11a.5.5 0 1 0 0 1 .5.5 0 0 0 0-1ZM4 2.5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Zm7 6a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Z" })), apple: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M11.03 8.1a3.05 3.05 0 0 1-.2-1.74 2.7 2.7 0 0 1 1.4-1.94 3.13 3.13 0 0 0-2.35-1.4c-.84-.08-2.01.56-2.65.57h-.02c-.63 0-1.81-.65-2.64-.57-.42.04-1.75.32-2.55 1.6-.28.44-.5 1.01-.58 1.74a6.36 6.36 0 0 0 .02 1.74 7.5 7.5 0 0 0 1.35 3.33c.7 1.01 1.51 1.6 1.97 1.6.93.02 1.74-.6 2.41-.6l.02.01h.04c.67-.02 1.48.61 2.42.6.45-.02 1.26-.6 1.97-1.6a7.95 7.95 0 0 0 .97-1.86 2.6 2.6 0 0 1-1.58-1.48ZM8.86 2.13c.72-.85.7-2.07.63-2.12-.07-.06-1.25.16-1.99.98a2.78 2.78 0 0 0-.62 2.13c.06.05 1.27-.14 1.98-.99Z" })), linux: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M7 0a3 3 0 0 1 3 3v1.24c.13.13.25.27.36.42l.52.43.2.15c.32.26.7.59 1.09.97A6.28 6.28 0 0 1 14 9.54a.5.5 0 0 1-.35.44c-.31.1-.8.18-1.34.13-.33-.03-.7-.12-1.05-.3-.04.17-.1.34-.17.51a2 2 0 1 1-2.89 2.56 5.5 5.5 0 0 1-2.4 0 2 2 0 1 1-2.9-2.56 5.56 5.56 0 0 1-.16-.51c-.35.18-.72.27-1.05.3a3.4 3.4 0 0 1-1.34-.13.5.5 0 0 1-.35-.44l.01-.14a6.28 6.28 0 0 1 1.82-3.2 13.42 13.42 0 0 1 1.3-1.11c.22-.19.4-.32.5-.43.12-.15.24-.29.37-.42V3a3 3 0 0 1 3-3Zm1 11.9a2 2 0 0 1 2.14-1.9 5.5 5.5 0 0 0 .36-2c0-.51-.1-1.07-.3-1.6l-.03-.02a4.4 4.4 0 0 0-.86-.42 6.71 6.71 0 0 0-1-.31l-.86.64c-.27.2-.63.2-.9 0l-.85-.64a6.72 6.72 0 0 0-1.87.73l-.03.02A4.6 4.6 0 0 0 3.5 8c0 .68.11 1.39.36 2H4a2 2 0 0 1 2 1.9 4.49 4.49 0 0 0 2 0ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm6 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM6.1 4.3a1.5 1.5 0 0 1 1.8 0l.27.2L7 5.38 5.83 4.5l.27-.2ZM8.5 2c.28 0 .5.22.5.5V3a.5.5 0 0 1-1 0v-.5c0-.28.22-.5.5-.5ZM6 2.5a.5.5 0 0 0-1 0V3a.5.5 0 0 0 1 0v-.5Z" })), ubuntu: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M12.26 2.07c0 1.14-.89 2.06-1.99 2.06s-1.99-.92-1.99-2.06c0-1.14.9-2.07 2-2.07s1.98.93 1.98 2.07ZM3.98 6.6c0 1.14-.9 2.07-2 2.07C.9 8.67 0 7.74 0 6.6c0-1.14.9-2.07 1.99-2.07 1.1 0 1.99.93 1.99 2.07ZM6.47 11.92a4.76 4.76 0 0 1-3.3-2.62c-.53.25-1.12.33-1.7.22a6.72 6.72 0 0 0 1.84 2.63 6.38 6.38 0 0 0 4.24 1.58c-.37-.5-.57-1.1-.59-1.73a4.77 4.77 0 0 1-.49-.08ZM11.81 11.93c0 1.14-.89 2.07-1.99 2.07s-1.98-.93-1.98-2.07c0-1.14.89-2.06 1.98-2.06 1.1 0 2 .92 2 2.06ZM12.6 11.17a6.93 6.93 0 0 0 .32-7.93A2.95 2.95 0 0 1 11.8 4.6a5.23 5.23 0 0 1-.16 5.03c.47.4.8.94.95 1.54ZM1.99 3.63h-.15A6.48 6.48 0 0 1 8 .24a3.07 3.07 0 0 0-.6 1.68 4.7 4.7 0 0 0-3.9 2.17c-.46-.3-.98-.45-1.51-.45Z" })), windows: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M6.5 1H1v5.5h5.5V1ZM13 1H7.5v5.5H13V1ZM7.5 7.5H13V13H7.5V7.5ZM6.5 7.5H1V13h5.5V7.5Z" })), storybook: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M2.04.62a.7.7 0 0 0-.66.72l.44 11.56c.01.37.3.66.67.68l9.4.42h.02a.7.7 0 0 0 .7-.7V.66a.7.7 0 0 0-.74-.66l-.77.05.05 1.62a.1.1 0 0 1-.17.08l-.52-.4-.61.46a.1.1 0 0 1-.17-.09L9.75.13l-7.7.49Zm8 4.74c-.24.2-2.09.33-2.09.05.04-1.04-.43-1.09-.69-1.09-.24 0-.66.08-.66.64 0 .57.6.89 1.32 1.27 1.02.53 2.24 1.18 2.24 2.82 0 1.57-1.27 2.43-2.9 2.43-1.67 0-3.14-.68-2.97-3.03.06-.27 2.2-.2 2.2 0-.03.97.19 1.26.75 1.26.43 0 .62-.24.62-.64 0-.6-.63-.95-1.36-1.36-.99-.56-2.15-1.2-2.15-2.7 0-1.5 1.03-2.5 2.86-2.5 1.83 0 2.84.99 2.84 2.85Z" })), azuredevops: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "m0 5.18 1.31-1.73 4.9-2V.01l4.3 3.15-8.78 1.7v4.8L0 9.16V5.18Zm14-2.6v8.55l-3.36 2.86-5.42-1.79V14L1.73 9.66l8.78 1.05V3.16L14 2.58Z" })), bitbucket: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M1 1.52A.41.41 0 0 0 .59 2l1.74 10.6c.05.26.28.46.55.46h8.37c.2 0 .38-.14.42-.34l1.01-6.25H8.81l-.46 2.71H5.68L4.95 5.4h7.91L13.4 2a.41.41 0 0 0-.41-.48H1Z" })), chrome: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M13.02 3.43a.11.11 0 0 1-.1.17H7a3.4 3.4 0 0 0-3.3 2.55.11.11 0 0 1-.21.03L1.52 2.76a.11.11 0 0 1 0-.12 6.97 6.97 0 0 1 9-1.7c1.03.6 1.9 1.47 2.5 2.5ZM7 9.62a2.62 2.62 0 1 1 0-5.24 2.62 2.62 0 0 1 0 5.24Zm1.03.7a.11.11 0 0 0-.12-.04 3.4 3.4 0 0 1-4-1.84L1.1 3.57a.11.11 0 0 0-.2 0 7 7 0 0 0 5.07 10.35c.04 0 .08-.02.1-.05l1.97-3.42a.11.11 0 0 0 0-.13Zm1.43-5.95h3.95c.05 0 .1.03.1.07a6.97 6.97 0 0 1-1.53 7.48A6.96 6.96 0 0 1 7.08 14a.11.11 0 0 1-.1-.17l2.81-4.88h.01a3.38 3.38 0 0 0-.42-4.38.11.11 0 0 1 .08-.2Z" })), chromatic: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M0 7a7 7 0 1 0 14 0A7 7 0 0 0 0 7Zm5.22-3.87a1.97 1.97 0 0 1 3.75.83v1.29L5.61 3.32a2.49 2.49 0 0 0-.4-.19ZM8.7 5.71 5.35 3.78a1.97 1.97 0 0 0-2.6 2.83c.12-.1.24-.18.37-.26l1.51-.87a.27.27 0 0 1 .27 0L7 6.69l1.7-.98Zm-.32 4.97-1.52-.87a.27.27 0 0 1-.13-.23V7.15l-1.7-.97v3.86a1.97 1.97 0 0 0 3.75.83 2.5 2.5 0 0 1-.4-.19Zm.26-.46a1.97 1.97 0 0 0 2.6-2.83c-.11.1-.23.18-.36.26L7.53 9.58l1.11.64Zm-4.1.26h-.17a1.97 1.97 0 0 1-1.9-2.47 2 2 0 0 1 .92-1.2l1.11-.63v3.86c0 .14.01.29.04.44Zm6.79-5.98a1.97 1.97 0 0 0-1.87-.97c.03.14.04.29.04.43v1.75c0 .1-.05.19-.14.23l-2.1 1.22V9.1l3.35-1.93a1.97 1.97 0 0 0 .72-2.68Z" })), componentdriven: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M10.85 2.18 8.87.2a.69.69 0 0 0-.97 0L3.09 5.01a.69.69 0 0 0 0 .97l2.46 2.46-2.4 2.4a.69.69 0 0 0 0 .98l1.98 1.98c.27.27.7.27.97 0l4.8-4.81a.69.69 0 0 0 0-.97L8.45 5.56l2.4-2.4a.69.69 0 0 0 0-.98Z" })), discord: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M11.85 2.88C10.95 2.48 10 2.18 9 2a7.05 7.05 0 0 0-.4.75 10.66 10.66 0 0 0-3.2 0c-.1-.23-.24-.5-.36-.73A.04.04 0 0 0 4.99 2a11.51 11.51 0 0 0-2.86.9 11.82 11.82 0 0 0-2.05 8 11.6 11.6 0 0 0 3.5 1.77c.01 0 .03 0 .04-.02.27-.36.51-.75.72-1.16a.04.04 0 0 0-.03-.06 7.66 7.66 0 0 1-1.09-.52.04.04 0 0 1 0-.08 5.96 5.96 0 0 0 .26-.17 8.28 8.28 0 0 0 7.08 0l.22.17c.02.02.02.06 0 .08-.36.2-.72.37-1.1.52a.04.04 0 0 0-.02.06c.2.4.45.8.71 1.16.01.02.03.02.05.02a11.57 11.57 0 0 0 3.52-1.8 11.74 11.74 0 0 0-2.09-7.99Zm-7.17 6.4c-.7 0-1.26-.63-1.26-1.41 0-.78.56-1.41 1.26-1.41s1.27.64 1.26 1.4c0 .79-.56 1.42-1.26 1.42Zm4.65 0c-.69 0-1.26-.63-1.26-1.41 0-.78.56-1.41 1.26-1.41s1.27.64 1.26 1.4c0 .79-.55 1.42-1.26 1.42Z" })), facebook: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7.4 14H5.06V7H3.5V4.59h1.56V3.17C5.06 1.2 5.53 0 7.6 0h1.72v2.41H8.25c-.8 0-.85.34-.85.97v1.2h1.93L9.11 7H7.4l-.01 7Z" })), figma: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { fillRule: "evenodd", d: "M9.2 0H4.8a2.6 2.6 0 0 0-1.4 4.8 2.6 2.6 0 0 0 0 4.4 2.6 2.6 0 1 0 4 2.2V8.89a2.6 2.6 0 1 0 3.2-4.09A2.6 2.6 0 0 0 9.2 0ZM7.4 7A1.8 1.8 0 1 0 11 7a1.8 1.8 0 0 0-3.6 0Zm-.8 2.6H4.8a1.8 1.8 0 1 0 1.8 1.8V9.6ZM4.8 4.4h1.8V.8H4.8a1.8 1.8 0 0 0 0 3.59Zm0 .8a1.8 1.8 0 0 0 0 3.6h1.8V5.2H4.8Zm4.4-.8H7.4V.8h1.8a1.8 1.8 0 1 1 0 3.59Z" })), gdrive: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M6.37 8.77 4.33 12.3h6.75l2.04-3.54H6.38Zm6.18-1-3.5-6.08h-4.1l3.51 6.08h4.09ZM4.38 2.7.88 8.77l2.04 3.54 3.5-6.07L4.38 2.7Z" })), github: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7 0a7 7 0 0 0-2.21 13.64c.35.06.48-.15.48-.33L5.26 12c-1.76.32-2.21-.43-2.35-.83-.08-.2-.43-.82-.72-.99-.25-.13-.6-.45-.01-.46.55 0 .94.5 1.07.72.63 1.06 1.64.76 2.04.58.07-.46.25-.77.45-.94-1.56-.18-3.19-.78-3.19-3.46 0-.76.28-1.39.72-1.88-.07-.17-.31-.9.07-1.85 0 0 .59-.19 1.93.71a6.5 6.5 0 0 1 3.5 0c1.34-.9 1.92-.71 1.92-.71.39.96.14 1.68.07 1.85.45.5.72 1.11.72 1.88 0 2.69-1.64 3.28-3.2 3.46.26.22.48.64.48 1.3l-.01 1.92c0 .18.13.4.48.33A7.01 7.01 0 0 0 7 0Z" })), gitlab: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M4.53 5.58H1.07l1.49-4.55a.26.26 0 0 1 .48 0l1.49 4.55ZM7 13.15 1.07 5.58l-.75 2.3a.5.5 0 0 0 .18.57l6.5 4.7Zm0 0 6.5-4.7a.5.5 0 0 0 .18-.57l-.75-2.3L7 13.15l2.47-7.57H4.53L7 13.15Zm2.47-7.57h3.46l-1.49-4.55a.26.26 0 0 0-.48 0L9.47 5.58Z" })), google: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M10.92 1.1H7.26c-1.64 0-3.19 1.24-3.19 2.68 0 1.47 1.12 2.66 2.8 2.66l.33-.01c-.1.2-.18.44-.18.68 0 .41.22.75.5 1.02h-.64c-2.03 0-3.6 1.3-3.6 2.64 0 1.32 1.72 2.15 3.75 2.15 2.32 0 3.6-1.31 3.6-2.64 0-1.06-.31-1.7-1.28-2.38-.33-.23-.96-.8-.96-1.14 0-.39.1-.58.7-1.04a2.46 2.46 0 0 0 1.03-1.92c0-.92-.4-1.82-1.18-2.11h1.17l.81-.6ZM9.6 10.04c.03.13.05.25.05.38 0 1.07-.7 1.9-2.67 1.9-1.4 0-2.42-.88-2.42-1.95 0-1.05 1.26-1.92 2.66-1.9a3 3 0 0 1 .92.14c.76.53 1.3.83 1.46 1.43ZM7.34 6.07c-.94-.03-1.84-1.06-2-2.3-.17-1.24.47-2.19 1.41-2.16.94.03 1.84 1.03 2 2.26.17 1.24-.47 2.23-1.41 2.2Z" })), graphql: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M7.87 11.6a1.17 1.17 0 0 0-1.7-.02l-2.71-1.56.01-.04h7.07l.02.07-2.69 1.56Zm-1.7-9.18.03.03-3.54 6.12h-.04V5.43a1.17 1.17 0 0 0 .84-1.46l2.7-1.56Zm4.38 1.56a1.17 1.17 0 0 0 .84 1.46v3.12l-.04.01-3.54-6.12c.02 0 .03-.02.04-.03l2.7 1.56ZM3.47 9.42a1.17 1.17 0 0 0-.32-.57l3.53-6.12a1.17 1.17 0 0 0 .65 0l3.54 6.12a1.17 1.17 0 0 0-.33.57H3.47Zm8.8-.74c-.1-.05-.21-.1-.32-.12V5.44a1.17 1.17 0 1 0-1.12-1.94l-2.7-1.56a1.17 1.17 0 1 0-2.24 0L3.19 3.5a1.17 1.17 0 1 0-1.13 1.94v3.12a1.17 1.17 0 1 0 1.12 1.94l2.7 1.56a1.17 1.17 0 1 0 2.24-.03l2.69-1.55a1.17 1.17 0 1 0 1.45-1.8Z" })), medium: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M0 0v14h14V0H0Zm11.63 3.32-.75.72a.22.22 0 0 0-.08.2v5.33c0 .07.03.14.08.18l.73.72v.16H7.92v-.16l.76-.74c.08-.07.08-.1.08-.21V5.24l-2.11 5.37h-.29L3.9 5.24v3.67c0 .13.05.25.14.34l.99 1.2v.16h-2.8v-.16l.98-1.2a.48.48 0 0 0 .13-.41V4.65c0-.11-.04-.2-.12-.27l-.88-1.06v-.16h2.73l2.1 4.62 1.86-4.62h2.6v.16Z" })), redux: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M4.06 9.69c.02.49.42.88.91.88H5a.91.91 0 0 0-.03-1.83h-.03c-.03 0-.08 0-.11.02a5.97 5.97 0 0 1-.85-3.62c.06-.98.39-1.82.96-2.52.47-.6 1.39-.9 2-.92 1.73-.03 2.47 2.12 2.51 2.99.22.04.57.16.82.24-.2-2.64-1.83-4-3.4-4-1.46 0-2.81 1.05-3.35 2.61a6.67 6.67 0 0 0 .65 5.68.74.74 0 0 0-.11.47Zm8.28-2.3a6.62 6.62 0 0 0-5.15-2.25h-.26a.9.9 0 0 0-.8-.49H6.1a.91.91 0 0 0 .03 1.83h.03a.92.92 0 0 0 .8-.56h.3c1.23 0 2.4.36 3.47 1.06.81.54 1.4 1.24 1.72 2.09.28.68.26 1.35-.03 1.92a2.4 2.4 0 0 1-2.23 1.34c-.65 0-1.27-.2-1.6-.34-.18.16-.5.42-.73.58.7.33 1.41.5 2.1.5 1.56 0 2.72-.85 3.16-1.72.47-.94.44-2.57-.78-3.96ZM4.9 12.9a4 4 0 0 1-.98.11c-1.2 0-2.3-.5-2.84-1.32C.38 10.6.13 8.3 2.5 6.58c.05.26.15.62.22.83-.31.23-.8.68-1.11 1.3a2.4 2.4 0 0 0 .13 2.53c.36.54.93.86 1.66.96.9.11 1.8-.05 2.66-.5a5.83 5.83 0 0 0 2.67-2.56.91.91 0 0 1 .62-1.55h.03a.92.92 0 0 1 .1 1.82 6.26 6.26 0 0 1-4.56 3.49Z" })), twitter: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M14 2.55c-.51.23-1.07.39-1.65.46.6-.36 1.05-.94 1.26-1.63-.55.34-1.17.58-1.82.72a2.84 2.84 0 0 0-2.1-.93 2.9 2.9 0 0 0-2.8 3.61 8.09 8.09 0 0 1-5.9-3.07 2.99 2.99 0 0 0 .88 3.93 2.8 2.8 0 0 1-1.3-.37v.04c0 1.42 1 2.61 2.3 2.89a2.82 2.82 0 0 1-1.3.05 2.89 2.89 0 0 0 2.7 2.04A5.67 5.67 0 0 1 0 11.51a7.98 7.98 0 0 0 4.4 1.32c5.29 0 8.17-4.48 8.17-8.38v-.38A5.93 5.93 0 0 0 14 2.55Z" })), youtube: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M13.99 8.17V5.83a14.95 14.95 0 0 0-.23-2.22c-.09-.38-.27-.7-.55-.96s-.6-.41-.97-.45A51.3 51.3 0 0 0 7 2c-2.34 0-4.09.07-5.24.2A1.78 1.78 0 0 0 .25 3.61 15.26 15.26 0 0 0 0 7v1.16a15.24 15.24 0 0 0 .24 2.22c.09.38.27.7.55.96.27.26.6.41.97.45 1.15.13 2.9.2 5.24.2 2.34 0 4.08-.06 5.24-.2.37-.04.7-.19.97-.45s.45-.58.54-.96a15.26 15.26 0 0 0 .24-2.22Zm-4.23-1.6c.16.1.24.24.24.43 0 .2-.08.33-.24.42l-4 2.5a.44.44 0 0 1-.26.08.54.54 0 0 1-.24-.06A.46.46 0 0 1 5 9.5v-5c0-.2.08-.34.26-.44.17-.1.34-.09.5.02l4 2.5Z" })), vscode: import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement("path", { d: "M10.24.04c.13 0 .26.03.38.09L13.5 1.5a.87.87 0 0 1 .5.8v.03-.01 9.39c0 .33-.2.63-.5.78l-2.88 1.38a.87.87 0 0 1-1-.17l-5.5-5.03-2.4 1.83a.58.58 0 0 1-.75-.04l-.77-.7a.58.58 0 0 1 0-.86L2.27 7 .2 5.1a.58.58 0 0 1 0-.86l.77-.7c.21-.2.52-.2.75-.04l2.4 1.83L9.63.3a.87.87 0 0 1 .61-.26Zm.26 3.78L6.32 7l4.18 3.18V3.82Z" })) };
var Svg = import_theming32.styled.svg`
  display: inline-block;
  shape-rendering: inherit;
  transform: translate3d(0, 0, 0);
  vertical-align: middle;
  fill: currentColor;

  path {
    fill: currentColor;
  }
`;
var Icons = ({ icon, useSymbol, ...props }) => import_react17.default.createElement(Svg, { viewBox: "0 0 14 14", width: "14px", height: "14px", ...props }, useSymbol ? import_react17.default.createElement("use", { xlinkHref: `#icon--${icon}` }) : icons[icon]);
var Symbols = (0, import_react17.memo)(function({ icons: keys = Object.keys(icons) }) {
  return import_react17.default.createElement(Svg, { viewBox: "0 0 14 14", style: { position: "absolute", width: 0, height: 0 }, "data-chromatic": "ignore" }, keys.map((key) => import_react17.default.createElement("symbol", { id: `icon--${key}`, key }, icons[key])));
});
var LEFT_BUTTON = 0;
var isPlainLeftClick = (e) => e.button === LEFT_BUTTON && !e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey;
var cancelled = (e, cb) => {
  isPlainLeftClick(e) && (e.preventDefault(), cb(e));
};
var LinkInner = import_theming31.styled.span(({ withArrow }) => withArrow ? { "> svg:last-of-type": { height: "0.7em", width: "0.7em", marginRight: 0, marginLeft: "0.25em", bottom: "auto", verticalAlign: "inherit" } } : {}, ({ containsIcon }) => containsIcon ? { svg: { height: "1em", width: "1em", verticalAlign: "middle", position: "relative", bottom: 0, marginRight: 0 } } : {});
var A2 = import_theming31.styled.a(({ theme }) => ({ display: "inline-block", transition: "all 150ms ease-out", textDecoration: "none", color: theme.color.secondary, "&:hover, &:focus": { cursor: "pointer", color: curriedDarken$1(0.07, theme.color.secondary), "svg path": { fill: curriedDarken$1(0.07, theme.color.secondary) } }, "&:active": { color: curriedDarken$1(0.1, theme.color.secondary), "svg path": { fill: curriedDarken$1(0.1, theme.color.secondary) } }, svg: { display: "inline-block", height: "1em", width: "1em", verticalAlign: "text-top", position: "relative", bottom: "-0.125em", marginRight: "0.4em", "& path": { fill: theme.color.secondary } } }), ({ theme, secondary, tertiary }) => {
  let colors;
  return secondary && (colors = [theme.textMutedColor, theme.color.dark, theme.color.darker]), tertiary && (colors = [theme.color.dark, theme.color.darkest, theme.textMutedColor]), colors ? { color: colors[0], "svg path": { fill: colors[0] }, "&:hover": { color: colors[1], "svg path": { fill: colors[1] } }, "&:active": { color: colors[2], "svg path": { fill: colors[2] } } } : {};
}, ({ nochrome }) => nochrome ? { color: "inherit", "&:hover, &:active": { color: "inherit", textDecoration: "underline" } } : {}, ({ theme, inverse }) => inverse ? { color: theme.color.lightest, "svg path": { fill: theme.color.lightest }, "&:hover": { color: theme.color.lighter, "svg path": { fill: theme.color.lighter } }, "&:active": { color: theme.color.light, "svg path": { fill: theme.color.light } } } : {}, ({ isButton }) => isButton ? { border: 0, borderRadius: 0, background: "none", padding: 0, fontSize: "inherit" } : {});
var Link2 = ({ cancel, children, onClick, withArrow, containsIcon, className, ...rest }) => import_react16.default.createElement(A2, { ...rest, onClick: onClick && cancel ? (e) => cancelled(e, onClick) : onClick, className }, import_react16.default.createElement(LinkInner, { withArrow, containsIcon }, children, withArrow && import_react16.default.createElement(Icons, { icon: "arrowright" })));
Link2.defaultProps = { cancel: true, className: void 0, style: void 0, onClick: void 0, withArrow: false, containsIcon: false };
var DocumentWrapper = import_theming33.styled.div(({ theme }) => ({ fontSize: `${theme.typography.size.s2}px`, lineHeight: "1.6", h1: { fontSize: `${theme.typography.size.l1}px`, fontWeight: theme.typography.weight.black }, h2: { fontSize: `${theme.typography.size.m2}px`, borderBottom: `1px solid ${theme.appBorderColor}` }, h3: { fontSize: `${theme.typography.size.m1}px` }, h4: { fontSize: `${theme.typography.size.s3}px` }, h5: { fontSize: `${theme.typography.size.s2}px` }, h6: { fontSize: `${theme.typography.size.s2}px`, color: theme.color.dark }, "pre:not(.prismjs)": { background: "transparent", border: "none", borderRadius: 0, padding: 0, margin: 0 }, "pre pre, pre.prismjs": { padding: 15, margin: 0, whiteSpace: "pre-wrap", color: "inherit", fontSize: "13px", lineHeight: "19px" }, "pre pre code, pre.prismjs code": { color: "inherit", fontSize: "inherit" }, "pre code": { margin: 0, padding: 0, whiteSpace: "pre", border: "none", background: "transparent" }, "pre code, pre tt": { backgroundColor: "transparent", border: "none" }, "body > *:first-of-type": { marginTop: "0 !important" }, "body > *:last-child": { marginBottom: "0 !important" }, a: { color: theme.color.secondary, textDecoration: "none" }, "a.absent": { color: "#cc0000" }, "a.anchor": { display: "block", paddingLeft: 30, marginLeft: -30, cursor: "pointer", position: "absolute", top: 0, left: 0, bottom: 0 }, "h1, h2, h3, h4, h5, h6": { margin: "20px 0 10px", padding: 0, cursor: "text", position: "relative", "&:first-of-type": { marginTop: 0, paddingTop: 0 }, "&:hover a.anchor": { textDecoration: "none" }, "& tt, & code": { fontSize: "inherit" } }, "h1:first-of-type + h2": { marginTop: 0, paddingTop: 0 }, "p, blockquote, ul, ol, dl, li, table, pre": { margin: "15px 0" }, hr: { border: "0 none", borderTop: `1px solid ${theme.appBorderColor}`, height: 4, padding: 0 }, "body > h1:first-of-type, body > h2:first-of-type, body > h3:first-of-type, body > h4:first-of-type, body > h5:first-of-type, body > h6:first-of-type": { marginTop: 0, paddingTop: 0 }, "body > h1:first-of-type + h2": { marginTop: 0, paddingTop: 0 }, "a:first-of-type h1, a:first-of-type h2, a:first-of-type h3, a:first-of-type h4, a:first-of-type h5, a:first-of-type h6": { marginTop: 0, paddingTop: 0 }, "h1 p, h2 p, h3 p, h4 p, h5 p, h6 p": { marginTop: 0 }, "li p.first": { display: "inline-block" }, "ul, ol": { paddingLeft: 30, "& :first-of-type": { marginTop: 0 }, "& :last-child": { marginBottom: 0 } }, dl: { padding: 0 }, "dl dt": { fontSize: "14px", fontWeight: "bold", fontStyle: "italic", margin: "0 0 15px", padding: "0 15px", "&:first-of-type": { padding: 0 }, "& > :first-of-type": { marginTop: 0 }, "& > :last-child": { marginBottom: 0 } }, blockquote: { borderLeft: `4px solid ${theme.color.medium}`, padding: "0 15px", color: theme.color.dark, "& > :first-of-type": { marginTop: 0 }, "& > :last-child": { marginBottom: 0 } }, table: { padding: 0, borderCollapse: "collapse", "& tr": { borderTop: `1px solid ${theme.appBorderColor}`, backgroundColor: "white", margin: 0, padding: 0, "& th": { fontWeight: "bold", border: `1px solid ${theme.appBorderColor}`, textAlign: "left", margin: 0, padding: "6px 13px" }, "& td": { border: `1px solid ${theme.appBorderColor}`, textAlign: "left", margin: 0, padding: "6px 13px" }, "&:nth-of-type(2n)": { backgroundColor: theme.color.lighter }, "& th :first-of-type, & td :first-of-type": { marginTop: 0 }, "& th :last-child, & td :last-child": { marginBottom: 0 } } }, img: { maxWidth: "100%" }, "span.frame": { display: "block", overflow: "hidden", "& > span": { border: `1px solid ${theme.color.medium}`, display: "block", float: "left", overflow: "hidden", margin: "13px 0 0", padding: 7, width: "auto" }, "& span img": { display: "block", float: "left" }, "& span span": { clear: "both", color: theme.color.darkest, display: "block", padding: "5px 0 0" } }, "span.align-center": { display: "block", overflow: "hidden", clear: "both", "& > span": { display: "block", overflow: "hidden", margin: "13px auto 0", textAlign: "center" }, "& span img": { margin: "0 auto", textAlign: "center" } }, "span.align-right": { display: "block", overflow: "hidden", clear: "both", "& > span": { display: "block", overflow: "hidden", margin: "13px 0 0", textAlign: "right" }, "& span img": { margin: 0, textAlign: "right" } }, "span.float-left": { display: "block", marginRight: 13, overflow: "hidden", float: "left", "& span": { margin: "13px 0 0" } }, "span.float-right": { display: "block", marginLeft: 13, overflow: "hidden", float: "right", "& > span": { display: "block", overflow: "hidden", margin: "13px auto 0", textAlign: "right" } }, "code, tt": { margin: "0 2px", padding: "0 5px", whiteSpace: "nowrap", border: `1px solid ${theme.color.mediumlight}`, backgroundColor: theme.color.lighter, borderRadius: 3, color: theme.base === "dark" && theme.color.darkest } }));
var LazySyntaxHighlighter = (0, import_react19.lazy)(() => Promise.resolve().then(() => (init_syntaxhighlighter_3EX6JOZ7(), syntaxhighlighter_3EX6JOZ7_exports)));
var LazySyntaxHighlighterWithFormatter = (0, import_react19.lazy)(async () => {
  let [{ SyntaxHighlighter: SyntaxHighlighter3 }, { formatter: formatter2 }] = await Promise.all([Promise.resolve().then(() => (init_syntaxhighlighter_3EX6JOZ7(), syntaxhighlighter_3EX6JOZ7_exports)), Promise.resolve().then(() => (init_formatter_PK6264PW(), formatter_PK6264PW_exports))]);
  return { default: (props) => import_react19.default.createElement(SyntaxHighlighter3, { ...props, formatter: formatter2 }) };
});
var Container2 = import_theming34.styled.div(({ theme, col, row = 1 }) => col ? { display: "inline-block", verticalAlign: "inherit", "& > *": { marginLeft: col * theme.layoutMargin, verticalAlign: "inherit" }, ["& > *:first-child"]: { marginLeft: 0 } } : { "& > *": { marginTop: row * theme.layoutMargin }, ["& > *:first-child"]: { marginTop: 0 } }, ({ theme, outer, col, row }) => {
  switch (true) {
    case !!(outer && col):
      return { marginLeft: outer * theme.layoutMargin, marginRight: outer * theme.layoutMargin };
    case !!(outer && row):
      return { marginTop: outer * theme.layoutMargin, marginBottom: outer * theme.layoutMargin };
    default:
      return {};
  }
});
var Title = import_theming35.styled.div(({ theme }) => ({ fontWeight: theme.typography.weight.bold }));
var Desc = import_theming35.styled.div();
var Message = import_theming35.styled.div(({ theme }) => ({ padding: 30, textAlign: "center", color: theme.color.defaultText, fontSize: theme.typography.size.s2 - 1 }));
var Placeholder = ({ children, ...props }) => {
  let [title, desc] = import_react21.Children.toArray(children);
  return import_react21.default.createElement(Message, { ...props }, import_react21.default.createElement(Title, null, title), desc && import_react21.default.createElement(Desc, null, desc));
};
var import_global4 = __toESM2(require_window());
var { window: globalWindow2 } = import_global4.default;
function browserSupportsCssZoom() {
  try {
    return globalWindow2.document.implementation.createHTMLDocument("").body.style.zoom !== void 0;
  } catch {
    return false;
  }
}
var hasBrowserSupportForCssZoom = browserSupportsCssZoom();
var ZoomElementWrapper = import_theming36.styled.div(({ scale = 1, height }) => hasBrowserSupportForCssZoom ? { "> *": { zoom: 1 / scale } } : { height: height ? height + 50 : "auto", transformOrigin: "top left", transform: `scale(${1 / scale})` });
var ButtonWrapper = import_theming37.styled.button(({ small, theme }) => ({ border: 0, borderRadius: "3em", cursor: "pointer", display: "inline-block", overflow: "hidden", padding: small ? "8px 16px" : "13px 20px", position: "relative", textAlign: "center", textDecoration: "none", transition: "all 150ms ease-out", transform: "translate3d(0,0,0)", verticalAlign: "top", whiteSpace: "nowrap", userSelect: "none", opacity: 1, margin: 0, background: "transparent", fontSize: `${small ? theme.typography.size.s1 : theme.typography.size.s2 - 1}px`, fontWeight: theme.typography.weight.bold, lineHeight: "1", svg: { display: "inline-block", height: small ? 12 : 14, width: small ? 12 : 14, verticalAlign: "top", marginRight: small ? 4 : 6, marginTop: small ? 0 : -1, marginBottom: small ? 0 : -1, pointerEvents: "none", path: { fill: "currentColor" } } }), ({ disabled }) => disabled ? { cursor: "not-allowed !important", opacity: 0.5, "&:hover": { transform: "none" } } : {}, ({ containsIcon, small }) => containsIcon ? { svg: { display: "block", margin: 0 }, ...small ? { padding: 10 } : { padding: 13 } } : {}, ({ theme, primary, secondary, gray }) => {
  let color;
  return gray ? color = theme.color.mediumlight : secondary ? color = theme.color.secondary : primary && (color = theme.color.primary), color ? { background: color, color: gray ? theme.color.darkest : theme.color.lightest, "&:hover": { background: curriedDarken$1(0.05, color) }, "&:active": { boxShadow: "rgba(0, 0, 0, 0.1) 0 0 0 3em inset" }, "&:focus": { boxShadow: `${rgba(color, 1)} 0 1px 9px 2px`, outline: "none" }, "&:focus:hover": { boxShadow: `${rgba(color, 0.2)} 0 8px 18px 0px` } } : {};
}, ({ theme, tertiary, inForm, small }) => tertiary ? { background: theme.button.background, color: theme.input.color, boxShadow: `${theme.button.border} 0 0 0 1px inset`, borderRadius: theme.input.borderRadius, ...inForm && small ? { padding: "10px 16px" } : {}, "&:hover": { background: theme.base === "light" ? curriedDarken$1(0.02, theme.button.background) : curriedLighten$1(0.03, theme.button.background), ...inForm ? {} : { boxShadow: "rgba(0,0,0,.2) 0 2px 6px 0, rgba(0,0,0,.1) 0 0 0 1px inset" } }, "&:active": { background: theme.button.background }, "&:focus": { boxShadow: `${rgba(theme.color.secondary, 1)} 0 0 0 1px inset`, outline: "none" } } : {}, ({ theme, outline }) => outline ? { boxShadow: `${curriedTransparentize$1(0.8, theme.color.defaultText)} 0 0 0 1px inset`, color: curriedTransparentize$1(0.3, theme.color.defaultText), background: "transparent", "&:hover, &:focus": { boxShadow: `${curriedTransparentize$1(0.5, theme.color.defaultText)} 0 0 0 1px inset`, outline: "none" }, "&:active": { boxShadow: `${curriedTransparentize$1(0.5, theme.color.defaultText)} 0 0 0 2px inset`, color: curriedTransparentize$1(0, theme.color.defaultText) } } : {}, ({ theme, outline, primary }) => {
  let color = theme.color.primary;
  return outline && primary ? { boxShadow: `${color} 0 0 0 1px inset`, color, "svg path": { fill: color }, "&:hover": { boxShadow: `${color} 0 0 0 1px inset`, background: "transparent" }, "&:active": { background: color, boxShadow: `${color} 0 0 0 1px inset`, color: theme.color.tertiary }, "&:focus": { boxShadow: `${color} 0 0 0 1px inset, ${rgba(color, 0.4)} 0 1px 9px 2px`, outline: "none" }, "&:focus:hover": { boxShadow: `${color} 0 0 0 1px inset, ${rgba(color, 0.2)} 0 8px 18px 0px` } } : {};
}, ({ theme, outline, primary, secondary }) => {
  let color;
  return secondary ? color = theme.color.secondary : primary && (color = theme.color.primary), outline && color ? { boxShadow: `${color} 0 0 0 1px inset`, color, "svg path": { fill: color }, "&:hover": { boxShadow: `${color} 0 0 0 1px inset`, background: "transparent" }, "&:active": { background: color, boxShadow: `${color} 0 0 0 1px inset`, color: theme.color.tertiary }, "&:focus": { boxShadow: `${color} 0 0 0 1px inset, ${rgba(color, 0.4)} 0 1px 9px 2px`, outline: "none" }, "&:focus:hover": { boxShadow: `${color} 0 0 0 1px inset, ${rgba(color, 0.2)} 0 8px 18px 0px` } } : {};
});
var ButtonLink = ButtonWrapper.withComponent("a");
var Button = Object.assign((0, import_react24.forwardRef)(function({ isLink, children, ...props }, ref) {
  return isLink ? import_react24.default.createElement(ButtonLink, { ...props, ref }, children) : import_react24.default.createElement(ButtonWrapper, { ...props, ref }, children);
}), { defaultProps: { isLink: false } });
var Wrapper3 = import_theming39.styled.label(({ theme }) => ({ display: "flex", borderBottom: `1px solid ${theme.appBorderColor}`, margin: "0 15px", padding: "8px 0", "&:last-child": { marginBottom: "3rem" } }));
var Label = import_theming39.styled.span(({ theme }) => ({ minWidth: 100, fontWeight: theme.typography.weight.bold, marginRight: 15, display: "flex", justifyContent: "flex-start", alignItems: "center", lineHeight: "16px" }));
var Field = ({ label, children, ...props }) => import_react25.default.createElement(Wrapper3, { ...props }, label ? import_react25.default.createElement(Label, null, import_react25.default.createElement("span", null, label)) : null, children);
Field.defaultProps = { label: void 0 };
var index = typeof document < "u" ? import_react28.useLayoutEffect : import_react28.useEffect;
var use_isomorphic_layout_effect_esm_default = index;
var useLatest = function(value) {
  var ref = React14.useRef(value);
  return use_isomorphic_layout_effect_esm_default(function() {
    ref.current = value;
  }), ref;
};
var updateRef = function(ref, value) {
  if (typeof ref == "function") {
    ref(value);
    return;
  }
  ref.current = value;
};
var useComposedRef = function(libRef, userRef) {
  var prevUserRef = (0, import_react29.useRef)();
  return (0, import_react29.useCallback)(function(instance) {
    libRef.current = instance, prevUserRef.current && updateRef(prevUserRef.current, null), prevUserRef.current = userRef, userRef && updateRef(userRef, instance);
  }, [userRef]);
};
var use_composed_ref_esm_default = useComposedRef;
var HIDDEN_TEXTAREA_STYLE = { "min-height": "0", "max-height": "none", height: "0", visibility: "hidden", overflow: "hidden", position: "absolute", "z-index": "-1000", top: "0", right: "0" };
var forceHiddenStyles = function(node) {
  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function(key) {
    node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], "important");
  });
};
var hiddenTextarea = null;
var getHeight = function(node, sizingData) {
  var height = node.scrollHeight;
  return sizingData.sizingStyle.boxSizing === "border-box" ? height + sizingData.borderSize : height - sizingData.paddingSize;
};
function calculateNodeHeight(sizingData, value, minRows, maxRows) {
  minRows === void 0 && (minRows = 1), maxRows === void 0 && (maxRows = 1 / 0), hiddenTextarea || (hiddenTextarea = document.createElement("textarea"), hiddenTextarea.setAttribute("tabindex", "-1"), hiddenTextarea.setAttribute("aria-hidden", "true"), forceHiddenStyles(hiddenTextarea)), hiddenTextarea.parentNode === null && document.body.appendChild(hiddenTextarea);
  var paddingSize = sizingData.paddingSize, borderSize = sizingData.borderSize, sizingStyle = sizingData.sizingStyle, boxSizing = sizingStyle.boxSizing;
  Object.keys(sizingStyle).forEach(function(_key) {
    var key = _key;
    hiddenTextarea.style[key] = sizingStyle[key];
  }), forceHiddenStyles(hiddenTextarea), hiddenTextarea.value = value;
  var height = getHeight(hiddenTextarea, sizingData);
  hiddenTextarea.value = "x";
  var rowHeight = hiddenTextarea.scrollHeight - paddingSize, minHeight = rowHeight * minRows;
  boxSizing === "border-box" && (minHeight = minHeight + paddingSize + borderSize), height = Math.max(minHeight, height);
  var maxHeight = rowHeight * maxRows;
  return boxSizing === "border-box" && (maxHeight = maxHeight + paddingSize + borderSize), height = Math.min(maxHeight, height), [height, rowHeight];
}
var noop2 = function() {
};
var pick = function(props, obj) {
  return props.reduce(function(acc, prop) {
    return acc[prop] = obj[prop], acc;
  }, {});
};
var SIZING_STYLE = ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "boxSizing", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "lineHeight", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "tabSize", "textIndent", "textRendering", "textTransform", "width", "wordBreak"];
var isIE = typeof document < "u" ? !!document.documentElement.currentStyle : false;
var getSizingData = function(node) {
  var style = window.getComputedStyle(node);
  if (style === null)
    return null;
  var sizingStyle = pick(SIZING_STYLE, style), boxSizing = sizingStyle.boxSizing;
  if (boxSizing === "")
    return null;
  isIE && boxSizing === "border-box" && (sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(sizingStyle.borderRightWidth) + parseFloat(sizingStyle.borderLeftWidth) + parseFloat(sizingStyle.paddingRight) + parseFloat(sizingStyle.paddingLeft) + "px");
  var paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop), borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);
  return { sizingStyle, paddingSize, borderSize };
};
var useWindowResizeListener = function(listener) {
  var latestListener = useLatest(listener);
  (0, import_react27.useLayoutEffect)(function() {
    var handler = function(event) {
      latestListener.current(event);
    };
    return window.addEventListener("resize", handler), function() {
      window.removeEventListener("resize", handler);
    };
  }, []);
};
var TextareaAutosize = function(_ref, userRef) {
  var cacheMeasurements = _ref.cacheMeasurements, maxRows = _ref.maxRows, minRows = _ref.minRows, _ref$onChange = _ref.onChange, onChange = _ref$onChange === void 0 ? noop2 : _ref$onChange, _ref$onHeightChange = _ref.onHeightChange, onHeightChange = _ref$onHeightChange === void 0 ? noop2 : _ref$onHeightChange, props = _objectWithoutPropertiesLoose(_ref, ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"]);
  if (props.style) {
    if ("maxHeight" in props.style)
      throw new Error("Using `style.maxHeight` for <TextareaAutosize/> is not supported. Please use `maxRows`.");
    if ("minHeight" in props.style)
      throw new Error("Using `style.minHeight` for <TextareaAutosize/> is not supported. Please use `minRows`.");
  }
  var isControlled = props.value !== void 0, libRef = (0, import_react27.useRef)(null), ref = use_composed_ref_esm_default(libRef, userRef), heightRef = (0, import_react27.useRef)(0), measurementsCacheRef = (0, import_react27.useRef)(), resizeTextarea = function() {
    var node = libRef.current, nodeSizingData = cacheMeasurements && measurementsCacheRef.current ? measurementsCacheRef.current : getSizingData(node);
    if (!!nodeSizingData) {
      measurementsCacheRef.current = nodeSizingData;
      var _calculateNodeHeight = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || "x", minRows, maxRows), height = _calculateNodeHeight[0], rowHeight = _calculateNodeHeight[1];
      heightRef.current !== height && (heightRef.current = height, node.style.setProperty("height", height + "px", "important"), onHeightChange(height, { rowHeight }));
    }
  }, handleChange = function(event) {
    isControlled || resizeTextarea(), onChange(event);
  };
  return typeof document < "u" && ((0, import_react27.useLayoutEffect)(resizeTextarea), useWindowResizeListener(resizeTextarea)), (0, import_react27.createElement)("textarea", _extends({}, props, { onChange: handleChange, ref }));
};
var index2 = (0, import_react27.forwardRef)(TextareaAutosize);
var react_textarea_autosize_esm_default = index2;
var styleResets = { appearance: "none", border: "0 none", boxSizing: "inherit", display: " block", margin: " 0", background: "transparent", padding: 0, fontSize: "inherit", position: "relative" };
var styles = ({ theme }) => ({ ...styleResets, transition: "box-shadow 200ms ease-out, opacity 200ms ease-out", color: theme.input.color || "inherit", background: theme.input.background, boxShadow: `${theme.input.border} 0 0 0 1px inset`, borderRadius: theme.input.borderRadius, fontSize: theme.typography.size.s2 - 1, lineHeight: "20px", padding: "6px 10px", "&:focus": { boxShadow: `${theme.color.secondary} 0 0 0 1px inset`, outline: "none" }, "&[disabled]": { cursor: "not-allowed", opacity: 0.5 }, "&:-webkit-autofill": { WebkitBoxShadow: `0 0 0 3em ${theme.color.lightest} inset` }, "&::placeholder": { color: theme.textMutedColor, opacity: 1 } });
var sizes = ({ size }) => {
  switch (size) {
    case "100%":
      return { width: "100%" };
    case "flex":
      return { flex: 1 };
    case "auto":
    default:
      return { display: "inline" };
  }
};
var alignment = ({ align }) => {
  switch (align) {
    case "end":
      return { textAlign: "right" };
    case "center":
      return { textAlign: "center" };
    case "start":
    default:
      return { textAlign: "left" };
  }
};
var validation = ({ valid, theme }) => {
  switch (valid) {
    case "valid":
      return { boxShadow: `${theme.color.positive} 0 0 0 1px inset !important` };
    case "error":
      return { boxShadow: `${theme.color.negative} 0 0 0 1px inset !important` };
    case "warn":
      return { boxShadow: `${theme.color.warning} 0 0 0 1px inset` };
    case void 0:
    case null:
    default:
      return {};
  }
};
var Input = Object.assign((0, import_theming40.styled)((0, import_react26.forwardRef)(function({ size, valid, align, ...props }, ref) {
  return import_react26.default.createElement("input", { ...props, ref });
}))(styles, sizes, alignment, validation, { minHeight: 32 }), { displayName: "Input" });
var Select = Object.assign((0, import_theming40.styled)((0, import_react26.forwardRef)(function({ size, valid, align, ...props }, ref) {
  return import_react26.default.createElement("select", { ...props, ref });
}))(styles, sizes, validation, { height: 32, userSelect: "none", paddingRight: 20, appearance: "menulist" }), { displayName: "Select" });
var Textarea = Object.assign((0, import_theming40.styled)((0, import_react26.forwardRef)(function({ size, valid, align, ...props }, ref) {
  return import_react26.default.createElement(react_textarea_autosize_esm_default, { ...props, ref });
}))(styles, sizes, alignment, validation, ({ height = 400 }) => ({ overflow: "visible", maxHeight: height })), { displayName: "Textarea" });
var ButtonStyled = (0, import_theming40.styled)((0, import_react26.forwardRef)(function({ size, valid, align, ...props }, ref) {
  return import_react26.default.createElement(Button, { ...props, ref });
}))(sizes, validation, { userSelect: "none", overflow: "visible", zIndex: 2, "&:hover": { transform: "none" } });
var Button3 = Object.assign((0, import_react26.forwardRef)(function(props, ref) {
  return import_react26.default.createElement(ButtonStyled, { ...props, ...{ tertiary: true, small: true, inForm: true }, ref });
}), { displayName: "Button" });
var Form = Object.assign(import_theming38.styled.form({ boxSizing: "border-box", width: "100%" }), { Field, Input, Select, Textarea, Button: Button3 });
var LazyWithTooltip = (0, import_react30.lazy)(() => Promise.resolve().then(() => (init_WithTooltip_52JYBAXX(), WithTooltip_52JYBAXX_exports)).then((mod) => ({ default: mod.WithTooltip })));
var LazyWithTooltipPure = (0, import_react30.lazy)(() => Promise.resolve().then(() => (init_WithTooltip_52JYBAXX(), WithTooltip_52JYBAXX_exports)).then((mod) => ({ default: mod.WithTooltipPure })));
var Title2 = import_theming41.styled.div(({ theme }) => ({ fontWeight: theme.typography.weight.black }));
var Desc2 = import_theming41.styled.span();
var Links = import_theming41.styled.div(({ theme }) => ({ marginTop: 8, textAlign: "center", "> *": { margin: "0 8px", fontWeight: theme.typography.weight.black } }));
var Message2 = import_theming41.styled.div(({ theme }) => ({ color: theme.color.defaultText, lineHeight: "18px" }));
var MessageWrapper = import_theming41.styled.div({ padding: 15, width: 280, boxSizing: "border-box" });
var TooltipMessage = ({ title, desc, links }) => import_react31.default.createElement(MessageWrapper, null, import_react31.default.createElement(Message2, null, title && import_react31.default.createElement(Title2, null, title), desc && import_react31.default.createElement(Desc2, null, desc)), links && import_react31.default.createElement(Links, null, links.map(({ title: linkTitle, ...other }) => import_react31.default.createElement(Link2, { ...other, key: linkTitle }, linkTitle))));
TooltipMessage.defaultProps = { title: null, desc: null, links: null };
var Note2 = import_theming42.styled.div(({ theme }) => ({ padding: "2px 6px", lineHeight: "16px", fontSize: 10, fontWeight: theme.typography.weight.bold, color: theme.color.lightest, boxShadow: "0 0 5px 0 rgba(0, 0, 0, 0.3)", borderRadius: 4, whiteSpace: "nowrap", pointerEvents: "none", zIndex: -1, background: theme.base === "light" ? "rgba(60, 60, 60, 0.9)" : "rgba(0, 0, 0, 0.95)", margin: 6 }));
var Title3 = (0, import_theming44.styled)(({ active, loading, disabled, ...rest }) => import_react34.default.createElement("span", { ...rest }))(({ theme }) => ({ color: theme.color.defaultText, fontWeight: theme.typography.weight.regular }), ({ active, theme }) => active ? { color: theme.color.primary, fontWeight: theme.typography.weight.bold } : {}, ({ loading, theme }) => loading ? { display: "inline-block", flex: "none", ...theme.animation.inlineGlow } : {}, ({ disabled, theme }) => disabled ? { color: curriedTransparentize$1(0.7, theme.color.defaultText) } : {});
var Right = import_theming44.styled.span({ "& svg": { transition: "all 200ms ease-out", opacity: 0, height: 12, width: 12, margin: "3px 0", verticalAlign: "top" }, "& path": { fill: "inherit" } }, ({ active, theme }) => active ? { "& svg": { opacity: 1 }, "& path": { fill: theme.color.primary } } : {});
var Center = import_theming44.styled.span({ flex: 1, textAlign: "left", display: "inline-flex", "& > * + *": { paddingLeft: 10 } });
var CenterText = import_theming44.styled.span({ flex: 1, textAlign: "center" }, ({ active, theme }) => active ? { color: theme.color.primary } : {}, ({ theme, disabled }) => disabled ? { color: theme.textMutedColor } : {});
var Left = import_theming44.styled.span(({ active, theme }) => active ? { "& svg": { opacity: 1 }, "& path": { fill: theme.color.primary } } : {});
var Item = import_theming44.styled.a(({ theme }) => ({ fontSize: theme.typography.size.s1, transition: "all 150ms ease-out", color: curriedTransparentize$1(0.5, theme.color.defaultText), textDecoration: "none", cursor: "pointer", justifyContent: "space-between", lineHeight: "18px", padding: "7px 15px", display: "flex", alignItems: "center", "& > * + *": { paddingLeft: 10 }, "&:hover": { background: theme.background.hoverable }, "&:hover svg": { opacity: 1 } }), ({ disabled }) => disabled ? { cursor: "not-allowed" } : {});
var getItemProps = (0, import_memoizerific4.default)(100)((onClick, href, LinkWrapper) => {
  let result = {};
  return onClick && Object.assign(result, { onClick }), href && Object.assign(result, { href }), LinkWrapper && href && Object.assign(result, { to: href, as: LinkWrapper }), result;
});
var ListItem = ({ loading, left: left2, title, center, right: right2, active, disabled, href, onClick, LinkWrapper, ...rest }) => {
  let itemProps = getItemProps(onClick, href, LinkWrapper), commonProps = { active, disabled };
  return import_react34.default.createElement(Item, { ...commonProps, ...rest, ...itemProps }, left2 && import_react34.default.createElement(Left, { ...commonProps }, left2), title || center ? import_react34.default.createElement(Center, null, title && import_react34.default.createElement(Title3, { ...commonProps, loading }, title), center && import_react34.default.createElement(CenterText, { ...commonProps }, center)) : null, right2 && import_react34.default.createElement(Right, { ...commonProps }, right2));
};
ListItem.defaultProps = { loading: false, left: null, title: import_react34.default.createElement("span", null, "Loading state"), center: null, right: null, active: false, disabled: false, href: null, LinkWrapper: null, onClick: null };
var ListItem_default = ListItem;
var List = import_theming43.styled.div({ minWidth: 180, overflow: "hidden", overflowY: "auto", maxHeight: 15.5 * 32 }, ({ theme }) => ({ borderRadius: theme.appBorderRadius * 2 }));
var Item2 = (props) => {
  let { LinkWrapper, onClick: onClickFromProps, ...rest } = props, { title, href, active } = rest, onClick = (0, import_react33.useCallback)((event) => {
    onClickFromProps(event, rest);
  }, [onClickFromProps]);
  return import_react33.default.createElement(ListItem_default, { title, active, href, LinkWrapper, ...rest, ...!!onClickFromProps ? { onClick } : {} });
};
var TooltipLinkList = ({ links, LinkWrapper }) => import_react33.default.createElement(List, null, links.map(({ isGatsby, ...p }) => import_react33.default.createElement(Item2, { key: p.id, LinkWrapper: isGatsby ? LinkWrapper : null, ...p })));
TooltipLinkList.defaultProps = { LinkWrapper: ListItem_default.defaultProps.LinkWrapper };
var Side = import_theming46.styled.div({ display: "flex", whiteSpace: "nowrap", flexBasis: "auto", flexShrink: 0, marginLeft: 3, marginRight: 3 }, ({ left: left2 }) => left2 ? { "& > *": { marginLeft: 4 } } : {}, ({ right: right2 }) => right2 ? { marginLeft: 30, "& > *": { marginRight: 4 } } : {});
Side.displayName = "Side";
var UnstyledBar = ({ children, className }) => import_react36.default.createElement(ScrollArea, { horizontal: true, vertical: false, className }, children);
var Bar = (0, import_theming46.styled)(UnstyledBar)(({ theme }) => ({ color: theme.barTextColor, width: "100%", height: 40, flexShrink: 0, overflow: "auto", overflowY: "hidden" }), ({ theme, border = false }) => border ? { boxShadow: `${theme.appBorderColor}  0 -1px 0 0 inset`, background: theme.barBg } : {});
Bar.displayName = "Bar";
var BarInner = import_theming46.styled.div(({ bgColor }) => ({ display: "flex", justifyContent: "space-between", position: "relative", flexWrap: "nowrap", flexShrink: 0, height: 40, backgroundColor: bgColor || "" }));
var FlexBar = ({ children, backgroundColor, ...rest }) => {
  let [left2, right2] = import_react36.Children.toArray(children);
  return import_react36.default.createElement(Bar, { ...rest }, import_react36.default.createElement(BarInner, { bgColor: backgroundColor }, import_react36.default.createElement(Side, { left: true }, left2), right2 ? import_react36.default.createElement(Side, { right: true }, right2) : null));
};
FlexBar.displayName = "FlexBar";
var ButtonOrLink = ({ children, ...restProps }) => restProps.href != null ? import_react37.default.createElement("a", { ...restProps }, children) : import_react37.default.createElement("button", { type: "button", ...restProps }, children);
var TabButton = (0, import_theming47.styled)(ButtonOrLink, { shouldForwardProp: import_theming47.isPropValid })({ whiteSpace: "normal", display: "inline-flex", overflow: "hidden", verticalAlign: "top", justifyContent: "center", alignItems: "center", textAlign: "center", textDecoration: "none", "&:empty": { display: "none" } }, ({ theme }) => ({ padding: "0 15px", transition: "color 0.2s linear, border-bottom-color 0.2s linear", height: 40, lineHeight: "12px", cursor: "pointer", background: "transparent", border: "0 solid transparent", borderTop: "3px solid transparent", borderBottom: "3px solid transparent", fontWeight: "bold", fontSize: 13, "&:focus": { outline: "0 none", borderBottomColor: theme.color.secondary } }), ({ active, textColor, theme }) => active ? { color: textColor || theme.barSelectedColor, borderBottomColor: theme.barSelectedColor } : { color: textColor || theme.barTextColor, borderBottomColor: "transparent" });
TabButton.displayName = "TabButton";
var IconButton = (0, import_theming47.styled)(ButtonOrLink, { shouldForwardProp: import_theming47.isPropValid })(() => ({ alignItems: "center", background: "transparent", border: "none", borderRadius: 4, color: "inherit", cursor: "pointer", display: "inline-flex", fontSize: 13, fontWeight: "bold", height: 28, justifyContent: "center", marginTop: 6, padding: "8px 7px", "& > svg": { width: 14 } }), ({ active, theme }) => active ? { backgroundColor: theme.background.hoverable, color: theme.color.secondary } : {}, ({ disabled, theme }) => disabled ? { opacity: 0.5, cursor: "not-allowed" } : { "&:hover, &:focus-visible": { background: curriedTransparentize$1(0.88, theme.color.secondary), color: theme.color.secondary }, "&:focus-visible": { outline: auto }, "&:focus:not(:focus-visible)": { outline: "none" } });
IconButton.displayName = "IconButton";
var IconPlaceholder = import_theming47.styled.div(({ theme }) => ({ width: 14, height: 14, backgroundColor: theme.appBorderColor, animation: `${theme.animation.glow} 1.5s ease-in-out infinite` }));
var IconButtonSkeletonWrapper = import_theming47.styled.div(() => ({ marginTop: 6, padding: 7, height: 28 }));
var Wrapper22 = import_theming45.styled.div(({ theme, bordered }) => bordered ? { backgroundClip: "padding-box", border: `1px solid ${theme.appBorderColor}`, borderRadius: theme.appBorderRadius, overflow: "hidden", boxSizing: "border-box" } : {}, ({ absolute }) => absolute ? { width: "100%", height: "100%", boxSizing: "border-box", display: "flex", flexDirection: "column" } : { display: "block" });
var TabBar = import_theming45.styled.div({ overflow: "hidden", "&:first-of-type": { marginLeft: -3 } });
var Content2 = import_theming45.styled.div({ display: "block", position: "relative" }, ({ theme }) => ({ fontSize: theme.typography.size.s2 - 1, background: theme.background.content }), ({ bordered, theme }) => bordered ? { borderRadius: `0 0 ${theme.appBorderRadius - 1}px ${theme.appBorderRadius - 1}px` } : {}, ({ absolute, bordered }) => absolute ? { height: `calc(100% - ${bordered ? 42 : 40}px)`, position: "absolute", left: 0 + (bordered ? 1 : 0), right: 0 + (bordered ? 1 : 0), bottom: 0 + (bordered ? 1 : 0), top: 40 + (bordered ? 1 : 0), overflow: "auto", ["& > *:first-child"]: { position: "absolute", left: 0 + (bordered ? 1 : 0), right: 0 + (bordered ? 1 : 0), bottom: 0 + (bordered ? 1 : 0), top: 0 + (bordered ? 1 : 0), height: `calc(100% - ${bordered ? 2 : 0}px)`, overflow: "auto" } } : {});
var VisuallyHidden = import_theming45.styled.div(({ active }) => active ? { display: "block" } : { display: "none" });
var childrenToList = (children, selected) => import_react35.Children.toArray(children).map(({ props: { title, id, color, children: childrenOfChild } }, index3) => {
  let content = Array.isArray(childrenOfChild) ? childrenOfChild[0] : childrenOfChild;
  return { active: selected ? id === selected : index3 === 0, title, id, color, render: typeof content == "function" ? content : ({ active, key }) => import_react35.default.createElement(VisuallyHidden, { key, active, role: "tabpanel" }, content) };
});
var Tabs = (0, import_react35.memo)(({ children, selected, actions, absolute, bordered, tools, backgroundColor, id: htmlId }) => {
  let list = childrenToList(children, selected);
  return list.length ? import_react35.default.createElement(Wrapper22, { absolute, bordered, id: htmlId }, import_react35.default.createElement(FlexBar, { border: true, backgroundColor }, import_react35.default.createElement(TabBar, { role: "tablist" }, list.map(({ title, id, active, color }) => {
    let tabTitle = typeof title == "function" ? title() : title;
    return import_react35.default.createElement(TabButton, { id: `tabbutton-${sanitize(tabTitle)}`, className: `tabbutton ${active ? "tabbutton-active" : ""}`, type: "button", key: id, active, textColor: color, onClick: (e) => {
      e.preventDefault(), actions.onSelect(id);
    }, role: "tab" }, tabTitle);
  })), tools ? import_react35.default.createElement(import_react35.Fragment, null, tools) : null), import_react35.default.createElement(Content2, { id: "panel-tab-content", bordered, absolute }, list.map(({ id, active, render }) => render({ key: id, active })))) : import_react35.default.createElement(Placeholder, null, import_react35.default.createElement(import_react35.Fragment, { key: "title" }, "Nothing found"));
});
Tabs.displayName = "Tabs";
Tabs.defaultProps = { id: null, children: null, tools: null, selected: null, absolute: false, bordered: false };
var TabsState = class extends import_react35.Component {
  constructor(props) {
    super(props);
    this.handlers = { onSelect: (id) => this.setState({ selected: id }) };
    this.state = { selected: props.initial };
  }
  render() {
    let { bordered = false, absolute = false, children, backgroundColor } = this.props, { selected } = this.state;
    return import_react35.default.createElement(Tabs, { bordered, absolute, selected, backgroundColor, actions: this.handlers }, children);
  }
};
TabsState.defaultProps = { children: [], initial: null, absolute: false, bordered: false, backgroundColor: "" };
var Separator = import_theming48.styled.span(({ theme }) => ({ width: 1, height: 20, background: theme.appBorderColor, marginTop: 10, marginLeft: 6, marginRight: 2 }), ({ force }) => force ? {} : { "& + &": { display: "none" } });
Separator.displayName = "Separator";
var rotate360 = import_theming50.keyframes`
	from {
		transform: rotate(0deg);
	}
	to {
		transform: rotate(360deg);
	}
`;
var LoaderWrapper = import_theming49.styled.div(({ size = 32 }) => ({ borderRadius: "50%", cursor: "progress", display: "inline-block", overflow: "hidden", position: "absolute", transition: "all 200ms ease-out", verticalAlign: "top", top: "50%", left: "50%", marginTop: -(size / 2), marginLeft: -(size / 2), height: size, width: size, zIndex: 4, borderWidth: 2, borderStyle: "solid", borderColor: "rgba(97, 97, 97, 0.29)", borderTopColor: "rgb(100,100,100)", animation: `${rotate360} 0.7s linear infinite`, mixBlendMode: "difference" }));
var ProgressWrapper = import_theming49.styled.div({ position: "absolute", display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", width: "100%", height: "100%" });
var ProgressTrack = import_theming49.styled.div(({ theme }) => ({ position: "relative", width: "80%", marginBottom: "0.75rem", maxWidth: 300, height: 5, borderRadius: 5, background: curriedTransparentize$1(0.8, theme.color.secondary), overflow: "hidden", cursor: "progress" }));
var ProgressBar = import_theming49.styled.div(({ theme }) => ({ position: "absolute", top: 0, left: 0, height: "100%", background: theme.color.secondary }));
var ProgressMessage = import_theming49.styled.div(({ theme }) => ({ minHeight: "2em", fontSize: `${theme.typography.size.s1}px`, color: theme.barTextColor }));
var ErrorIcon = (0, import_theming49.styled)(Icons)(({ theme }) => ({ width: 20, height: 20, marginBottom: "0.5rem", color: theme.textMutedColor }));
var ellipsis = import_theming49.keyframes`
  from { content: "..." }
  33% { content: "." }
  66% { content: ".." }
  to { content: "..." }
`;
var Ellipsis = import_theming49.styled.span({ "&::after": { content: "'...'", animation: `${ellipsis} 1s linear infinite`, animationDelay: "1s", display: "inline-block", width: "1em", height: "auto" } });
var resetComponents = {};
Object.keys(components).forEach((key) => {
  resetComponents[key] = (0, import_react11.forwardRef)((props, ref) => (0, import_react11.createElement)(key, { ...props, ref }));
});

// src/panel/task-result/expanding-result.tsx
var import_react46 = require("@xstate/react");

// src/use-required-context.ts
var import_react43 = require("react");

// ../../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// src/use-required-context.ts
function useRequiredContext(Context2) {
  const value = (0, import_react43.useContext)(Context2);
  invariant(value, "Could not find context value");
  return value;
}

// src/panel/service-context.ts
var import_react44 = __toESM(require("react"));
var service_context_default = import_react44.default.createContext(null);

// src/util/pluralise.ts
function pluralise({ value, single, multiple }) {
  return value === 1 ? single : multiple;
}
function pluraliseCopies(copies) {
  return pluralise({ value: copies, single: "copy", multiple: "copies" });
}
function pluraliseSamples(samples) {
  return pluralise({ value: samples, single: "sample", multiple: "samples" });
}

// src/panel/next-events-include.ts
function nextEventsInclude(name, events) {
  return events.includes(name);
}

// src/panel/task-result/expanding-result.tsx
var Container3 = import_theming51.styled.div`
  --result-border-radius: 4px;
  margin-bottom: var(--grid);
  border: 1px solid lightgray;
  border-radius: var(--result-border-radius);
`;
var HeaderButton = import_theming51.styled.button`
  /* reset */
  margin: 0;
  padding: 0;
  border: none;

  width: 100%;
  height: calc(var(--grid) * 4);
  text-align: left;
  font-size: 16px;
  font-weight: bold;

  border-radius: var(--result-border-radius);
  background-color: ${(props) => props.theme.background.content};
  color: ${(props) => props.theme.color.defaultText};

  display: flex;
  align-items: center;
  padding: 0 var(--grid);

  > * {
    margin-left: var(--grid);
    flex-shrink: 0;
  }
`;
var Name = import_theming51.styled.h4`
  /* the name will push the result over, it can also collapse when there is no room */
  flex-grow: 1;
  flex-shrink: 1;
  font-weight: bold;

  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
`;
var IconContainer = import_theming51.styled.span`
  margin-left: 0;
  width: var(--grid);
  height: var(--grid);
`;
function ExpandIcon({ isExpanded }) {
  return /* @__PURE__ */ import_react45.default.createElement(IconContainer, null, /* @__PURE__ */ import_react45.default.createElement(Icons, { icon: isExpanded ? "arrowdown" : "arrowright" }));
}
function ExpandingResult({ name, result, getExpanded }) {
  const [isExpanded, setIsExpanded] = (0, import_react45.useState)(false);
  const toggle = (0, import_react45.useCallback)(() => setIsExpanded((value) => !value), [setIsExpanded]);
  const service = useRequiredContext(service_context_default);
  const [state, send] = (0, import_react46.useActor)(service);
  const expanded = getExpanded({ isExpanded });
  const { copies, samples } = state.context.current;
  return /* @__PURE__ */ import_react45.default.createElement(Container3, null, /* @__PURE__ */ import_react45.default.createElement(HeaderButton, { onClick: toggle, isExpanded, "aria-expanded": isExpanded }, /* @__PURE__ */ import_react45.default.createElement(ExpandIcon, { isExpanded }), /* @__PURE__ */ import_react45.default.createElement(Name, null, name), result), isExpanded ? /* @__PURE__ */ import_react45.default.createElement(Section, null, /* @__PURE__ */ import_react45.default.createElement(
    Button,
    {
      secondary: true,
      small: true,
      disabled: !nextEventsInclude("START_ONE", state.nextEvents),
      onClick: () => send({ type: "START_ONE", taskName: name })
    },
    "Run task",
    " ",
    /* @__PURE__ */ import_react45.default.createElement("small", null, "(", copies, " ", pluraliseCopies(copies), ", ", samples, " ", pluraliseSamples(samples), ")")
  ), expanded) : null);
}
